{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":344770313,"authorName":"Colin Green","from":"Colin Green &lt;colin.green1@...&gt;","profile":"alienseedpod","replyTo":"LIST","senderId":"tST9P_oFHf8aZw13gqOeVWI0nYj7llvaYu_z8-cGWRCJQ__avtfVbmE7ZB85OCI6bRFUWc-gGGw0t5Jufd25GBCjwF87yt-cidEiZklur7Q","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Re: about the innovation number","postDate":"1245967769","msgId":4715,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDcyN2E0MDZjMDkwNjI1MTUwOXQ3OWZiNDJlOWo1NTA5Nzc3ZDYwODFkOWVmQG1haWwuZ21haWwuY29tPg==","inReplyToHeader":"PDc3MzEyRDZBQ0VDRjQxQUE4NDlCNTFBN0FEMDA0QzM2QEtlblBDPg==","referencesHeader":"PGgxdnFtcCtwZG9qQGVHcm91cHMuY29tPiA8NzczMTJENkFDRUNGNDFBQTg0OUI1MUE3QUQwMDRDMzZAS2VuUEM+"},"prevInTopic":4714,"nextInTopic":4716,"prevInTime":4714,"nextInTime":4716,"topicId":4711,"numMessagesInTopic":15,"msgSnippet":"Hi, ... Not especially but I did decide to use two separate incrementing counters, one for neurons and one for connections. The two types of gene have their","rawEmail":"Return-Path: &lt;colin.green1@...&gt;\r\nX-Sender: colin.green1@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 32114 invoked from network); 25 Jun 2009 22:09:34 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m5.grp.sp2.yahoo.com with QMQP; 25 Jun 2009 22:09:34 -0000\r\nX-Received: from unknown (HELO mail-yx0-f192.google.com) (209.85.210.192)\n  by mta3.grp.sp2.yahoo.com with SMTP; 25 Jun 2009 22:09:34 -0000\r\nX-Received: by yxe30 with SMTP id 30so8759345yxe.6\n        for &lt;neat@yahoogroups.com&gt;; Thu, 25 Jun 2009 15:09:29 -0700 (PDT)\r\nMIME-Version: 1.0\r\nX-Received: by 10.90.68.20 with SMTP id q20mr2465923aga.104.1245967769614; Thu, \n\t25 Jun 2009 15:09:29 -0700 (PDT)\r\nIn-Reply-To: &lt;77312D6ACECF41AA849B51A7AD004C36@KenPC&gt;\r\nReferences: &lt;h1vqmp+pdoj@...&gt; &lt;77312D6ACECF41AA849B51A7AD004C36@KenPC&gt;\r\nDate: Thu, 25 Jun 2009 23:09:29 +0100\r\nMessage-ID: &lt;727a406c0906251509t79fb42e9j5509777d6081d9ef@...&gt;\r\nTo: neat@yahoogroups.com\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Colin Green &lt;colin.green1@...&gt;\r\nSubject: Re: [neat] Re: about the innovation number\r\nX-Yahoo-Group-Post: member; u=344770313; y=Px0huPsjhMWN1nDO-CwX8CdPqNHbz-ysehNlmn7jGvppl-40Mj-c\r\nX-Yahoo-Profile: alienseedpod\r\n\r\nHi,\n\n2009/6/25 Ken Lloyd &lt;kalloyd@...&gt;:\n&gt;\n&gt; Did anyone else find it=\r\n problematic that the NeuronGeneId was generated\n&gt; just=A0like the Innovati=\r\nonId for the ConnectionGene?\n\nNot especially but I did decide to use two se=\r\nparate incrementing\ncounters, one for neurons and one for connections. The =\r\ntwo types of\ngene have their own &#39;ID&#39; space. I think my main motivation was=\r\n to\nprevent the ID space from being exhausted - y&#39;know if some day this\nbec=\r\nomes distributed neat and/or running on much faster hardware and/or\nfor lon=\r\ng timescales. I like to over engineer shall we say.\n\n\n\n\n&gt; In my implementat=\r\nion, I\n&gt; decided to use a GUID for gene identification, and only use the in=\r\nnovation\n&gt; number for sequencing (aging)=A0the connection genes - substanti=\r\nally reducing\n&gt; the range of the innovation numbers.\n\nWell, a GUID is 4 byt=\r\nes which is a bit of overkill (a bit rich given\nmy previous sentence :), al=\r\nso if you use standard approaches of\ngenerating GUID&#39;s they will have some =\r\nproblems.\n\n1) Performance. GUIDs are typically a hash of hardware IDs (netw=\r\nork\ncard MAC and other things), current time, and any other source of\nrando=\r\nmness such as a background service that measures the interval\nbetween key p=\r\nresses. These all sap performance and can also result in\nclusters of very c=\r\nlose GUIDs if you ask for a few (or many) in a short\ntime period (e.g. with=\r\nin a 50/th of a second).\n\n2) The uses of hardware IDs also means you probab=\r\nly are generating IDs\nwithin a narrow sub-set of all possibke IDs - that is=\r\n you get the\noverhead of dealing with 4 bytes without the benefits of more =\r\nIDs.\nThis also means that GUID clashes might occur - an incrementing value\n=\r\ngives you efficient utilization of the availablke ID space.\n\nOK on the othe=\r\nr hand a GUID might be a good solution in a distributed\nsetting - you can g=\r\nenerate a GUID with practical zero chance of\nclashing with GUIDs generated =\r\non other machines. However you still\nneed a central register of all IDs fro=\r\nm all machines in order re-use\nIDs correctly when adding new nodes and conn=\r\nections.\n\n\n&gt; The search space for identifying=A0identical preexisting conne=\r\nctions is always\n&gt; problematic (due to the time penalty it imposes), even i=\r\nf done=A0efficiently.\n&gt; How about a small=A0static structure similar to=A0a=\r\n=A0step function CPPN (ok, just\n&gt; an array, diagonalized of course) to take=\r\n the endpoints of connections=A0as\n&gt; inputs and generate a value (1 or (tru=\r\ne)=A0=3D prior exists, 0 =3D it doesn&#39;t).\n&gt; Here, using=A0the endpoint GUID=\r\ns=A0keeps the array small enough, only=A0encoding\n&gt; surviving searchable ne=\r\nurons.\n\nI /think/ you&#39;re effectively describing a hashmap that uses the\ncon=\r\nnection endpoints as a key and stores the connection ID as the\nmapped value=\r\n. This is what sharpneat does, however I think the hashmap\nis discarded aft=\r\ner each generation (so we ensure ID use only within a\ngeneration). Sharpnea=\r\nt 2 takes a more pragmatic approach of keeping a\npermanent history of innov=\r\nation IDs keyed by endpoints as before, but\nthe history length is limited (=\r\nit&#39;s a hybrid of a circular buffer and\na hashmap) so as to prevent it expan=\r\nding indefinitely and consuming\nall memory and increasing lookup time.\n\nBTW=\r\n Coding on V2 will resume shortly - I&#39;ve been busy with moving and\nstuff th=\r\ne last few months. I&#39;ve also been catching up on HyperNeat and\nnovelty sear=\r\nch papers, so hopefully this help me design the code to\nassist in these res=\r\nearch directions.\n\nColin.\n\n"}}