{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":54567749,"authorName":"Ken","from":"&quot;Ken&quot; &lt;kstanley@...&gt;","profile":"kenstanley01","replyTo":"LIST","senderId":"GCapvz7zLPNJQ9z1LHqzoT_PS5LIj_FPVFdEOsy_yjRgb5R_2N67_WghFIcjTb0xk9S4CUfG4eHiQlE24KLp71_XPWzH","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: Evolving feedforward networks","postDate":"1260918706","msgId":5018,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGhnOTUzaStwanVzQGVHcm91cHMuY29tPg==","inReplyToHeader":"PDcyN2E0MDZjMDkxMjE0MTMzNnYyZWUxOTA3MGo0YzczM2MyMjM4ZGNhMWE0QG1haWwuZ21haWwuY29tPg=="},"prevInTopic":5017,"nextInTopic":5021,"prevInTime":5017,"nextInTime":5019,"topicId":5013,"numMessagesInTopic":14,"msgSnippet":"Colin, one thing that comes to mind is the way Mat Buckland s implementation addresses the issue of detecting potential recurrent links efficiently.  I think","rawEmail":"Return-Path: &lt;kstanley@...&gt;\r\nX-Sender: kstanley@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 72057 invoked from network); 15 Dec 2009 23:11:51 -0000\r\nX-Received: from unknown (66.196.94.105)\n  by m2.grp.sp2.yahoo.com with QMQP; 15 Dec 2009 23:11:51 -0000\r\nX-Received: from unknown (HELO n43d.bullet.mail.sp1.yahoo.com) (66.163.169.157)\n  by mta1.grp.re1.yahoo.com with SMTP; 15 Dec 2009 23:11:51 -0000\r\nX-Received: from [69.147.65.150] by n43.bullet.mail.sp1.yahoo.com with NNFMP; 15 Dec 2009 23:11:48 -0000\r\nX-Received: from [98.137.34.73] by t7.bullet.mail.sp1.yahoo.com with NNFMP; 15 Dec 2009 23:11:48 -0000\r\nDate: Tue, 15 Dec 2009 23:11:46 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;hg953i+pjus@...&gt;\r\nIn-Reply-To: &lt;727a406c0912141336v2ee19070j4c733c2238dca1a4@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;Ken&quot; &lt;kstanley@...&gt;\r\nSubject: Re: Evolving feedforward networks\r\nX-Yahoo-Group-Post: member; u=54567749; y=fpBF9l4B6On3DpCCJxrdKcrojEJuvHItNDHeh_ry2VK1pjLpaapz\r\nX-Yahoo-Profile: kenstanley01\r\n\r\n\n\nColin, one thing that comes to mind is the way Mat Buckland&#39;s implementat=\r\nion addresses the issue of detecting potential recurrent links efficiently.=\r\n  I think we might have discussed this approach on this group a long time a=\r\ngo?  The basic idea is that each node has a &quot;row-level&quot; floating point numb=\r\ner.  The inputs are row-level 0 and the outputs are row-level 1.  Every tim=\r\ne a new node is added that splits a feedforward link, it gets a row-level h=\r\nalfway between the source and target nodes.  For example, if it split a lin=\r\nk between rows 0 and 1, it would have row-level 0.5.  Now to determine whet=\r\nher a potential link would be recurrent, all you need to do is check whethe=\r\nr it connected a source node to a target node at an equivalent or lower row=\r\n-level.\n\nI believe the only catch is what to do when splitting already-recu=\r\nrrent connections.  However, if you are just trying to create strictly feed=\r\nforward networks, they won&#39;t exist, so it won&#39;t be an issue.\n\nIt&#39;s possible=\r\n I got some part of the procedure slightly wrong in the description above, =\r\nbut I believe that is the gist of it.\n\nken\n\n--- In neat@yahoogroups.com, Co=\r\nlin Green &lt;colin.green1@...&gt; wrote:\n&gt;\n&gt; Hi,\n&gt; \n&gt; Ken&#39;s response to Daniel T=\r\nuohy&#39;s yesterday briefly touched on\n&gt; evolution of feedforward-only network=\r\ns and this is somethign I&#39;ve been\n&gt; meaning to think about for some time. M=\r\ny initial thoughts on how to do\n&gt; this relatively efficiently are as follow=\r\ns:\n&gt; \n&gt; 1) Start out with a feedforward only graph (e.g. the typical NEAT\n&gt;=\r\n initial population with conenctions from inputs to outputs).\n&gt; 2) We initi=\r\nalise each node with a list of all the nodes that are above\n&gt; it in the gra=\r\nph, let&#39;s call this the &#39;ancestor&#39; list (A-list or A-node\n&gt; list for short)=\r\n\n&gt; 3) With recursive networks, in order to add a connection we typically\n&gt; =\r\nrandomly search pairs of source and target node IDs until we find a\n&gt; pair =\r\nthat does not exist in the existign connection genes. Now we can\n&gt; add the =\r\nadditional test that the target node ID is not in the source\n&gt; node&#39;s A-lis=\r\nt. This eliminates the need to traverse the network,\n&gt; effectively recalcul=\r\nating each node&#39;s A-List each time.\n&gt; 4) When we create a new node by split=\r\nting a conenction, the new node\n&gt; creates it&#39;s own A-list by takign a copy =\r\nthe source node&#39;s A-List plus\n&gt; the source node&#39;s ID.\n&gt; \n&gt; The A-lists can =\r\nbecome part of the genome so that we never have to\n&gt; traverse networks to r=\r\nebuild A-lists, they just get copied when we\n&gt; create offspring genomes/net=\r\nworks. Ok so now you&#39;re all thinking that\n&gt; the memory requirements for thi=\r\ns could get unwieldy. We can reduce\n&gt; memory requirements by using bitmaps =\r\nwhere each node ID get&#39;s it&#39;s own\n&gt; location in an array of bits, thus if t=\r\nhe IDs are 32bit integers we\n&gt; get a 32x reduction in storage space require=\r\nments. As a bonus, testing\n&gt; if a node is in a given A-list should be almos=\r\nt intantaneous, versus\n&gt; the O(log n) time complexity of a binary search ag=\r\nainst a sorted list\n&gt; of integer IDs.\n&gt; \n&gt; The first problem I see is that =\r\nthe set of innovation IDs currently in\n&gt; use in a given population becomes =\r\npatchy, e.g. some early IDs may\n&gt; simply not exist any more (although I&#39;m n=\r\not 100% if this happens in\n&gt; reality). So lets say NEAT has been running a =\r\nwhile and the innovation\n&gt; ID variable is up to 100,000. Each node requires=\r\n its own bit in each\n&gt; A-list regardless of whether it is set or not, there=\r\nfore the A-lists\n&gt; are 100000/8 =3D 12,500 bytes in size (I&#39;m assuming the =\r\nA-lists grow\n&gt; over time, along with the innovation ID counter). We can how=\r\never\n&gt; reduce this memory requirement by periodically stoppign NEAT and\n&gt; d=\r\nefragmenting the ID space, this allows us to reuse the low IDs that\n&gt; are n=\r\no longer in use anymore (no node anywhere in the population uses\n&gt; it) and =\r\nthus the size of the A-list only needs to refelct the number\n&gt; of /active/ =\r\nnode IDs rather than the number of IDs there has ever\n&gt; been.\n&gt; \n&gt; Thinking=\r\n ahead to distributed-NEAT algorithms this potentially creates\n&gt; a new prob=\r\nlem when/if we need to pass genome between clusteres - the\n&gt; node IDs of li=\r\nke nodes no longer match up. The proposed solution there\n&gt; is to have a per=\r\niodic system wide defragmentation take place\n&gt; encompassing all nodes, or a=\r\nlternatively each distribution node\n&gt; maintains a mapping between &#39;global&#39; =\r\ninnovation IDs and the local\n&gt; defragmented IDs.\n&gt; \n&gt; I&#39;d be interested hea=\r\nr other&#39;s ideas on this topic. Perhaps there&#39;s\n&gt; some more elegant approach=\r\n using clever allocation of IDs to indicate\n&gt; where a node lies in the netw=\r\nork of ancestors, e.g. if node IDs are\n&gt; taken to be a height measured from=\r\n top to bottom of the network, we\n&gt; can assign and modify node IDs so that =\r\nwe can simply compare two IDs\n&gt; to see their relative position in the top-d=\r\nown graph - the problem\n&gt; there being that we can no longer use the IDs as =\r\ninnovation numbers;\n&gt; However we could simply use two variables - innovatio=\r\nn ID and a\n&gt; height/position. One downside there is that only one node can =\r\noccupy a\n&gt; given height and since the number of height levels is limits (e.=\r\ng. to\n&gt; 2^32 for a 32 bit variable) the number of nodes in a network is\n&gt; l=\r\nimited, on the other hand that&#39;s potentially a very high limit.\n&gt; Perhaps t=\r\nhe tricky part is decidign what to do when mating two\n&gt; networks.\n&gt; \n&gt; This=\r\n post is already too long so I&#39;m going to stop :)\n&gt; \n&gt; Colin\n&gt;\n\n\n\n"}}