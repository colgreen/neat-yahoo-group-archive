{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":37465196,"authorName":"Ken Lloyd","from":"&quot;Ken Lloyd&quot; &lt;kalloyd@...&gt;","profile":"kalloyd2","replyTo":"LIST","senderId":"6rfvfiSFrqZj3g0DyjVWfZZ2voDSbkDHarZ-BG1HnxhBTy_H-9IYHZfhSLWcEma3rQIkWyhFyvt6WxTfy6zwKFCWm6sWmG6M","spamInfo":{"isSpam":false,"reason":"12"},"subject":"RE: [neat] Evolving feedforward networks","postDate":"1260838982","msgId":5014,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDA4RTE4ODI3M0RCOTQ4RDZBOTY2QTkyN0EzMDMxRDY4QHdhdHRwND4=","inReplyToHeader":"PDcyN2E0MDZjMDkxMjE0MTMzNnYyZWUxOTA3MGo0YzczM2MyMjM4ZGNhMWE0QG1haWwuZ21haWwuY29tPg==","referencesHeader":"PDcyN2E0MDZjMDkxMjE0MTMzNnYyZWUxOTA3MGo0YzczM2MyMjM4ZGNhMWE0QG1haWwuZ21haWwuY29tPg=="},"prevInTopic":5013,"nextInTopic":5015,"prevInTime":5013,"nextInTime":5015,"topicId":5013,"numMessagesInTopic":14,"msgSnippet":"Colin, Do you think a feed-forward network can have recurrent paths?  In other words, must it be strictly feed-forward? Or can it generally exhibit forward","rawEmail":"Return-Path: &lt;kalloyd@...&gt;\r\nX-Sender: kalloyd@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 59516 invoked from network); 15 Dec 2009 01:03:15 -0000\r\nX-Received: from unknown (66.196.94.105)\n  by m1.grp.sp2.yahoo.com with QMQP; 15 Dec 2009 01:03:15 -0000\r\nX-Received: from unknown (HELO QMTA15.emeryville.ca.mail.comcast.net) (76.96.27.228)\n  by mta1.grp.re1.yahoo.com with SMTP; 15 Dec 2009 01:03:14 -0000\r\nX-Received: from OMTA09.emeryville.ca.mail.comcast.net ([76.96.30.20])\n\tby QMTA15.emeryville.ca.mail.comcast.net with comcast\n\tid HC9s1d0010S2fkCAFD3270; Tue, 15 Dec 2009 01:03:02 +0000\r\nX-Received: from wattp4 ([174.56.66.94])\n\tby OMTA09.emeryville.ca.mail.comcast.net with comcast\n\tid HD311d00D221HGW8VD31V7; Tue, 15 Dec 2009 01:03:02 +0000\r\nTo: &lt;neat@yahoogroups.com&gt;\r\nReferences: &lt;727a406c0912141336v2ee19070j4c733c2238dca1a4@...&gt;\r\nDate: Mon, 14 Dec 2009 18:03:02 -0700\r\nMessage-ID: &lt;08E188273DB948D6A966A927A3031D68@wattp4&gt;\r\nMIME-Version: 1.0\r\nContent-Type: multipart/alternative;\n\tboundary=&quot;----=_NextPart_000_043F_01CA7CE7.AE5CB000&quot;\r\nX-Mailer: Microsoft Office Outlook 11\r\nThread-Index: Acp9BlyUOuU2snYdRVmrmq9VTImEFAAG6OdA\r\nIn-Reply-To: &lt;727a406c0912141336v2ee19070j4c733c2238dca1a4@...&gt;\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.5579\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Ken Lloyd&quot; &lt;kalloyd@...&gt;\r\nSubject: RE: [neat] Evolving feedforward networks\r\nX-Yahoo-Group-Post: member; u=37465196; y=vpBmK8TcA4zjITP5nlCxI98CXgNFjy8XqJCcHcU6gq1GS4o\r\nX-Yahoo-Profile: kalloyd2\r\n\r\n\r\n------=_NextPart_000_043F_01CA7CE7.AE5CB000\r\nContent-Type: text/plain;\n\tcharset=&quot;US-ASCII&quot;\r\nContent-Transfer-Encoding: 7bit\r\n\r\nColin,\n \nDo you think a feed-forward network can have recurrent paths?  In other\nwords, must it be &quot;strictly&quot; feed-forward? Or can it generally exhibit\nforward directional traits?\n \nKen Lloyd\n\n\n  _____  \n\nFrom: neat@yahoogroups.com [mailto:neat@yahoogroups.com] On Behalf Of Colin\nGreen\nSent: Monday, December 14, 2009 2:37 PM\nTo: neat@yahoogroups.com\nSubject: [neat] Evolving feedforward networks\n\n\n  \n\nHi,\n\nKen&#39;s response to Daniel Tuohy&#39;s yesterday briefly touched on\nevolution of feedforward-only networks and this is somethign I&#39;ve been\nmeaning to think about for some time. My initial thoughts on how to do\nthis relatively efficiently are as follows:\n\n1) Start out with a feedforward only graph (e.g. the typical NEAT\ninitial population with conenctions from inputs to outputs).\n2) We initialise each node with a list of all the nodes that are above\nit in the graph, let&#39;s call this the &#39;ancestor&#39; list (A-list or A-node\nlist for short)\n3) With recursive networks, in order to add a connection we typically\nrandomly search pairs of source and target node IDs until we find a\npair that does not exist in the existign connection genes. Now we can\nadd the additional test that the target node ID is not in the source\nnode&#39;s A-list. This eliminates the need to traverse the network,\neffectively recalculating each node&#39;s A-List each time.\n4) When we create a new node by splitting a conenction, the new node\ncreates it&#39;s own A-list by takign a copy the source node&#39;s A-List plus\nthe source node&#39;s ID.\n\nThe A-lists can become part of the genome so that we never have to\ntraverse networks to rebuild A-lists, they just get copied when we\ncreate offspring genomes/networks. Ok so now you&#39;re all thinking that\nthe memory requirements for this could get unwieldy. We can reduce\nmemory requirements by using bitmaps where each node ID get&#39;s it&#39;s own\nlocation in an array of bits, thus if the IDs are 32bit integers we\nget a 32x reduction in storage space requirements. As a bonus, testing\nif a node is in a given A-list should be almost intantaneous, versus\nthe O(log n) time complexity of a binary search against a sorted list\nof integer IDs.\n\nThe first problem I see is that the set of innovation IDs currently in\nuse in a given population becomes patchy, e.g. some early IDs may\nsimply not exist any more (although I&#39;m not 100% if this happens in\nreality). So lets say NEAT has been running a while and the innovation\nID variable is up to 100,000. Each node requires its own bit in each\nA-list regardless of whether it is set or not, therefore the A-lists\nare 100000/8 = 12,500 bytes in size (I&#39;m assuming the A-lists grow\nover time, along with the innovation ID counter). We can however\nreduce this memory requirement by periodically stoppign NEAT and\ndefragmenting the ID space, this allows us to reuse the low IDs that\nare no longer in use anymore (no node anywhere in the population uses\nit) and thus the size of the A-list only needs to refelct the number\nof /active/ node IDs rather than the number of IDs there has ever\nbeen.\n\nThinking ahead to distributed-NEAT algorithms this potentially creates\na new problem when/if we need to pass genome between clusteres - the\nnode IDs of like nodes no longer match up. The proposed solution there\nis to have a periodic system wide defragmentation take place\nencompassing all nodes, or alternatively each distribution node\nmaintains a mapping between &#39;global&#39; innovation IDs and the local\ndefragmented IDs.\n\nI&#39;d be interested hear other&#39;s ideas on this topic. Perhaps there&#39;s\nsome more elegant approach using clever allocation of IDs to indicate\nwhere a node lies in the network of ancestors, e.g. if node IDs are\ntaken to be a height measured from top to bottom of the network, we\ncan assign and modify node IDs so that we can simply compare two IDs\nto see their relative position in the top-down graph - the problem\nthere being that we can no longer use the IDs as innovation numbers;\nHowever we could simply use two variables - innovation ID and a\nheight/position. One downside there is that only one node can occupy a\ngiven height and since the number of height levels is limits (e.g. to\n2^32 for a 32 bit variable) the number of nodes in a network is\nlimited, on the other hand that&#39;s potentially a very high limit.\nPerhaps the tricky part is decidign what to do when mating two\nnetworks.\n\nThis post is already too long so I&#39;m going to stop :)\n\nColin\n\n\n\n\n\r\n------=_NextPart_000_043F_01CA7CE7.AE5CB000\r\nContent-Type: text/html;\n\tcharset=&quot;US-ASCII&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;\n&lt;HTML&gt;&lt;HEAD&gt;=\r\n\n&lt;META content=3D&quot;text/html; charset=3Dus-ascii&quot; http-equiv=3DContent-Type&gt;=\r\n\n&lt;META name=3DGENERATOR content=3D&quot;MSHTML 8.00.6001.18854&quot;&gt;&lt;/HEAD&gt;\n&lt;BODY st=\r\nyle=3D&quot;BACKGROUND-COLOR: #fff&quot;&gt;\n&lt;DIV dir=3Dltr align=3Dleft&gt;&lt;SPAN class=3D9=\r\n33310001-15122009&gt;&lt;FONT color=3D#0000ff \nsize=3D2 face=3DArial&gt;Colin,&lt;/FONT=\r\n&gt;&lt;/SPAN&gt;&lt;/DIV&gt;\n&lt;DIV dir=3Dltr align=3Dleft&gt;&lt;SPAN class=3D933310001-15122009=\r\n&gt;&lt;FONT color=3D#0000ff \nsize=3D2 face=3DArial&gt;&lt;/FONT&gt;&lt;/SPAN&gt;&nbsp;&lt;/DIV&gt;\n&lt;D=\r\nIV dir=3Dltr align=3Dleft&gt;&lt;SPAN class=3D933310001-15122009&gt;&lt;FONT color=3D#0=\r\n000ff \nsize=3D2 face=3DArial&gt;Do you think a feed-forward network can have r=\r\necurrent \npaths?&nbsp; In other words, must it be &quot;strictly&quot; feed-forward? =\r\nOr can it \ngenerally exhibit forward directional traits?&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/DIV=\r\n&gt;\n&lt;DIV dir=3Dltr align=3Dleft&gt;&lt;SPAN class=3D933310001-15122009&gt;&lt;FONT color=\r\n=3D#0000ff \nsize=3D2 face=3DArial&gt;&lt;/FONT&gt;&lt;/SPAN&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV dir=3Dltr=\r\n align=3Dleft&gt;&lt;SPAN class=3D933310001-15122009&gt;&lt;FONT color=3D#0000ff \nsize=\r\n=3D2 face=3DArial&gt;Ken Lloyd&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/DIV&gt;&lt;BR&gt;\n&lt;BLOCKQUOTE \nstyle=3D&quot;B=\r\nORDER-LEFT: #0000ff 2px solid; PADDING-LEFT: 5px; MARGIN-LEFT: 5px; MARGIN-=\r\nRIGHT: 0px&quot;&gt;\n  &lt;DIV dir=3Dltr lang=3Den-us class=3DOutlookMessageHeader ali=\r\ngn=3Dleft&gt;\n  &lt;HR tabIndex=3D-1&gt;\n  &lt;FONT size=3D2 face=3DTahoma&gt;&lt;B&gt;From:&lt;/B&gt;=\r\n neat@yahoogroups.com \n  [mailto:neat@yahoogroups.com] &lt;B&gt;On Behalf Of &lt;/B&gt;=\r\nColin Green&lt;BR&gt;&lt;B&gt;Sent:&lt;/B&gt; \n  Monday, December 14, 2009 2:37 PM&lt;BR&gt;&lt;B&gt;To:&lt;=\r\n/B&gt; \n  neat@yahoogroups.com&lt;BR&gt;&lt;B&gt;Subject:&lt;/B&gt; [neat] Evolving feedforward =\r\n\n  networks&lt;BR&gt;&lt;/FONT&gt;&lt;BR&gt;&lt;/DIV&gt;\n  &lt;DIV&gt;&lt;/DIV&gt;&lt;SPAN style=3D&quot;DISPLAY: none&quot;=\r\n&gt;&nbsp;&lt;/SPAN&gt; \n  &lt;DIV id=3Dygrp-text&gt;\n  &lt;P&gt;Hi,&lt;BR&gt;&lt;BR&gt;Ken&#39;s response to Da=\r\nniel Tuohy&#39;s yesterday briefly touched \n  on&lt;BR&gt;evolution of feedforward-&lt;W=\r\nBR&gt;only networks and this is somethign I&#39;ve \n  been&lt;BR&gt;meaning to think abo=\r\nut for some time. My initial thoughts on how to \n  do&lt;BR&gt;this relatively ef=\r\nficiently are as follows:&lt;BR&gt;&lt;BR&gt;1) Start out with a \n  feedforward only gr=\r\naph (e.g. the typical NEAT&lt;BR&gt;initial population with \n  conenctions from i=\r\nnputs to outputs).&lt;BR&gt;2) We initialise each node with a list \n  of all the =\r\nnodes that are above&lt;BR&gt;it in the graph, let&#39;s call this the \n  &#39;ancestor&#39; =\r\nlist (A-list or A-node&lt;BR&gt;list for short)&lt;BR&gt;3) With recursive \n  networks,=\r\n in order to add a connection we typically&lt;BR&gt;randomly search pairs \n  of s=\r\nource and target node IDs until we find a&lt;BR&gt;pair that does not exist in \n =\r\n the existign connection genes. Now we can&lt;BR&gt;add the additional test that =\r\nthe \n  target node ID is not in the source&lt;BR&gt;node&#39;s A-list. This eliminate=\r\ns the need \n  to traverse the network,&lt;BR&gt;effectively recalculating each no=\r\nde&#39;s A-List each \n  time.&lt;BR&gt;4) When we create a new node by splitting a co=\r\nnenction, the new \n  node&lt;BR&gt;creates it&#39;s own A-list by takign a copy the s=\r\nource node&#39;s A-List \n  plus&lt;BR&gt;the source node&#39;s ID.&lt;BR&gt;&lt;BR&gt;The A-lists can=\r\n become part of the genome \n  so that we never have to&lt;BR&gt;traverse networks=\r\n to rebuild A-lists, they just \n  get copied when we&lt;BR&gt;create offspring ge=\r\nnomes/networks. Ok so now you&#39;re all \n  thinking that&lt;BR&gt;the memory require=\r\nments for this could get unwieldy. We can \n  reduce&lt;BR&gt;memory requirements =\r\nby using bitmaps where each node ID get&#39;s it&#39;s \n  own&lt;BR&gt;location in an arr=\r\nay of bits, thus if the IDs are 32bit integers \n  we&lt;BR&gt;get a 32x reduction=\r\n in storage space requirements. As a bonus, \n  testing&lt;BR&gt;if a node is in a=\r\n given A-list should be almost intantaneous, \n  versus&lt;BR&gt;the O(log n) time=\r\n complexity of a binary search against a sorted \n  list&lt;BR&gt;of integer IDs.&lt;=\r\nBR&gt;&lt;BR&gt;The first problem I see is that the set of \n  innovation IDs current=\r\nly in&lt;BR&gt;use in a given population becomes patchy, e.g. \n  some early IDs m=\r\nay&lt;BR&gt;simply not exist any more (although I&#39;m not 100% if this \n  happens i=\r\nn&lt;BR&gt;reality). So lets say NEAT has been running a while and the \n  innovat=\r\nion&lt;BR&gt;ID variable is up to 100,000. Each node requires its own bit in \n  e=\r\nach&lt;BR&gt;A-list regardless of whether it is set or not, therefore the \n  A-li=\r\nsts&lt;BR&gt;are 100000/8 =3D 12,500 bytes in size (I&#39;m assuming the A-lists \n  g=\r\nrow&lt;BR&gt;over time, along with the innovation ID counter). We can \n  however&lt;=\r\nBR&gt;reduce this memory requirement by periodically stoppign NEAT \n  and&lt;BR&gt;d=\r\nefragmenting the ID space, this allows us to reuse the low IDs \n  that&lt;BR&gt;a=\r\nre no longer in use anymore (no node anywhere in the population \n  uses&lt;BR&gt;=\r\nit) and thus the size of the A-list only needs to refelct the \n  number&lt;BR&gt;=\r\nof /active/ node IDs rather than the number of IDs there has \n  ever&lt;BR&gt;bee=\r\nn.&lt;BR&gt;&lt;BR&gt;Thinking ahead to distributed-&lt;WBR&gt;NEAT algorithms this \n  potent=\r\nially creates&lt;BR&gt;a new problem when/if we need to pass genome between \n  cl=\r\nusteres - the&lt;BR&gt;node IDs of like nodes no longer match up. The proposed \n =\r\n solution there&lt;BR&gt;is to have a periodic system wide defragmentation take \n=\r\n  place&lt;BR&gt;encompassing all nodes, or alternatively each distribution \n  no=\r\nde&lt;BR&gt;maintains a mapping between &#39;global&#39; innovation IDs and the \n  local&lt;=\r\nBR&gt;defragmented IDs.&lt;BR&gt;&lt;BR&gt;I&#39;d be interested hear other&#39;s ideas on this \n =\r\n topic. Perhaps there&#39;s&lt;BR&gt;some more elegant approach using clever allocati=\r\non \n  of IDs to indicate&lt;BR&gt;where a node lies in the network of ancestors, =\r\ne.g. if \n  node IDs are&lt;BR&gt;taken to be a height measured from top to bottom=\r\n of the \n  network, we&lt;BR&gt;can assign and modify node IDs so that we can sim=\r\nply compare \n  two IDs&lt;BR&gt;to see their relative position in the top-down gr=\r\naph - the \n  problem&lt;BR&gt;there being that we can no longer use the IDs as in=\r\nnovation \n  numbers;&lt;BR&gt;However we could simply use two variables - innovat=\r\nion ID and \n  a&lt;BR&gt;height/position. One downside there is that only one nod=\r\ne can occupy \n  a&lt;BR&gt;given height and since the number of height levels is =\r\nlimits (e.g. \n  to&lt;BR&gt;2^32 for a 32 bit variable) the number of nodes in a =\r\nnetwork \n  is&lt;BR&gt;limited, on the other hand that&#39;s potentially a very high =\r\n\n  limit.&lt;BR&gt;Perhaps the tricky part is decidign what to do when mating \n  =\r\ntwo&lt;BR&gt;networks.&lt;BR&gt;&lt;BR&gt;This post is already too long so I&#39;m going to stop =\r\n\n  :)&lt;BR&gt;&lt;BR&gt;Colin&lt;BR&gt;&lt;/P&gt;&lt;/DIV&gt;&lt;!-- end group email --&gt;&lt;/BODY&gt;&lt;/HTML&gt;\n\r\n------=_NextPart_000_043F_01CA7CE7.AE5CB000--\r\n\n"}}