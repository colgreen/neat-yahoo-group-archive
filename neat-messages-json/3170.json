{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":292213213,"authorName":"shanemcdonaldryan","from":"&quot;shanemcdonaldryan&quot; &lt;shanemcdonaldryan@...&gt;","profile":"shanemcdonaldryan","replyTo":"LIST","senderId":"lPRcvyFpGFD4LQDOOQewV4JFY0eAJn3i1kvas34vTjUqIRpQdY-6a9i-yDqn1drIsfx6Y2kpJTH5D3B3R8kuCCTBKQafd-kizaqsYdTa1k9jRpw4Pvk1AA","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: Computation Time","postDate":"1176912140","msgId":3170,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGYwNWZlYys2dmRtQGVHcm91cHMuY29tPg==","inReplyToHeader":"PDAxMTlFMzk1LTlDNjctNEY5MC05MDlBLTU5NDBCNDQzMzA3MEB3YWl0cy5uZXQ+"},"prevInTopic":3167,"nextInTopic":3171,"prevInTime":3169,"nextInTime":3171,"topicId":845,"numMessagesInTopic":99,"msgSnippet":"Fair enough. I compared the two versions on my system and the difference in speed for 10 million iterations was negligible. So I ll leave it like it was","rawEmail":"Return-Path: &lt;shanemcdonaldryan@...&gt;\r\nX-Sender: shanemcdonaldryan@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 24363 invoked from network); 18 Apr 2007 16:07:04 -0000\r\nReceived: from unknown (66.218.66.68)\n  by m47.grp.scd.yahoo.com with QMQP; 18 Apr 2007 16:07:04 -0000\r\nReceived: from unknown (HELO n25c.bullet.scd.yahoo.com) (66.218.67.216)\n  by mta11.grp.scd.yahoo.com with SMTP; 18 Apr 2007 16:07:04 -0000\r\nReceived: from [66.218.69.3] by n25.bullet.scd.yahoo.com with NNFMP; 18 Apr 2007 16:02:21 -0000\r\nReceived: from [66.218.66.75] by t3.bullet.scd.yahoo.com with NNFMP; 18 Apr 2007 16:02:21 -0000\r\nDate: Wed, 18 Apr 2007 16:02:20 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;f05fec+6vdm@...&gt;\r\nIn-Reply-To: &lt;0119E395-9C67-4F90-909A-5940B4433070@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0\r\nFrom: &quot;shanemcdonaldryan&quot; &lt;shanemcdonaldryan@...&gt;\r\nSubject: Re: Computation Time\r\nX-Yahoo-Group-Post: member; u=292213213; y=jxYFvVfhptXNmxU6OioNYOt4V2Lo_gRlSk4a6p1-MhLOiZ-ji40rYicodbw\r\nX-Yahoo-Profile: shanemcdonaldryan\r\n\r\nFair enough. I compared the two versions on my system and the\ndifference in=\r\n speed for 10 million iterations was negligible. So I&#39;ll\nleave it like it w=\r\nas before.\n\nOne thing I did do was get rid of that discontinuity that I men=\r\ntioned.\nI modified the Matlab least squares code so that it only solved for=\r\n\nthe last n-1 terms. Leaving the first constant term fixed (constant).\nThou=\r\ngh to get a good solution I had to increase the order of the\npolynomial to =\r\n6 from 5. This has significantly improved the learning\nin the tests I did. =\r\nBefore there was a small difference in the\nlearning rate (rate of convergen=\r\nce on a solution) between the regular\nand the least-squares sigmoid. Now th=\r\nis is almost negligible.  I think\nthis is a pretty viable replacement now f=\r\nor the standard sigmoid.\n\nAdditionally the approximated sigmoid itself stil=\r\nl runs about 6 times\nfaster than the standard sigmoid. Which in the tests I=\r\n have been doing\nhas resulted in about a 70% gain in speed for my implement=\r\nation for\nrunning through a given number of generations. While the rate of\n=\r\nconvergence has only seen the slightest decrease (and occasionally an\neven =\r\nslighter increase). So factoring in the ever so slightly slowed\nrate of con=\r\nvergence. I think this approximated sigmoid will give at\nleast a 50% real g=\r\nain in performance for the problems I am working on.\n\nThe improved code is =\r\nbelow. Hope this helps someone or inspires \n\nThanks,\n\nShane\n\n//START CODE\nc=\r\nonst float SigmoidLeastSquares(const float aNetinput, const float\naResponse=\r\n)\n\n{\n\tconst float c0 =3D\t0.5000f;\n\n\tconst float c1 =3D\t0.2780f;\n\n\tconst flo=\r\nat c2 =3D\t-0.0474f;\n\n\tconst float c3 =3D\t-2.4015e-004f;\n\n\tconst float c4 =\r\n=3D\t8.9276e-004f;\n\n\tconst float c5 =3D\t-9.0291e-005f;\n\n\tconst float c6 =3D\t=\r\n2.8028e-006f;\n\n\n\n\tconst float tUpperAndLowerLimit =3D 7.92871952056884f;\n\n\n=\r\n\tfloat x =3D aNetinput / aResponse;\n\n\tif( x &gt; tUpperAndLowerLimit)\n\t\treturn=\r\n 1.0f;\n\n\tif(x &lt; -tUpperAndLowerLimit)\n\t\treturn 0.0f;\n\n\tbool tLessThanZero =\r\n=3D false;\n\n\tif(x &lt; 0.0f)\n\t{\n\t\tx *=3D -1.0f;\n\t\ttLessThanZero =3D true;\n\t}\n\t=\r\n\n\tfloat xmul =3D x;\n\tfloat tOutput1 =3D c0;\n\ttOutput1 +=3D c1*xmul;\n\txmul *=\r\n=3D x;\n\ttOutput1 +=3D c2*xmul;\n\txmul *=3D x;\n\ttOutput1 +=3D c3*xmul;\n\txmul =\r\n*=3D x;\n\ttOutput1 +=3D c4*xmul;\n\txmul *=3D x;\n\ttOutput1 +=3D c5*xmul;\n\txmul=\r\n *=3D x;\n\ttOutput1 +=3D c6*xmul;\n\n\tif(!tLessThanZero)\n\t\treturn tOutput1;\n\te=\r\nlse\n\t\treturn 1.0f - tOutput1;\n}\n\n//END CODE\n\n\n--- In neat@yahoogroups.com, =\r\nStephen Waits &lt;steve@...&gt; wrote:\n&gt;\n&gt; \n&gt; On Apr 17, 2007, at 3:02 AM, shanem=\r\ncdonaldryan wrote:\n&gt; \n&gt; &gt; Plus I can&#39;t see why multiplying using a ternary\n=\r\n&gt; &gt; operator will be faster than multiplying using *=3D -1\n&gt; \n&gt; In the hard=\r\nware, flipping a sign is always going to be faster than a  \n&gt; multiply; how=\r\never, you only do it once.. so any gains from this are  \n&gt; close to negligi=\r\nble.\n&gt; \n&gt; I wouldn&#39;t be surprised if your compiler can transform x *=3D -1 =\r\nto x =3D  \n&gt; -x.  To verify this, you should look at the assembler.\n&gt; \n&gt; In=\r\n fact I just verified that my compiler (686-apple-darwin8- \n&gt; gcc-4.0.1), e=\r\nven without the optimizer enabled, will do this without  \n&gt; using a multipl=\r\nication.\n&gt; \n&gt; --Steve\n&gt;\n\n\n\n"}}