{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":436954031,"authorName":"arman.schwarz","from":"&quot;arman.schwarz&quot; &lt;arman.schwarz@...&gt;","profile":"arman.schwarz","replyTo":"LIST","senderId":"omeHPiEoRnBJaXEu_EaVa6aEqQvWoFjnQ8cTfa105UPTFwQksrwU9vj7YQfFrG-zJC9GyW2DGlZ3mjjERIzEqMg1Em2IrmloodagMQuOvGs","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: technical question about custom number of sensors and output nodes","postDate":"1315285468","msgId":5636,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGo0NDlrcytsbDM1QGVHcm91cHMuY29tPg==","inReplyToHeader":"PGozZzZpaCs2Z284QGVHcm91cHMuY29tPg=="},"prevInTopic":5635,"nextInTopic":5637,"prevInTime":5635,"nextInTime":5637,"topicId":5623,"numMessagesInTopic":7,"msgSnippet":"I also noticed that the NETWORK::load_sensors function accepts a double pointer, so NEAT conceivably has no knowledge of the number of inputs that are","rawEmail":"Return-Path: &lt;arman.schwarz@...&gt;\r\nX-Sender: arman.schwarz@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 38100 invoked from network); 6 Sep 2011 05:04:28 -0000\r\nX-Received: from unknown (98.137.35.161)\n  by m11.grp.sp2.yahoo.com with QMQP; 6 Sep 2011 05:04:28 -0000\r\nX-Received: from unknown (HELO n43d.bullet.mail.sp1.yahoo.com) (66.163.169.157)\n  by mta5.grp.sp2.yahoo.com with SMTP; 6 Sep 2011 05:04:28 -0000\r\nX-Received: from [69.147.65.147] by n43.bullet.mail.sp1.yahoo.com with NNFMP; 06 Sep 2011 05:04:28 -0000\r\nX-Received: from [98.137.34.73] by t10.bullet.mail.sp1.yahoo.com with NNFMP; 06 Sep 2011 05:04:28 -0000\r\nDate: Tue, 06 Sep 2011 05:04:28 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;j449ks+ll35@...&gt;\r\nIn-Reply-To: &lt;j3g6ih+6go8@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;arman.schwarz&quot; &lt;arman.schwarz@...&gt;\r\nSubject: Re: technical question about custom number of sensors and output nodes\r\nX-Yahoo-Group-Post: member; u=436954031; y=pY-Sr3GODN_gXC0tS3juATN-AskD7alF5u3ddAvfH5sJcqGiIajG0w\r\nX-Yahoo-Profile: arman.schwarz\r\n\r\nI also noticed that the NETWORK::load_sensors function accepts a double poi=\r\nnter, so NEAT conceivably has no knowledge of the number of inputs that are=\r\n available (unless a vector is passed to the function).\n\nSo am I correct in=\r\n understanding that the rtNEAT package will not try adding inputs beyond th=\r\nose specified in the input file? This would be unfortunate as I might have =\r\nseveral hundred inputs and always using all of them in the genome start fil=\r\ne would generate considerable computational (as well as human workload) ove=\r\nrhead.\n\nHowever, contrary to this you have previously mentioned in another =\r\npost that FSNEAT is supposed by rtNEAT, which does give me some hope. I&#39;m s=\r\norry I&#39;ve been somewhat unclear with my questions (I&#39;m still in the process=\r\n of getting my head around NEAT itself), but if the addition of sensors is =\r\nsupported, where does this take place in rtNEAT? \n\nArman\n\n--- In neat@yahoo=\r\ngroups.com, &quot;arman.schwarz&quot; &lt;arman.schwarz@...&gt; wrote:\n&gt;\n&gt; Thanks Ken,\n&gt; \n&gt;=\r\n I tried to create a simple starting genome that simply connects the input =\r\nto the output;\n&gt; \n&gt; genomestart 1\n&gt; trait 1 1.0 0 0 0 0 0 0 0\n&gt; node 1 1 1 =\r\n1\n&gt; node 1 0 1 2\n&gt; gene 1 1 1 1.0 0 1 0 1\n&gt; genomeend 1\n&gt; \n&gt; when I allow t=\r\nhis to run it does a surprisingly good job at finding a solution, but it do=\r\nesn&#39;t use the other inputs. That is to say, I end up with very complex netw=\r\norks that do a reasonable job of predicting the timeseries (but not as well=\r\n as they could if they used all the inputs), but none of the nodes, other t=\r\nhan the first, are ever input nodes.\n&gt; \n&gt; Supposing that I have 25 inputs, =\r\nI am creating the following start genes file:\n&gt; \n&gt; genomestart 1\n&gt; trait 1 =\r\n1 0 0 0 0 0 0 0\n&gt; node 1 0 1 1\n&gt; node 2 0 1 1\n&gt; node 3 0 1 1\n&gt; node 4 0 1 1=\r\n\n&gt; node 5 0 1 1\n&gt; node 6 0 1 1\n&gt; node 7 0 1 1\n&gt; node 8 0 1 1\n&gt; node 9 0 1 1=\r\n\n&gt; node 10 0 1 1\n&gt; node 11 0 1 1\n&gt; node 12 0 1 1\n&gt; node 13 0 1 1\n&gt; node 14 =\r\n0 1 1\n&gt; node 15 0 1 1\n&gt; node 16 0 1 1\n&gt; node 17 0 1 1\n&gt; node 18 0 1 1\n&gt; nod=\r\ne 19 0 1 1\n&gt; node 20 0 1 1\n&gt; node 21 0 1 1\n&gt; node 22 0 1 1\n&gt; node 23 0 1 1\n=\r\n&gt; node 24 0 1 1\n&gt; node 25 0 1 1\n&gt; node 26 0 0 2\n&gt; node 27 0 0 3\n&gt; node 28 0=\r\n 0 0\n&gt; gene 1 1 26 1 0 1 0 1\n&gt; genomeend 1\n&gt; \n&gt; Will this ensure that NEAT =\r\nmakes use of any available inputs (assuming there are only 25)?\n&gt; \n&gt; Arman\n=\r\n&gt; \n&gt; --- In neat@yahoogroups.com, &quot;Ken&quot; &lt;kstanley@&gt; wrote:\n&gt; &gt;\n&gt; &gt; \n&gt; &gt; \n&gt; =\r\n&gt; Hi Arman, nodes.size() is not constant because nodes is a variable-length=\r\n list, so it can grow or shrink.  Asking for its size just gives the curren=\r\nt number of nodes in the list.  The &quot;inlist&quot; and &quot;outlist&quot; (lists of inputs=\r\n and outputs internally generated by NEAT) work the same way, so they too c=\r\nan change.  Therefore, in principle, I believe that your idea should be fea=\r\nsible.  However, you need to make sure that if you ever add new inputs that=\r\n those new nodes have the right flags marking them as input nodes and senso=\r\nrs.\n&gt; &gt; \n&gt; &gt; There used to be a tutorial that comes with NEAT that explaine=\r\nd the file format, but it gone out of date as NEAT was updated, so I believ=\r\ne unfortunately it&#39;s no longer included.  Let me try to explain a little:\n&gt;=\r\n &gt; \n&gt; &gt; Traits are reserved for special genetic information that nodes or c=\r\nonnections can point to.  They are not used in most NEAT experiments.  I be=\r\nlieve you just need one dummy trait in a genome file trait but it won&#39;t be =\r\nused.\n&gt; &gt; \n&gt; &gt; node 1 0 1 1\n&gt; &gt; \n&gt; &gt; The first number is the node ID #, the=\r\n second is the trait pointer (which can be left at zero), the third says wh=\r\nether the node is NEURON/SENSOR (0,1), and the fourth is HIDDEN/INPUT/OUTPU=\r\nT/BIAS (0,1,2,3).  It&#39;s true that the third and fourth numbers are a little=\r\n confusing because they seem to be about a similar issue, but that is how t=\r\nhey are defined.\n&gt; &gt; \n&gt; &gt; gene 1 1 5 0.0 0 1 0 1\n&gt; &gt; \n&gt; &gt; The parameters ar=\r\ne: trait # (not usually used), in_node id, out_node id, weight, is_recurren=\r\nt flag, innovation_num, mutation_num, and enable flag.\n&gt; &gt; \n&gt; &gt; Note that m=\r\nutation_num is generally set the same as the weight and does not have a rea=\r\nl specific use in NEAT.\n&gt; &gt; \n&gt; &gt; As you may notice some parameters seem unn=\r\necessary or redundant, but I initially created this format before I was sur=\r\ne about everything that would be needed and the legacy parameters stuck aro=\r\nund, which unfortunately can be confusing.\n&gt; &gt; \n&gt; &gt; ken\n&gt; &gt; \n&gt; &gt; --- In nea=\r\nt@yahoogroups.com, &quot;arman.schwarz&quot; &lt;arman.schwarz@&gt; wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; \n&gt; &gt;=\r\n &gt; \n&gt; &gt; &gt; Thanks Ken,\n&gt; &gt; &gt; \n&gt; &gt; &gt; I think I understand what you mean. So w=\r\nhen a new genome is created, NEAT will search through the &quot;nodes&quot; vector to=\r\n look for candidates. The nodes vector in turn is generated initially by wh=\r\nat it finds in the call to this function during the initial creation of the=\r\n population:\n&gt; &gt; &gt; \n&gt; &gt; &gt; Genome::Genome(int id, std::ifstream &iFile)\n&gt; &gt; =\r\n&gt; \n&gt; &gt; &gt; Does this mean that nodes.size() is constant and initially constra=\r\nined to what is given in the genome start file, or does can it adapt depend=\r\ning on the size of the array passed to the &quot;load_sensors&quot; function?\n&gt; &gt; &gt; \n=\r\n&gt; &gt; &gt; The reason I ask is because I have about 200 inputs, and I would like=\r\n to create a start file which simply takes the first input as output, and t=\r\nries to improve based on that, preferably allowing me to use any number of =\r\ninputs with a single genome start file. Can I do that without destroying NE=\r\nAT&#39;s ability to recognise the existence of all the sensors?\n&gt; &gt; &gt; \n&gt; &gt; &gt; I&#39;=\r\nm also somewhat confused about the format of those start files, is there an=\r\ny documentation for these files that I can learn from, or will I just need =\r\nto look through the source code? I understand NEAT&#39;s concept of bias nodes,=\r\n but not so much the idea of &quot;traits&quot;, so it would be nice to know if any d=\r\nocumentation does exist.\n&gt; &gt; &gt; \n&gt; &gt; &gt; Thanks again for your help.\n&gt; &gt; &gt; Arm=\r\nan\n&gt; &gt; &gt; \n&gt; &gt; &gt; --- In neat@yahoogroups.com, &quot;Ken&quot; &lt;kstanley@&gt; wrote:\n&gt; &gt; &gt;=\r\n &gt;\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; Hi Arman, from what you wrote I think you unde=\r\nrstand how to pass in and read out the input and output arrays.  I think th=\r\ne main question you are asking is how it knows how long those arrays are.\n&gt;=\r\n &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; The answer is that rtNEAT (or plain NEAT) C++ counts the nu=\r\nmber of inputs and number of outputs when it creates a neural network from =\r\na genome, which happens in the method \n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; Network *Genome::ge=\r\nnesis(int id)\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; When it creates the network, it creates sepa=\r\nrate lists of inputs, hidden nodes, and outputs, as you can see here:\n&gt; &gt; &gt;=\r\n &gt; \n&gt; &gt; &gt; &gt;                 //Check for input or output designation of node=\r\n\n&gt; &gt; &gt; &gt;                 if (((*curnode)-&gt;gen_node_label)=3D=3DINPUT)\n&gt; &gt; &gt;=\r\n &gt;                         inlist.push_back(newnode);\n&gt; &gt; &gt; &gt;              =\r\n   if (((*curnode)-&gt;gen_node_label)=3D=3DBIAS)\n&gt; &gt; &gt; &gt;                     =\r\n    inlist.push_back(newnode);\n&gt; &gt; &gt; &gt;                 if (((*curnode)-&gt;gen=\r\n_node_label)=3D=3DOUTPUT)\n&gt; &gt; &gt; &gt;                         outlist.push_back=\r\n(newnode);\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; Then it knows how many inputs there are and how=\r\n many outputs there are because it knows how long those lists are.\n&gt; &gt; &gt; &gt; =\r\n\n&gt; &gt; &gt; &gt; Going back further in the chain, usually the first place this issu=\r\ne will ultimately be specified is in the starter genome file, which is usua=\r\nlly the origin of the genome data structures (which are created from this f=\r\nile).  Here is a pole balancing starter genome:\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; genomestar=\r\nt 1\n&gt; &gt; &gt; &gt; trait 1 0.1 0 0 0 0 0 0 0\n&gt; &gt; &gt; &gt; node 1 0 1 1\n&gt; &gt; &gt; &gt; node 2 0=\r\n 1 1\n&gt; &gt; &gt; &gt; node 3 0 1 1\n&gt; &gt; &gt; &gt; node 4 0 1 3\n&gt; &gt; &gt; &gt; node 5 0 0 2\n&gt; &gt; &gt; &gt;=\r\n gene 1 1 5 0.0 0 1 0 1\n&gt; &gt; &gt; &gt; gene 1 2 5 0.0 0 2 0 1\n&gt; &gt; &gt; &gt; gene 1 3 5 0=\r\n.0 0 3 0 1\n&gt; &gt; &gt; &gt; gene 1 4 5 0.0 0 4 0 1\n&gt; &gt; &gt; &gt; genomeend 1\n&gt; &gt; &gt; &gt; \n&gt; &gt; =\r\n&gt; &gt; Here the numerical codes next the nodes specify what type of nodes they=\r\n are.  In this case, there are 4 inputs (one is a bias) and 1 output.  Thes=\r\ne codes are defined in nnode.h:\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt;         enum nodetype {\n&gt; =\r\n&gt; &gt; &gt;                 NEURON =3D 0,\n&gt; &gt; &gt; &gt;                 SENSOR =3D 1\n&gt; =\r\n&gt; &gt; &gt;         };\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt;         enum nodeplace {\n&gt; &gt; &gt; &gt;         =\r\n        HIDDEN =3D 0,\n&gt; &gt; &gt; &gt;                 INPUT =3D 1,\n&gt; &gt; &gt; &gt;         =\r\n        OUTPUT =3D 2,\n&gt; &gt; &gt; &gt;                 BIAS =3D 3\n&gt; &gt; &gt; &gt;         };=\r\n\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; So usually that is from where NEAT ultimately ends up kno=\r\nwing these counts.  I hope that helps answer your question.\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; =\r\n&gt; ken\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; --- In neat@yahoogroups.com, &quot;arman.schwarz=\r\n&quot; &lt;arman.schwarz@&gt; wrote:\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; hi everyone, \n&gt; &gt; &gt; &gt; &gt; I am =\r\ncurrently trying to apply timeseries prediction to the rtNEAT c++ package, =\r\nto compare its search performance to a fixed-size, evolving topology recurr=\r\nent neural net I wrote.\n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; I have written a custom experi=\r\nments.h/cpp file to cycle through the activate() function for every time st=\r\nep, after loading an array of ~75 sensor inputs.\n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; So wh=\r\nile I understand how to load the inputs and retrieve the outputs, I don&#39;t q=\r\nuite understand how I am supposed to tell NEAT how many inputs and outputs =\r\nthere are. after all, that array I&#39;m passing to load_sensor is nothing more=\r\n than a pointer to a value.\n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; so where do I tell NEAT ho=\r\nw many inputs I will give each net, and how many outputs I will be expectin=\r\ng? (in my RNN the outputs were simply the last x neurons, but the inputs do=\r\n need to be defined).\n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; thanks in advance for the help!\n=\r\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt;\n&gt;\n\n\n\n"}}