{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":170210925,"authorName":"Ashot Petrosian","from":"&quot;Ashot Petrosian&quot; &lt;ashot@...&gt;","profile":"Ashot_Petrosian","replyTo":"LIST","senderId":"fpWZkTG5GvPDZa0bfjNQzIQccEXfbNIjmjUnnnyej4D1T8acbY9yytvtqakRu2-rkmdjhUQp6c47La1knzXoCQMFkKWO5PGtwdjm1N2BNxY","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Introduction/Some Questions","postDate":"1121682856","msgId":2107,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PG9wc3QzdWJlaDd4NHAzM21AbWFpbC51dGV4YXMuZWR1Pg==","inReplyToHeader":"PDA3QzE1NDczLTNGNjYtNDc3Qi1BRjc1LUU2RjlDRjM3N0NBNEBjcy51dGV4YXMuZWR1Pg==","referencesHeader":"PGRiN240ZStqOXNmQGVHcm91cHMuY29tPiA8UGluZS5MTlguNC42My4wNTA3MTUwOTMyMDYwLjQzMDNAb3JhbmdlLXBla29lLmNzLnV0ZXhhcy5lZHU+IDxvcHN0ejZ1c3MzeDRwMzNtQG1haWwudXRleGFzLmVkdT4gPDA3QzE1NDczLTNGNjYtNDc3Qi1BRjc1LUU2RjlDRjM3N0NBNEBjcy51dGV4YXMuZWR1Pg=="},"prevInTopic":2105,"nextInTopic":2110,"prevInTime":2106,"nextInTime":2108,"topicId":2088,"numMessagesInTopic":13,"msgSnippet":"... So does this mean someone is working on a NEAT with indirect encoding? Although thinking about this some more, I don t think a developmental encoding will","rawEmail":"Return-Path: &lt;ashot@...&gt;\r\nX-Sender: ashot@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 43212 invoked from network); 18 Jul 2005 10:34:23 -0000\r\nReceived: from unknown (66.218.66.167)\n  by m23.grp.scd.yahoo.com with QMQP; 18 Jul 2005 10:34:23 -0000\r\nReceived: from unknown (HELO wb1-a.mail.utexas.edu) (128.83.126.134)\n  by mta6.grp.scd.yahoo.com with SMTP; 18 Jul 2005 10:34:23 -0000\r\nReceived: (qmail 10606 invoked from network); 18 Jul 2005 10:34:16 -0000\r\nReceived: from pcp07743086pcs.nrockv01.md.comcast.net (HELO mail.utexas.edu) (ashot@69.138.172.137)\n  by wb1.mail.utexas.edu with RC4-SHA encrypted SMTP; 18 Jul 2005 10:34:16 -0000\r\nDate: Mon, 18 Jul 2005 05:34:16 -0500\r\nTo: neat@yahoogroups.com\r\nReferences: &lt;db7n4e+j9sf@...&gt; &lt;Pine.LNX.4.63.0507150932060.4303@...&gt; &lt;opstz6uss3x4p33m@...&gt; &lt;07C15473-3F66-477B-AF75-E6F9CF377CA4@...&gt;\r\nContent-Type: text/plain; format=flowed; delsp=yes; charset=iso-8859-15\r\nMIME-Version: 1.0\r\nContent-Transfer-Encoding: 8bit\r\nMessage-ID: &lt;opst3ubeh7x4p33m@...&gt;\r\nIn-Reply-To: &lt;07C15473-3F66-477B-AF75-E6F9CF377CA4@...&gt;\r\nUser-Agent: Opera M2/7.50 (Win32, build 3778)\r\nX-eGroups-Msg-Info: 1:12:0\r\nX-eGroups-From: &quot;Ashot Petrosian&quot; &lt;ashot@...&gt;\r\nFrom: &quot;Ashot Petrosian&quot; &lt;ashot@...&gt;\r\nSubject: Re: [neat] Introduction/Some Questions\r\nX-Yahoo-Group-Post: member; u=170210925; y=6qCxKBQ4o-j7ztF7tq1ai9AO6z1h0alkF0VcDPEnqUDNZw6eY_2lKYJa\r\nX-Yahoo-Profile: Ashot_Petrosian\r\n\r\nOn Sun, 17 Jul 2005 23:22:30 -0500, Joseph Reisinger &lt;joeraii@...&gt; wrote:\n&gt;&gt;\n&gt;&gt; Yea, this was the first thing that hit me when I read about NEAT..\n&gt;&gt; Is there an anti-modular contingency? If there is, we&#39;ll show &#39;em ;)\n&gt;\n&gt; I wouldn&#39;t say everyone is anti-modular, they just seem focused more\n&gt; on issues with the standard NEAT implementation, which just by itself\n&gt; has quite a lot of issues :) Though to be fair both Ken and I have\n&gt; come to the conclusion that the ad-hoc kind of modularity present in\n&gt; e.g. mNEAT is kind of the wrong way to approach the problem. Thats\n&gt; not to say doing work in the area is not extremely valuable (and may\n&gt; yield some excellent results), its just that there might be other,\n&gt; better ways of doing modularity besides explicit modularization. Ken\n&gt; and I wrote a position statement that appeared in a GECCO workshop on\n&gt; modularity last year that focuses on this topic. If you haven&#39;t\n&gt; already, I&#39;d say it might be worth reading. Its available here:\n&gt;\n&gt; http://nn.cs.utexas.edu/keyword?stanley:gecco04ws\n\nSo does this mean someone is working on a NEAT with indirect encoding?\n\nAlthough thinking about this some more, I don&#39;t think a developmental encoding will accomplish what you are talking about here right?  Stuff like this in nature can happen because the whole &#39;ga&#39; is encoded in the genome.  I suppose you could do something like perform the mutations themselves with an NN or a GP (that is part of each individual), or at least evolve some routine that is parameterized to some extent.  I think also that you need a very very long fitness climb before this kind of stuff will become statistically significant.  Of course I&#39;m not sure if this is what you meant in that paper but I actually read about someone who was either prposing or had written an entire GP system that was self-contained, I can&#39;t seem to find it now though.\n\nWhen you say ad-hoc approaches do you mean relative to developmental systems, or something else?  It seems to me that if we engineer the system in this ad-hoc, but transparent fashion, at least at first, it will be easier to control the vital details.\n\n&gt;\n&gt;&gt; If the parent has a mechanism for adding this mutation itself, then\n&gt;&gt; it seems like this is exactly what you would not want to do.  In\n&gt;&gt; fact, I was going to go further than that.  Rather than use the\n&gt;&gt; average I wanted to multiply the fitnesses together specifically so\n&gt;&gt; this wouldn&#39;t happen.  I&#39;m not sure I understand why this doesn&#39;t\n&gt;&gt; make sense, isn&#39;t it exactly the selective pressure that we are\n&gt;&gt; looking for?  Maybe I need to read your paper again, its been a\n&gt;&gt; while =]\n&gt;&gt;\n&gt;&gt; As a side note actually, I&#39;ve found that this method (multiplying\n&gt;&gt; fitness together rather than averaging them) was helpful when\n&gt;&gt; evaluating a network on multiple random runs.  If I used the\n&gt;&gt; average networks would fall into the local minimum of solving the\n&gt;&gt; problem really well some of the time rather than trying to solve\n&gt;&gt; the problem all the time.  This worked really well, so I&#39;m sure its\n&gt;&gt; not a new idea I just don&#39;t know what its called.  To control the\n&gt;&gt; intensity of the effect I actually divide by n and 1 before\n&gt;&gt; multiplying.\n&gt;&gt;\n&gt;\n&gt; I&#39;ve been trying to wrap my head around the properties of a\n&gt; &quot;multiplicative average&quot; like that. It seems like it would be\n&gt; beneficial, but I&#39;m still not sure I see why. Basically you get the\n&gt; same effect as it you did something like exp(fitness) for each\n&gt; individual and then averaged right? But you still have the same\n\nI don&#39;t think so, as long as you use average to group the elements together the relationship _between_ them is still linear.\n\n\n&gt; fundamental problem where the fitness of module A is the same as\n&gt; module B:\n&gt;\n&gt; f(A): [0.1, 0.1, 0.1, 1000]\n&gt; f(B): [1, 1, 1, 1]\n&gt;\n&gt; But in this case wouldn&#39;t you want to reward module A more, since in\n&gt; one case it has a fitness 1000 times better than module B? In fact\n&gt; with this example multiplication yields:\n&gt;\n&gt; f(A) = 1\n&gt; f(B) = 1\n&gt;\n&gt; while standard averaging yields:\n&gt;\n&gt; f(A) ~= 250\n&gt; f(B) = 1\n&gt;\n&gt; So standard averaging would actually be more biased towards solutions\n&gt; that excel in only trial. Anyway I&#39;m sure I&#39;m probably missing\n&gt; something.\n\nRight, well thats what I was saying, my initial intuition is to actually do the opposite of what you are proposing =]  (even more &#39;average-fitness&#39; than average..)  It just turns out that this also works to reward networks that did well on all trials over ones that &#39;specialize&#39; on particular cases.\n\nI think this (selecting for modularity) _is_ necessary if there is going to be a method to do non-modular evolution as well and let evolution decide where to use it, you&#39;ll have to throw away innovations which are useful only for one individual, otherwise there is no way to differentiate.  Perhaps this could be adapted to something more like requiring the module to do well in at least 2 (or n) significantally distinct situations, which then of course leaves the task of identifying distinct situations.\n\n\n\n\n&gt; Its deadly if the selective pressures aren&#39;t well aligned (which is\n&gt; very often the case), i.e. if one module is receiving reward for\n&gt; something else entirely, and therefore doesn&#39;t have to &quot;play nice&quot;\n&gt; with the other module in order to evolve. You can imagine a case\n&gt; where the downstream module keeps having its inputs changed whenever\n&gt; the upstream module changes, therefore during evolution, downstream\n&gt; modules that perform well in one fitness trial may perform poorly in\n&gt; the next. In general its very difficult to perform evolution on a\n&gt; population like this that has little control over its own fitness\n&gt; from generation to generation, as it basically destroys information\n&gt; about evolvability.\n\nOk, yea I see what you are saying now, this is analogous to the bloat problem?\n\n&gt;&gt;\n&gt;&gt; You are right though in that this is more rigid, however I think\n&gt;&gt; I&#39;ve settled on this for now for several reasons.  One of the most\n&gt;&gt; important being that I can make sure that this type of modularity\n&gt;&gt; exists easily by using a problem which requires distinct\n&gt;&gt; behaviours.  Perhaps actually we (or I?) should expand the\n&gt;&gt; vocabularity a bit as I can think of three distinct types of\n&gt;&gt; modularity which probably shouldn&#39;t be lumped up.  One type is the\n&gt;&gt; sequential: do this, then using the result do something else.\n&gt;&gt; Second type is to do two things both at the same time, but in\n&gt;&gt; parallel, and the third is to do one thing sometimes, and do\n&gt;&gt; something else another time.  So ideally I think there should be a\n&gt;&gt; system which is easily capable of doing all of these recursively\n&gt;&gt; and arbitrarily intermixed.  So this becomes sort of a GP on top of\n&gt;&gt; NEAT modules as building blocks sort of thing (a smooth GP.. at\n&gt;&gt; least in my head).\n&gt;\n&gt; These correspond to the engineering view of modularity as a black-box\n&gt; processing unit (inputs/outputs well defined). Another way of\n&gt; thinking about modularity is based on the degree of component\n&gt; linkage. In biology, regulatory interactions form a (roughly) scale-\n&gt; free networks structure (i.e. a network where most nodes have few\n&gt; inputs/outputs, but some a few &quot;hub&quot; nodes have many). Combining this\n&gt; with the ability of RNA to bind with a varying degree of\n&gt; effectiveness to different binding sites you get a notion of weak-\n&gt; vs. strong-linkage. Components that are weakly connected don&#39;t affect\n&gt; each other very much (i.e. are compartmentalized as &quot;modules&quot;),\n&gt; whereas strongly connected components are very interdependent and\n&gt; cannot be changed easily without requiring that the linked components\n&gt; change as well. By allowing the degrees of &quot;linkedness&quot; to change,\n&gt; you get a really nice smooth, non-ad-hoc way of implementing\n&gt; hierarchy and reusable modularity.\n\nsounds like OOP =]\n\nThats a valuable frame as well, but I don&#39;t think that the two definitions are contradictory, one is just fuzzy.  You will still have the types of modularity that I mentioned even under this system.\n\n&gt;&gt;\n&gt;&gt; Anyway, so the most perplexing thing for me right now (you touched\n&gt;&gt; on this above) seems to be how to combine the evolution of the\n&gt;&gt; different levels, especially since the selection pressures will be\n&gt;&gt; changing.  In my mind the best solution that I&#39;ve come to is to\n&gt;&gt; just wipe the slate clean everytime.  This is how this would work\n&gt;&gt; for the switch network idea (although this could be applied\n&gt;&gt; elsewhere too):\n&gt;&gt;\n&gt;&gt; 1. Regular NEAT tries to solve the problem.\n&gt;&gt; 2. A switching network evolves using the resulting species as sub-\n&gt;&gt; behaviours\n&gt;&gt; 3. The old NEAT population is wiped clean and now n NEAT\n&gt;&gt; populations co-evolve as the sub-behaviours using the winning\n&gt;&gt; switch network.\n&gt;&gt; 4. The switch evolves from scratch using the new NEAT populations\n&gt;&gt; as the sub-behaviours.\n&gt;&gt; etc..\n&gt;&gt;\n&gt;&gt; Obviously this is computationally pretty expensive, but it seems\n&gt;&gt; like this sort of &#39;forgetting&#39; is necessary here since the task\n&gt;&gt; (for all the pieces) changes.  I see no other way of solving the\n&gt;&gt; chicken and egg problem.  I have some more ideas on this, but I&#39;m\n&gt;&gt; not sure if this is the question you were addressing?\n&gt;&gt;\n&gt;&gt;\n&gt;\n&gt; This sounds like an interesting direction. It sidesteps some of the\n&gt; issues involved in co-evolving everything at the same time (changing\n&gt; selection pressures, dependent fitness evaluations, sheer cost of\n&gt; evaluating everything). However, I&#39;m wondering how you will re-\n&gt; initialize the sub-behavior populations after the switching network\n&gt; has evolved? Completely reset them? Randomize weights of the best\n&gt; topology? It would be interesting to see what kind of balance turns\n&gt; out between the switching network and the sub-components. In mNEAT we\n&gt; found that most of the information was being stored in the bindings,\n&gt; not the modules themselves. A nice result would be that the switching\n&gt; networks and the component behaviors are useful even when isolated\n&gt; from each other (i.e. the algorithm found generally good strategies).\n&gt; But I suspect that in general you&#39;ll find that the two populations\n&gt; are highly dependent.\n\nI think that I would start from scratch completely as I don&#39;t see why using the (incorrectly) biased networks/decision tree from the last round would be a benefit (except computationally).  So in this case if the two populations must be highly dependant, then it just won&#39;t work any better than regular NEAT.  Actually, I guess thats not true is it, looking at it as a dynamical system I see how it could possibly veer off into some direction, but this dependency would have to be transfered from the behaviours to the tree and then back again.\n\n&gt;&gt;\n&gt;&gt;&gt; Anyway, this looks like a great start, and I hope you will be\n&gt;&gt;&gt; continuing\n&gt;&gt;&gt; this work in the Fall as well.\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;\n&gt;&gt; Thanks for the insightful questions, I&#39;ve actually really been\n&gt;&gt; missing someone to bounce ideas off of.  Actually, I&#39;m not used to\n&gt;&gt; talking about this stuff, the vocab seems a bit awkward, so I&#39;m not\n&gt;&gt; sure I&#39;m doing my thoughts justice.. ultimately I&#39;ll just have to\n&gt;&gt; code them I think =P\n&gt;\n&gt; A lot of the vocab is still really up in the air (especially\n&gt; regarding modularity). I tend to defer to biology if possible, but\n&gt; the way biologists talk about modularity and the way engineers do is\n&gt; a bit different.\n&gt; -- Joe\n&gt;\n\nWhat about mathematicians? ;)\n\n&gt;\n&gt; Yahoo! Groups Links\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n\n\n"}}