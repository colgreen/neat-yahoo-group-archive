{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":292213213,"authorName":"shanemcdonaldryan","from":"&quot;shanemcdonaldryan&quot; &lt;shanemcdonaldryan@...&gt;","profile":"shanemcdonaldryan","replyTo":"LIST","senderId":"KexX-KPqJKrScASrpFnQsKKiBeDBxEUIAZcIRv5uA7p2r3yKTLubni52rOiRsoYWQTYWoghISuzPA_gLUu_-CVAixH5Rvqp14wCCSOH-1G1rzZ3r_z8-CQ","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: Computation Time","postDate":"1176804163","msgId":3166,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGYwMjYwMytxY21tQGVHcm91cHMuY29tPg==","inReplyToHeader":"PDQ2MjNEN0E4LjkwMDAzMDlAd2FpdHMubmV0Pg=="},"prevInTopic":3165,"nextInTopic":3167,"prevInTime":3165,"nextInTime":3167,"topicId":845,"numMessagesInTopic":99,"msgSnippet":"I am using a least squares fitting algorithm. It fits a polynomial of degree m through a set of co-ordinates. The code I used was written by Alain G. Kapitho.","rawEmail":"Return-Path: &lt;shanemcdonaldryan@...&gt;\r\nX-Sender: shanemcdonaldryan@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 8083 invoked from network); 17 Apr 2007 10:03:43 -0000\r\nReceived: from unknown (66.218.66.72)\n  by m44.grp.scd.yahoo.com with QMQP; 17 Apr 2007 10:03:43 -0000\r\nReceived: from unknown (HELO n21a.bullet.scd.yahoo.com) (66.94.237.50)\n  by mta14.grp.scd.yahoo.com with SMTP; 17 Apr 2007 10:03:43 -0000\r\nReceived: from [66.218.69.1] by n21.bullet.scd.yahoo.com with NNFMP; 17 Apr 2007 10:02:43 -0000\r\nReceived: from [66.218.66.87] by t1.bullet.scd.yahoo.com with NNFMP; 17 Apr 2007 10:02:43 -0000\r\nDate: Tue, 17 Apr 2007 10:02:43 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;f02603+qcmm@...&gt;\r\nIn-Reply-To: &lt;4623D7A8.9000309@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0\r\nFrom: &quot;shanemcdonaldryan&quot; &lt;shanemcdonaldryan@...&gt;\r\nSubject: Re: Computation Time\r\nX-Yahoo-Group-Post: member; u=292213213; y=rLHYsnJ_tyVoWGK3pTClS8ZqHQ6Z6Hkv1LYXChMwXya0H27muWuGZ_AiICw\r\nX-Yahoo-Profile: shanemcdonaldryan\r\n\r\nI am using a least squares fitting algorithm. It fits a polynomial of\ndegre=\r\ne m through a set of co-ordinates. The code I used was written by\nAlain G. =\r\nKapitho. You should be able to find it via Google. The file\nis called &quot;leas=\r\nt_squares.m&quot;. I tried with various polynomial degrees\nfrom 2-12. A polynomi=\r\nal of degree five seemed to be the best trade off\nbetween speed and accurac=\r\ny. If I remember correctly I had to increase\nthe degree to about 9 before I=\r\n got superior accuracy.\n\nThere is one part that needs to be improved. If yo=\r\nu look at the first\nco-efficient c0 it starts at 0.4952 but because the alg=\r\norithm calcs\nnegative values as 1 - poly(x). A slightly negative value will=\r\n\nactually be greater than a slightly positive value. This causes a\nlitte bu=\r\nmp around the very small values near zero. Which makes the\nlearning not as =\r\nefficient as it could be. The way to solve this would\nbe to fix the first c=\r\noefficient c0 as 0.500 and solve the system of\nequations. I&#39;ll do it later =\r\nwhen I have time to get around to it. Or\nif anyone else has the time I woul=\r\nd be eternally grateful!\n\nI am not sure if my compiler does optimize away t=\r\nhe extra mults. But I\ndon&#39;t think so. I changed my code to use your idea an=\r\nd I saw a\nnoticeable decrease in the runtime of the Sigmoid approximation (=\r\n2-3\ntimes faster). Plus  I compared the error and there was only a\nnegligib=\r\nle increase in error (in the order 1e-8). So there shouldn&#39;t\nbe any real de=\r\ncrease in learning ability. I did throw away the part\nusing the ternary ope=\r\nrator because it was introducing a bug (as far as\nI could see). Plus I can&#39;=\r\nt see why multiplying using a ternary\noperator will be faster than multiply=\r\ning using *=3D -1\n\nHere is the updated code.\n\nThanks,\n\nShane\n\nconst float S=\r\nigmoidLeastSquares5(const float aNetinput, const float\naResponse)\n\n{\n\tconst=\r\n float c0 =3D\t0.4952f;\n\tconst float c1 =3D\t0.3050f;\n\tconst float c2 =3D\t-0.=\r\n0719f;\n\tconst float c3 =3D\t0.0082f;\n\tconst float c4 =3D\t-4.4987e-004f;\n\tcon=\r\nst float c5 =3D\t9.4767e-006f;\n\n\tconst float tUpperAndLowerLimit =3D 8.07505=\r\n893707;\n\n\tfloat x =3D aNetinput / aResponse;\n\n\tif( x &gt; tUpperAndLowerLimit)=\r\n\n\t\treturn 1.0f;\n\n\tif(x &lt; -tUpperAndLowerLimit)\n\t\treturn 0.0f;\n\n\tbool tLessT=\r\nhanZero =3D false;\n\n\tif(x &lt; 0.0f)\n\t{\n\t\tx *=3D -1.0f;\n\t\ttLessThanZero =3D tr=\r\nue;\n\t}\n\n\t\n\tfloat xmul =3D x;//(x &lt; 0.0f) ? -x : x;\n\tfloat tOutput1 =3D c0;\n=\r\n\ttOutput1 +=3D c1*xmul;\n\txmul *=3D x;\n\ttOutput1 +=3D c2*xmul;\n\txmul *=3D x;=\r\n\n\ttOutput1 +=3D c3*xmul;\n\txmul *=3D x;\n\ttOutput1 +=3D c4*xmul;\n\txmul *=3D x=\r\n;\n\ttOutput1 +=3D c5*xmul;\n\t//return (x &lt; 0.0f) ? 1.0f-out : out;\n\n/* \tconst=\r\n float tOutput =3D c0 + c1*x + c2*(x*x) + c3*(x*x*x) +\nc4*(x*x*x*x) + c5*(x=\r\n*x*x*x*x);\n\tconst float tDelta =3D 1e-6f;\n\tfloat tAbs =3D (tOutput1 - tOutp=\r\nut);\n\tif( tAbs &lt; 0.0f)\n\t\ttAbs *=3D -1;\n\tassert(tAbs &lt; tDelta);*/\n\tif(!tLess=\r\nThanZero)\n\t\treturn tOutput1;\n\telse\n\t\treturn 1.0f - tOutput1;\n}\n\n\n\n\n\n  \n\n\n--=\r\n- In neat@yahoogroups.com, Stephen Waits &lt;steve@...&gt; wrote:\n&gt;\n&gt; shanemcdona=\r\nldryan wrote:\n&gt; &gt; \n&gt; &gt; const float tOutput =3D c0 + c1*x + c2*(x*x) + c3*(x=\r\n*x*x) + c4*\n&gt; &gt; (x*x*x*x) + c5*(x*x*x*x*x);\n&gt; \n&gt; Cool.  What did you use fo=\r\nr the regression?  Did you try using lower\norders?\n&gt; \n&gt; Did your compiler o=\r\nptimize those extraneous multiplications away for \n&gt; you?  If not, you shou=\r\nld be able to get a bit more speed up..\n&gt; \n&gt;    float xmul =3D (x &lt; 0.0f) ?=\r\n -x : x; // better an &quot;x*=3D-1&quot;?\n&gt;    float out =3D c0;\n&gt;    out +=3D c1*xm=\r\nul;\n&gt;    xmul *=3D x;\n&gt;    out +=3D c2*xmul;\n&gt;    xmul *=3D x;\n&gt;    out +=\r\n=3D c3*xmul;\n&gt;    xmul *=3D x;\n&gt;    out +=3D c4*xmul;\n&gt;    xmul *=3D x;\n&gt;  =\r\n  out +=3D c5*xmul;\n&gt;    return (x &lt; 0.0f) ? 1.0f-out : out;\n&gt; \n&gt; 9 muls, 5=\r\n adds (vs. 15 muls, 5 adds)\n&gt; \n&gt; --Steve\n&gt;\n\n\n\n"}}