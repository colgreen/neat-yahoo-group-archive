{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":37465196,"authorName":"Ken Lloyd","from":"&quot;Ken Lloyd&quot; &lt;kalloyd@...&gt;","profile":"kalloyd2","replyTo":"LIST","senderId":"6_UaJGp_6NUd75zR44nrOdhxDWK6EAuk9oE1xtF_MHNeoETFzGMHrDt3TwB4yp6SIE0IyCRv8z4PMV3gm6MHyIABhzdEjO4H","spamInfo":{"isSpam":false,"reason":"12"},"subject":"RE: [neat] Evolving feedforward networks","postDate":"1260878348","msgId":5015,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDkwNkMwRjk3RkNENDQ5RUZBOEVEM0QwMERBMTVBNkQzQHdhdHRwND4=","inReplyToHeader":"PDA4RTE4ODI3M0RCOTQ4RDZBOTY2QTkyN0EzMDMxRDY4QHdhdHRwND4=","referencesHeader":"PDcyN2E0MDZjMDkxMjE0MTMzNnYyZWUxOTA3MGo0YzczM2MyMjM4ZGNhMWE0QG1haWwuZ21haWwuY29tPiA8MDhFMTg4MjczREI5NDhENkE5NjZBOTI3QTMwMzFENjhAd2F0dHA0Pg=="},"prevInTopic":5014,"nextInTopic":5017,"prevInTime":5014,"nextInTime":5016,"topicId":5013,"numMessagesInTopic":14,"msgSnippet":"BTW, the reason I asked has more to do with backprop through MLFF networks (which if they have recurrent paths may not be FF nets at all, in the view of some).","rawEmail":"Return-Path: &lt;kalloyd@...&gt;\r\nX-Sender: kalloyd@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 9449 invoked from network); 15 Dec 2009 11:59:10 -0000\r\nX-Received: from unknown (66.196.94.107)\n  by m14.grp.re1.yahoo.com with QMQP; 15 Dec 2009 11:59:10 -0000\r\nX-Received: from unknown (HELO QMTA14.emeryville.ca.mail.comcast.net) (76.96.27.212)\n  by mta3.grp.re1.yahoo.com with SMTP; 15 Dec 2009 11:59:10 -0000\r\nX-Received: from OMTA10.emeryville.ca.mail.comcast.net ([76.96.30.28])\n\tby QMTA14.emeryville.ca.mail.comcast.net with comcast\n\tid HPmF1d0030cQ2SLAEPz7qk; Tue, 15 Dec 2009 11:59:07 +0000\r\nX-Received: from wattp4 ([174.56.66.94])\n\tby OMTA10.emeryville.ca.mail.comcast.net with comcast\n\tid HPz61d002221HGW8WPz6pY; Tue, 15 Dec 2009 11:59:07 +0000\r\nTo: &lt;neat@yahoogroups.com&gt;\r\nReferences: &lt;727a406c0912141336v2ee19070j4c733c2238dca1a4@...&gt; &lt;08E188273DB948D6A966A927A3031D68@wattp4&gt;\r\nDate: Tue, 15 Dec 2009 04:59:08 -0700\r\nMessage-ID: &lt;906C0F97FCD449EFA8ED3D00DA15A6D3@wattp4&gt;\r\nMIME-Version: 1.0\r\nContent-Type: multipart/alternative;\n\tboundary=&quot;----=_NextPart_000_05AB_01CA7D43.55D51830&quot;\r\nX-Mailer: Microsoft Office Outlook 11\r\nThread-Index: Acp9BlyUOuU2snYdRVmrmq9VTImEFAAG6OdAABbx1YA=\r\nIn-Reply-To: &lt;08E188273DB948D6A966A927A3031D68@wattp4&gt;\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.5579\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Ken Lloyd&quot; &lt;kalloyd@...&gt;\r\nSubject: RE: [neat] Evolving feedforward networks\r\nX-Yahoo-Group-Post: member; u=37465196; y=ye0WdxpbUDyP4KA-wGQsqyFODJpXeFu90Zh094JGOkfDrxo\r\nX-Yahoo-Profile: kalloyd2\r\n\r\n\r\n------=_NextPart_000_05AB_01CA7D43.55D51830\r\nContent-Type: text/plain;\n\tcharset=&quot;US-ASCII&quot;\r\nContent-Transfer-Encoding: 7bit\r\n\r\nBTW, the reason I asked has more to do with backprop through MLFF networks\n(which if they have recurrent paths may not be FF nets at all, in the view\nof some).\n\n\n  _____  \n\nFrom: neat@yahoogroups.com [mailto:neat@yahoogroups.com] On Behalf Of Ken\nLloyd\nSent: Monday, December 14, 2009 6:03 PM\nTo: neat@yahoogroups.com\nSubject: RE: [neat] Evolving feedforward networks\n\n\n  \n\n\n\nColin,\n \nDo you think a feed-forward network can have recurrent paths?  In other\nwords, must it be &quot;strictly&quot; feed-forward? Or can it generally exhibit\nforward directional traits?\n \nKen Lloyd\n\n\n  _____  \n\nFrom: neat@yahoogroups.com [mailto:neat@yahoogroups.com] On Behalf Of Colin\nGreen\nSent: Monday, December 14, 2009 2:37 PM\nTo: neat@yahoogroups.com\nSubject: [neat] Evolving feedforward networks\n\n\n  \n\nHi,\n\nKen&#39;s response to Daniel Tuohy&#39;s yesterday briefly touched on\nevolution of feedforward-only networks and this is somethign I&#39;ve been\nmeaning to think about for some time. My initial thoughts on how to do\nthis relatively efficiently are as follows:\n\n1) Start out with a feedforward only graph (e.g. the typical NEAT\ninitial population with conenctions from inputs to outputs).\n2) We initialise each node with a list of all the nodes that are above\nit in the graph, let&#39;s call this the &#39;ancestor&#39; list (A-list or A-node\nlist for short)\n3) With recursive networks, in order to add a connection we typically\nrandomly search pairs of source and target node IDs until we find a\npair that does not exist in the existign connection genes. Now we can\nadd the additional test that the target node ID is not in the source\nnode&#39;s A-list. This eliminates the need to traverse the network,\neffectively recalculating each node&#39;s A-List each time.\n4) When we create a new node by splitting a conenction, the new node\ncreates it&#39;s own A-list by takign a copy the source node&#39;s A-List plus\nthe source node&#39;s ID.\n\nThe A-lists can become part of the genome so that we never have to\ntraverse networks to rebuild A-lists, they just get copied when we\ncreate offspring genomes/networks. Ok so now you&#39;re all thinking that\nthe memory requirements for this could get unwieldy. We can reduce\nmemory requirements by using bitmaps where each node ID get&#39;s it&#39;s own\nlocation in an array of bits, thus if the IDs are 32bit integers we\nget a 32x reduction in storage space requirements. As a bonus, testing\nif a node is in a given A-list should be almost intantaneous, versus\nthe O(log n) time complexity of a binary search against a sorted list\nof integer IDs.\n\nThe first problem I see is that the set of innovation IDs currently in\nuse in a given population becomes patchy, e.g. some early IDs may\nsimply not exist any more (although I&#39;m not 100% if this happens in\nreality). So lets say NEAT has been running a while and the innovation\nID variable is up to 100,000. Each node requires its own bit in each\nA-list regardless of whether it is set or not, therefore the A-lists\nare 100000/8 = 12,500 bytes in size (I&#39;m assuming the A-lists grow\nover time, along with the innovation ID counter). We can however\nreduce this memory requirement by periodically stoppign NEAT and\ndefragmenting the ID space, this allows us to reuse the low IDs that\nare no longer in use anymore (no node anywhere in the population uses\nit) and thus the size of the A-list only needs to refelct the number\nof /active/ node IDs rather than the number of IDs there has ever\nbeen.\n\nThinking ahead to distributed-NEAT algorithms this potentially creates\na new problem when/if we need to pass genome between clusteres - the\nnode IDs of like nodes no longer match up. The proposed solution there\nis to have a periodic system wide defragmentation take place\nencompassing all nodes, or alternatively each distribution node\nmaintains a mapping between &#39;global&#39; innovation IDs and the local\ndefragmented IDs.\n\nI&#39;d be interested hear other&#39;s ideas on this topic. Perhaps there&#39;s\nsome more elegant approach using clever allocation of IDs to indicate\nwhere a node lies in the network of ancestors, e.g. if node IDs are\ntaken to be a height measured from top to bottom of the network, we\ncan assign and modify node IDs so that we can simply compare two IDs\nto see their relative position in the top-down graph - the problem\nthere being that we can no longer use the IDs as innovation numbers;\nHowever we could simply use two variables - innovation ID and a\nheight/position. One downside there is that only one node can occupy a\ngiven height and since the number of height levels is limits (e.g. to\n2^32 for a 32 bit variable) the number of nodes in a network is\nlimited, on the other hand that&#39;s potentially a very high limit.\nPerhaps the tricky part is decidign what to do when mating two\nnetworks.\n\nThis post is already too long so I&#39;m going to stop :)\n\nColin\n\n\n\n\n\n\n\r\n------=_NextPart_000_05AB_01CA7D43.55D51830\r\nContent-Type: text/html;\n\tcharset=&quot;US-ASCII&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;\n&lt;HTML&gt;&lt;HEAD&gt;=\r\n\n&lt;META content=3D&quot;text/html; charset=3Dus-ascii&quot; http-equiv=3DContent-Type&gt;=\r\n\n&lt;META name=3DGENERATOR content=3D&quot;MSHTML 8.00.6001.18854&quot;&gt;&lt;/HEAD&gt;\n&lt;BODY st=\r\nyle=3D&quot;BACKGROUND-COLOR: #fff&quot;&gt;\n&lt;DIV dir=3Dltr align=3Dleft&gt;&lt;SPAN class=3D5=\r\n42305711-15122009&gt;&lt;FONT color=3D#0000ff \nsize=3D2 face=3DArial&gt;BTW, the rea=\r\nson I asked has more to do with backprop through \nMLFF networks (which if t=\r\nhey have recurrent paths may not be FF nets at all, in \nthe view of some).&lt;=\r\n/FONT&gt;&lt;/SPAN&gt;&lt;/DIV&gt;&lt;BR&gt;\n&lt;BLOCKQUOTE \nstyle=3D&quot;BORDER-LEFT: #0000ff 2px soli=\r\nd; PADDING-LEFT: 5px; MARGIN-LEFT: 5px; MARGIN-RIGHT: 0px&quot;&gt;\n  &lt;DIV dir=3Dlt=\r\nr lang=3Den-us class=3DOutlookMessageHeader align=3Dleft&gt;\n  &lt;HR tabIndex=3D=\r\n-1&gt;\n  &lt;FONT size=3D2 face=3DTahoma&gt;&lt;B&gt;From:&lt;/B&gt; neat@yahoogroups.com \n  [ma=\r\nilto:neat@yahoogroups.com] &lt;B&gt;On Behalf Of &lt;/B&gt;Ken Lloyd&lt;BR&gt;&lt;B&gt;Sent:&lt;/B&gt; \n =\r\n Monday, December 14, 2009 6:03 PM&lt;BR&gt;&lt;B&gt;To:&lt;/B&gt; \n  neat@yahoogroups.com&lt;BR=\r\n&gt;&lt;B&gt;Subject:&lt;/B&gt; RE: [neat] Evolving feedforward \n  networks&lt;BR&gt;&lt;/FONT&gt;&lt;BR&gt;=\r\n&lt;/DIV&gt;\n  &lt;DIV&gt;&lt;/DIV&gt;&lt;SPAN style=3D&quot;DISPLAY: none&quot;&gt;&nbsp;&lt;/SPAN&gt; \n  &lt;DIV id=\r\n=3Dygrp-text&gt;\n  &lt;P&gt;\n  &lt;DIV dir=3Dltr align=3Dleft&gt;&lt;SPAN class=3D933310001-1=\r\n5122009&gt;&lt;FONT color=3D#0000ff \n  size=3D2 face=3DArial&gt;Colin,&lt;/FONT&gt;&lt;/SPAN&gt;=\r\n&lt;/DIV&gt;\n  &lt;DIV dir=3Dltr align=3Dleft&gt;&lt;SPAN class=3D933310001-15122009&gt;&lt;FONT=\r\n color=3D#0000ff \n  size=3D2 face=3DArial&gt;&lt;/FONT&gt;&lt;/SPAN&gt;&nbsp;&lt;/DIV&gt;\n  &lt;DIV=\r\n dir=3Dltr align=3Dleft&gt;&lt;SPAN class=3D933310001-15122009&gt;&lt;FONT color=3D#000=\r\n0ff \n  size=3D2 face=3DArial&gt;Do you think a feed-forward network can have r=\r\necurrent \n  paths?&nbsp; In other words, must it be &quot;strictly&quot; feed-forward=\r\n? Or can it \n  generally exhibit forward directional traits?&lt;/FONT&gt;&lt;/SPAN&gt;&lt;=\r\n/DIV&gt;\n  &lt;DIV dir=3Dltr align=3Dleft&gt;&lt;SPAN class=3D933310001-15122009&gt;&lt;FONT =\r\ncolor=3D#0000ff \n  size=3D2 face=3DArial&gt;&lt;/FONT&gt;&lt;/SPAN&gt;&nbsp;&lt;/DIV&gt;\n  &lt;DIV =\r\ndir=3Dltr align=3Dleft&gt;&lt;SPAN class=3D933310001-15122009&gt;&lt;FONT color=3D#0000=\r\nff \n  size=3D2 face=3DArial&gt;Ken Lloyd&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/DIV&gt;&lt;BR&gt;\n  &lt;BLOCKQUOTE=\r\n style=3D&quot;BORDER-LEFT: #0000ff 2px solid&quot;&gt;\n    &lt;DIV dir=3Dltr lang=3Den-us =\r\nclass=3DOutlookMessageHeader align=3Dleft&gt;\n    &lt;HR tabIndex=3D-1&gt;\n    &lt;FONT=\r\n size=3D2 face=3DTahoma&gt;&lt;B&gt;From:&lt;/B&gt; neat@yahoogroups.&lt;WBR&gt;com \n    [mailto=\r\n:neat@&lt;WBR&gt;yahoogroups.&lt;WBR&gt;com] &lt;B&gt;On Behalf Of &lt;/B&gt;Colin \n    Green&lt;BR&gt;&lt;B=\r\n&gt;Sent:&lt;/B&gt; Monday, December 14, 2009 2:37 PM&lt;BR&gt;&lt;B&gt;To:&lt;/B&gt; \n    neat@yahoog=\r\nroups.&lt;WBR&gt;com&lt;BR&gt;&lt;B&gt;Subject:&lt;/B&gt; [neat] Evolving feedforward \n    networks=\r\n&lt;BR&gt;&lt;/FONT&gt;&lt;BR&gt;&lt;/DIV&gt;\n    &lt;DIV&gt;&lt;/DIV&gt;&lt;SPAN&gt;&nbsp;&lt;/SPAN&gt; \n    &lt;DIV id=3Dygr=\r\np-text&gt;\n    &lt;P&gt;Hi,&lt;BR&gt;&lt;BR&gt;Ken&#39;s response to Daniel Tuohy&#39;s yesterday briefl=\r\ny touched \n    on&lt;BR&gt;evolution of feedforward-&lt;WBR&gt;only networks and this i=\r\ns somethign I&#39;ve \n    been&lt;BR&gt;meaning to think about for some time. My init=\r\nial thoughts on how to \n    do&lt;BR&gt;this relatively efficiently are as follow=\r\ns:&lt;BR&gt;&lt;BR&gt;1) Start out with a \n    feedforward only graph (e.g. the typical=\r\n NEAT&lt;BR&gt;initial population with \n    conenctions from inputs to outputs).&lt;=\r\nBR&gt;2) We initialise each node with a \n    list of all the nodes that are ab=\r\nove&lt;BR&gt;it in the graph, let&#39;s call this the \n    &#39;ancestor&#39; list (A-list or=\r\n A-node&lt;BR&gt;list for short)&lt;BR&gt;3) With recursive \n    networks, in order to =\r\nadd a connection we typically&lt;BR&gt;randomly search pairs \n    of source and t=\r\narget node IDs until we find a&lt;BR&gt;pair that does not exist in \n    the exis=\r\ntign connection genes. Now we can&lt;BR&gt;add the additional test that \n    the =\r\ntarget node ID is not in the source&lt;BR&gt;node&#39;s A-list. This eliminates \n    =\r\nthe need to traverse the network,&lt;BR&gt;effectively recalculating each node&#39;s =\r\n\n    A-List each time.&lt;BR&gt;4) When we create a new node by splitting a conen=\r\nction, \n    the new node&lt;BR&gt;creates it&#39;s own A-list by takign a copy the so=\r\nurce node&#39;s \n    A-List plus&lt;BR&gt;the source node&#39;s ID.&lt;BR&gt;&lt;BR&gt;The A-lists ca=\r\nn become part of \n    the genome so that we never have to&lt;BR&gt;traverse netwo=\r\nrks to rebuild A-lists, \n    they just get copied when we&lt;BR&gt;create offspri=\r\nng genomes/networks. Ok so now \n    you&#39;re all thinking that&lt;BR&gt;the memory =\r\nrequirements for this could get \n    unwieldy. We can reduce&lt;BR&gt;memory requ=\r\nirements by using bitmaps where each \n    node ID get&#39;s it&#39;s own&lt;BR&gt;locatio=\r\nn in an array of bits, thus if the IDs are \n    32bit integers we&lt;BR&gt;get a =\r\n32x reduction in storage space requirements. As a \n    bonus, testing&lt;BR&gt;if=\r\n a node is in a given A-list should be almost \n    intantaneous, versus&lt;BR&gt;=\r\nthe O(log n) time complexity of a binary search \n    against a sorted list&lt;=\r\nBR&gt;of integer IDs.&lt;BR&gt;&lt;BR&gt;The first problem I see is \n    that the set of i=\r\nnnovation IDs currently in&lt;BR&gt;use in a given population \n    becomes patchy=\r\n, e.g. some early IDs may&lt;BR&gt;simply not exist any more \n    (although I&#39;m n=\r\not 100% if this happens in&lt;BR&gt;reality). So lets say NEAT has \n    been runn=\r\ning a while and the innovation&lt;BR&gt;ID variable is up to 100,000. \n    Each n=\r\node requires its own bit in each&lt;BR&gt;A-list regardless of whether it is \n   =\r\n set or not, therefore the A-lists&lt;BR&gt;are 100000/8 =3D 12,500 bytes in size=\r\n \n    (I&#39;m assuming the A-lists grow&lt;BR&gt;over time, along with the innovatio=\r\nn ID \n    counter). We can however&lt;BR&gt;reduce this memory requirement by per=\r\niodically \n    stoppign NEAT and&lt;BR&gt;defragmenting the ID space, this allows=\r\n us to reuse the \n    low IDs that&lt;BR&gt;are no longer in use anymore (no node=\r\n anywhere in the \n    population uses&lt;BR&gt;it) and thus the size of the A-lis=\r\nt only needs to refelct \n    the number&lt;BR&gt;of /active/ node IDs rather than=\r\n the number of IDs there has \n    ever&lt;BR&gt;been.&lt;BR&gt;&lt;BR&gt;Thinking ahead to di=\r\nstributed-&lt;WBR&gt;NEAT algorithms this \n    potentially creates&lt;BR&gt;a new probl=\r\nem when/if we need to pass genome between \n    clusteres - the&lt;BR&gt;node IDs =\r\nof like nodes no longer match up. The proposed \n    solution there&lt;BR&gt;is to=\r\n have a periodic system wide defragmentation take \n    place&lt;BR&gt;encompassin=\r\ng all nodes, or alternatively each distribution \n    node&lt;BR&gt;maintains a ma=\r\npping between &#39;global&#39; innovation IDs and the \n    local&lt;BR&gt;defragmented ID=\r\ns.&lt;BR&gt;&lt;BR&gt;I&#39;d be interested hear other&#39;s ideas on \n    this topic. Perhaps =\r\nthere&#39;s&lt;BR&gt;some more elegant approach using clever \n    allocation of IDs t=\r\no indicate&lt;BR&gt;where a node lies in the network of \n    ancestors, e.g. if n=\r\node IDs are&lt;BR&gt;taken to be a height measured from top to \n    bottom of the=\r\n network, we&lt;BR&gt;can assign and modify node IDs so that we can \n    simply c=\r\nompare two IDs&lt;BR&gt;to see their relative position in the top-down \n    graph=\r\n - the problem&lt;BR&gt;there being that we can no longer use the IDs as \n    inn=\r\novation numbers;&lt;BR&gt;However we could simply use two variables - \n    innova=\r\ntion ID and a&lt;BR&gt;height/position. One downside there is that only one \n    =\r\nnode can occupy a&lt;BR&gt;given height and since the number of height levels is =\r\n\n    limits (e.g. to&lt;BR&gt;2^32 for a 32 bit variable) the number of nodes in =\r\na \n    network is&lt;BR&gt;limited, on the other hand that&#39;s potentially a very h=\r\nigh \n    limit.&lt;BR&gt;Perhaps the tricky part is decidign what to do when mati=\r\nng \n    two&lt;BR&gt;networks.&lt;BR&gt;&lt;BR&gt;This post is already too long so I&#39;m going =\r\nto stop \n    :)&lt;BR&gt;&lt;BR&gt;Colin&lt;BR&gt;&lt;/P&gt;&lt;/DIV&gt;&lt;!-- end group email --&gt;&lt;/BLOCKQU=\r\nOTE&gt;\n  &lt;P&gt;&lt;/P&gt;&lt;/DIV&gt;&lt;!-- end group email --&gt;&lt;/BODY&gt;&lt;/HTML&gt;\n\r\n------=_NextPart_000_05AB_01CA7D43.55D51830--\r\n\n"}}