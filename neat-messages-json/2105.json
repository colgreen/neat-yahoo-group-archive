{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":151231063,"authorName":"Joseph Reisinger","from":"Joseph Reisinger &lt;joeraii@...&gt;","profile":"joeraii","replyTo":"LIST","senderId":"YIVtF0yU5LyrLX6OUS0exfhhCZVwlcE2YNMm-Nj_dlWvFTYS2oeBRxVqsl20Sqv3Uii-D15lm3RRkw8RXbeAkrA_kgMFRJjxntgANlyz7w","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Introduction/Some Questions","postDate":"1121660550","msgId":2105,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDA3QzE1NDczLTNGNjYtNDc3Qi1BRjc1LUU2RjlDRjM3N0NBNEBjcy51dGV4YXMuZWR1Pg==","inReplyToHeader":"PG9wc3R6NnVzczN4NHAzM21AbWFpbC51dGV4YXMuZWR1Pg==","referencesHeader":"PGRiN240ZStqOXNmQGVHcm91cHMuY29tPiA8UGluZS5MTlguNC42My4wNTA3MTUwOTMyMDYwLjQzMDNAb3JhbmdlLXBla29lLmNzLnV0ZXhhcy5lZHU+IDxvcHN0ejZ1c3MzeDRwMzNtQG1haWwudXRleGFzLmVkdT4="},"prevInTopic":2096,"nextInTopic":2107,"prevInTime":2104,"nextInTime":2106,"topicId":2088,"numMessagesInTopic":13,"msgSnippet":"... I wouldn t say everyone is anti-modular, they just seem focused more on issues with the standard NEAT implementation, which just by itself has quite a lot","rawEmail":"Return-Path: &lt;joeraii@...&gt;\r\nX-Sender: joeraii@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 91465 invoked from network); 18 Jul 2005 04:22:44 -0000\r\nReceived: from unknown (66.218.66.166)\n  by m30.grp.scd.yahoo.com with QMQP; 18 Jul 2005 04:22:44 -0000\r\nReceived: from unknown (HELO mail.cs.utexas.edu) (128.83.139.10)\n  by mta5.grp.scd.yahoo.com with SMTP; 18 Jul 2005 04:22:44 -0000\r\nReceived: from [67.154.88.191] ([67.154.88.191])\n\t(authenticated bits=0)\n\tby mail.cs.utexas.edu (8.13.4/8.13.4) with ESMTP id j6I4MdXO010676\n\tfor &lt;neat@yahoogroups.com&gt;; Sun, 17 Jul 2005 23:22:42 -0500 (CDT)\r\nMime-Version: 1.0 (Apple Message framework v733)\r\nIn-Reply-To: &lt;opstz6uss3x4p33m@...&gt;\r\nReferences: &lt;db7n4e+j9sf@...&gt; &lt;Pine.LNX.4.63.0507150932060.4303@...&gt; &lt;opstz6uss3x4p33m@...&gt;\r\nContent-Type: text/plain; charset=US-ASCII; delsp=yes; format=flowed\r\nMessage-Id: &lt;07C15473-3F66-477B-AF75-E6F9CF377CA4@...&gt;\r\nContent-Transfer-Encoding: 7bit\r\nDate: Sun, 17 Jul 2005 23:22:30 -0500\r\nTo: neat@yahoogroups.com\r\nX-Mailer: Apple Mail (2.733)\r\nX-eGroups-Msg-Info: 1:12:0\r\nFrom: Joseph Reisinger &lt;joeraii@...&gt;\r\nSubject: Re: [neat] Introduction/Some Questions\r\nX-Yahoo-Group-Post: member; u=151231063; y=_mF5RO5AleUBnppAwUCIIy_wfw0Oi3EK5j78JXjM07u--g\r\nX-Yahoo-Profile: joeraii\r\n\r\n&gt;\n&gt; Yea, this was the first thing that hit me when I read about NEAT..  \n&gt; Is there an anti-modular contingency? If there is, we&#39;ll show &#39;em ;)\n\nI wouldn&#39;t say everyone is anti-modular, they just seem focused more  \non issues with the standard NEAT implementation, which just by itself  \nhas quite a lot of issues :) Though to be fair both Ken and I have  \ncome to the conclusion that the ad-hoc kind of modularity present in  \ne.g. mNEAT is kind of the wrong way to approach the problem. Thats  \nnot to say doing work in the area is not extremely valuable (and may  \nyield some excellent results), its just that there might be other,  \nbetter ways of doing modularity besides explicit modularization. Ken  \nand I wrote a position statement that appeared in a GECCO workshop on  \nmodularity last year that focuses on this topic. If you haven&#39;t  \nalready, I&#39;d say it might be worth reading. Its available here:\n\nhttp://nn.cs.utexas.edu/keyword?stanley:gecco04ws\n\n\n&gt; If the parent has a mechanism for adding this mutation itself, then  \n&gt; it seems like this is exactly what you would not want to do.  In  \n&gt; fact, I was going to go further than that.  Rather than use the  \n&gt; average I wanted to multiply the fitnesses together specifically so  \n&gt; this wouldn&#39;t happen.  I&#39;m not sure I understand why this doesn&#39;t  \n&gt; make sense, isn&#39;t it exactly the selective pressure that we are  \n&gt; looking for?  Maybe I need to read your paper again, its been a  \n&gt; while =]\n&gt;\n&gt; As a side note actually, I&#39;ve found that this method (multiplying  \n&gt; fitness together rather than averaging them) was helpful when  \n&gt; evaluating a network on multiple random runs.  If I used the  \n&gt; average networks would fall into the local minimum of solving the  \n&gt; problem really well some of the time rather than trying to solve  \n&gt; the problem all the time.  This worked really well, so I&#39;m sure its  \n&gt; not a new idea I just don&#39;t know what its called.  To control the  \n&gt; intensity of the effect I actually divide by n and 1 before  \n&gt; multiplying.\n&gt;\n\nI&#39;ve been trying to wrap my head around the properties of a  \n&quot;multiplicative average&quot; like that. It seems like it would be  \nbeneficial, but I&#39;m still not sure I see why. Basically you get the  \nsame effect as it you did something like exp(fitness) for each  \nindividual and then averaged right? But you still have the same  \nfundamental problem where the fitness of module A is the same as  \nmodule B:\n\nf(A): [0.1, 0.1, 0.1, 1000]\nf(B): [1, 1, 1, 1]\n\nBut in this case wouldn&#39;t you want to reward module A more, since in  \none case it has a fitness 1000 times better than module B? In fact  \nwith this example multiplication yields:\n\nf(A) = 1\nf(B) = 1\n\nwhile standard averaging yields:\n\nf(A) ~= 250\nf(B) = 1\n\nSo standard averaging would actually be more biased towards solutions  \nthat excel in only trial. Anyway I&#39;m sure I&#39;m probably missing  \nsomething.\n\n&gt;\n&gt;&gt;\n&gt;&gt; One approach Ken and I discussed akin to this is &quot;hierarchical\n&gt;&gt; modularizing NEAT&quot; where subpopulations could have their own\n&gt;&gt; subpopulations of modules, ad infinitum. This allows evolution to  \n&gt;&gt; choose the\n&gt;&gt; right granularity for each module more effectively, at the cost of  \n&gt;&gt; having\n&gt;&gt; to evaluate many, many more subpopulations. Initially, you don&#39;t  \n&gt;&gt; really\n&gt;&gt; know how complex a module needs to be, so you start by making  \n&gt;&gt; naive module\n&gt;&gt; partitions. Later, however, it may turn out that some modules you\n&gt;&gt; partitioned off can stay simple, but others may need to become very\n&gt;&gt; complex (i.e. should be constructed out of sub-modules). Anyway,  \n&gt;&gt; it seems\n&gt;&gt; your approach is a good first step towards this. I&#39;m very  \n&gt;&gt; interested in to\n&gt;&gt; see your results.\n&gt;&gt;\n&gt;\n&gt; Yea, I&#39;ve thought about the recursive idea as well, although I&#39;m  \n&gt; not clear how that solves any of the above problems (maybe you  \n&gt; didn&#39;t mean to imply that it did?).  This would be particularly  \n&gt; nice if it was in an environment were evolution was able to decide  \n&gt; how much modularity was needed etc.  It certainly would not be  \n&gt; difficult to make the algorithm heirchical as in essence it already  \n&gt; is.\n\nNo sorry, I wrote the email in non-linear pieces and then re-arranged  \nthem all, this one ended up in the wrong spot. I didn&#39;t mean to imply  \nit solves the problems (in fact it creates a few more), but I thought  \nit would be interesting to throw out as an example, as it highlights  \none of the deeper issues with modularity.\n\n\n&gt;&gt; Did Risto show you the (unpublished) paper by Steetskamp? He did some\n&gt;&gt; tests on doing SANE/ESP with things other than fully connected  \n&gt;&gt; nodes (for\n&gt;&gt; example individual links, half-nodes, etc). And the main thing he  \n&gt;&gt; found\n&gt;&gt; was that once you introduce hard-dependencies between two modules  \n&gt;&gt; (i.e. if\n&gt;&gt; module A&#39;s output feeds only into module B), then correctly  \n&gt;&gt; evaluating\n&gt;&gt; module performance becomes very difficult (i.e. module A&#39;s fitness  \n&gt;&gt; is now\n&gt;&gt; completely at the whim of module B, and vice-versa).\n&gt;&gt;\n&gt;\n&gt; Right well this makes sense, in this case there really aren&#39;t two  \n&gt; seperate modules.  This doesn&#39;t seem deadly though, essentially you  \n&gt; would just have one module but you&#39;d be treating it like two, so  \n&gt; its not a big deal, right?   You could even do a check every x  \n&gt; generations and if combine modules together if they always appear  \n&gt; together. Feels like a hack though.\n\nIts deadly if the selective pressures aren&#39;t well aligned (which is  \nvery often the case), i.e. if one module is receiving reward for  \nsomething else entirely, and therefore doesn&#39;t have to &quot;play nice&quot;  \nwith the other module in order to evolve. You can imagine a case  \nwhere the downstream module keeps having its inputs changed whenever  \nthe upstream module changes, therefore during evolution, downstream  \nmodules that perform well in one fitness trial may perform poorly in  \nthe next. In general its very difficult to perform evolution on a  \npopulation like this that has little control over its own fitness  \nfrom generation to generation, as it basically destroys information  \nabout evolvability.\n\n&gt;\n&gt;&gt; Anyway,  if the building block is just a link, how would you then do\n&gt;&gt; complexification? You&#39;d need some mechanism to pull in more inputs\n&gt;&gt; and maybe more outputs later (similar perhaps to Shimon&#39;s work on  \n&gt;&gt; fsNEAT).\n&gt;&gt;\n&gt;\n&gt; I don&#39;t think this is necessarily true, can&#39;t we run neat on a one  \n&gt; input/one output problem? It should work the same way.  This could  \n&gt; actually be an interesting restriction because it requires the  \n&gt; module to &#39;compute&#39; something and pass it on, rather than operate  \n&gt; the way a NN normally would.  But it was really just a random  \n&gt; thought..\n&gt;\n\nThis may work fine for some problems, but in the majority of cases I  \nthink you need to pull input from at least two inputs in order to be  \nuseful. For example consider a board game domain. Compare the number  \nof useful functions you can perform using a single location as input,  \nvs using a small local area. In mNEAT we started with modules as  \nsingle links, but allowed them to expand with add-input and add- \noutput mutations. I did some tests as well (unreported in the paper)  \non varying the initial module size (2x2, 3x3, etc), and it turns out  \nminimal starting performs better most of the time, the tradeoff is  \nthat you end up using more modules in early evolution to &quot;flesh-out&quot;  \nthe network.\n\n\n&gt;\n&gt;&gt;&gt; Think along these lines brought up some other questions.  When NEAT\n&gt;&gt;&gt; adds a node it actually is functionally no different then a weight\n&gt;&gt;&gt; mutation (with the exception of the non-linearity of the sigmoid).\n&gt;&gt;&gt; For a node to really add functionality above what direct link can\n&gt;&gt;&gt; accomplish it must at least have two inputs or two outputs.  So for\n&gt;&gt;&gt; NEAT to take advantage of a new node mutation it actually has to get\n&gt;&gt;&gt; lucky twice, once to add node in the right place, and another two  \n&gt;&gt;&gt; add\n&gt;&gt;&gt; a link to/from it.  I think in general this problem is  \n&gt;&gt;&gt; sidestepped by\n&gt;&gt;&gt; having a much higher add-connection rate.  If I&#39;m right on this  \n&gt;&gt;&gt; (am I?\n&gt;&gt;&gt; ) then perhaps the mutation should  be changed to add a node which\n&gt;&gt;&gt; connects two inputs/outputs simultaneously, or n inputs/outputs?\n&gt;&gt;&gt;\n&gt;&gt;\n&gt;&gt; This is probably worth exploring. I&#39;ll defer to Ken on discussing it,\n&gt;&gt; though.\n&gt;&gt;\n&gt;\n&gt; Ken?\n\nI /think/ this has been discussed on the list before, but I don&#39;t  \nrecall exactly what the consensus was. You might try browsing the  \narchives.\n\n&gt;\n&gt;\n&gt; You are right though in that this is more rigid, however I think  \n&gt; I&#39;ve settled on this for now for several reasons.  One of the most  \n&gt; important being that I can make sure that this type of modularity  \n&gt; exists easily by using a problem which requires distinct  \n&gt; behaviours.  Perhaps actually we (or I?) should expand the  \n&gt; vocabularity a bit as I can think of three distinct types of  \n&gt; modularity which probably shouldn&#39;t be lumped up.  One type is the  \n&gt; sequential: do this, then using the result do something else.   \n&gt; Second type is to do two things both at the same time, but in  \n&gt; parallel, and the third is to do one thing sometimes, and do  \n&gt; something else another time.  So ideally I think there should be a  \n&gt; system which is easily capable of doing all of these recursively  \n&gt; and arbitrarily intermixed.  So this becomes sort of a GP on top of  \n&gt; NEAT modules as building blocks sort of thing (a smooth GP.. at  \n&gt; least in my head).\n\nThese correspond to the engineering view of modularity as a black-box  \nprocessing unit (inputs/outputs well defined). Another way of  \nthinking about modularity is based on the degree of component  \nlinkage. In biology, regulatory interactions form a (roughly) scale- \nfree networks structure (i.e. a network where most nodes have few  \ninputs/outputs, but some a few &quot;hub&quot; nodes have many). Combining this  \nwith the ability of RNA to bind with a varying degree of  \neffectiveness to different binding sites you get a notion of weak-  \nvs. strong-linkage. Components that are weakly connected don&#39;t affect  \neach other very much (i.e. are compartmentalized as &quot;modules&quot;),  \nwhereas strongly connected components are very interdependent and  \ncannot be changed easily without requiring that the linked components  \nchange as well. By allowing the degrees of &quot;linkedness&quot; to change,  \nyou get a really nice smooth, non-ad-hoc way of implementing  \nhierarchy and reusable modularity.\n\n&gt;\n&gt; Anyway, so the most perplexing thing for me right now (you touched  \n&gt; on this above) seems to be how to combine the evolution of the  \n&gt; different levels, especially since the selection pressures will be  \n&gt; changing.  In my mind the best solution that I&#39;ve come to is to  \n&gt; just wipe the slate clean everytime.  This is how this would work  \n&gt; for the switch network idea (although this could be applied  \n&gt; elsewhere too):\n&gt;\n&gt; 1. Regular NEAT tries to solve the problem.\n&gt; 2. A switching network evolves using the resulting species as sub- \n&gt; behaviours\n&gt; 3. The old NEAT population is wiped clean and now n NEAT  \n&gt; populations co-evolve as the sub-behaviours using the winning  \n&gt; switch network.\n&gt; 4. The switch evolves from scratch using the new NEAT populations  \n&gt; as the sub-behaviours.\n&gt; etc..\n&gt;\n&gt; Obviously this is computationally pretty expensive, but it seems  \n&gt; like this sort of &#39;forgetting&#39; is necessary here since the task  \n&gt; (for all the pieces) changes.  I see no other way of solving the  \n&gt; chicken and egg problem.  I have some more ideas on this, but I&#39;m  \n&gt; not sure if this is the question you were addressing?\n&gt;\n&gt;\n\nThis sounds like an interesting direction. It sidesteps some of the  \nissues involved in co-evolving everything at the same time (changing  \nselection pressures, dependent fitness evaluations, sheer cost of  \nevaluating everything). However, I&#39;m wondering how you will re- \ninitialize the sub-behavior populations after the switching network  \nhas evolved? Completely reset them? Randomize weights of the best  \ntopology? It would be interesting to see what kind of balance turns  \nout between the switching network and the sub-components. In mNEAT we  \nfound that most of the information was being stored in the bindings,  \nnot the modules themselves. A nice result would be that the switching  \nnetworks and the component behaviors are useful even when isolated  \nfrom each other (i.e. the algorithm found generally good strategies).  \nBut I suspect that in general you&#39;ll find that the two populations  \nare highly dependent.\n\n&gt;\n&gt;&gt; Anyway, this looks like a great start, and I hope you will be  \n&gt;&gt; continuing\n&gt;&gt; this work in the Fall as well.\n&gt;&gt;\n&gt;&gt;\n&gt;\n&gt; Thanks for the insightful questions, I&#39;ve actually really been  \n&gt; missing someone to bounce ideas off of.  Actually, I&#39;m not used to  \n&gt; talking about this stuff, the vocab seems a bit awkward, so I&#39;m not  \n&gt; sure I&#39;m doing my thoughts justice.. ultimately I&#39;ll just have to  \n&gt; code them I think =P\n\nA lot of the vocab is still really up in the air (especially  \nregarding modularity). I tend to defer to biology if possible, but  \nthe way biologists talk about modularity and the way engineers do is  \na bit different.\n\n-- Joe\n\n\n"}}