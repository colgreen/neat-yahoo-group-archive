{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":115403844,"authorName":"John Arrowwood","from":"&quot;John Arrowwood&quot; &lt;jarrowwx@...&gt;","profile":"jarrowwx","replyTo":"LIST","senderId":"uCWmXL9X49W_wCFvqcFsXsIKwfsH6HWElgcOJVmvoi0qpu5uuxq_tObtgak8lWjtICwgp1zeXOgRII2t-8iXiK3x4Vj6AstGZ8pUXVTC","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [neat] Re: Computation Time","postDate":"1085889551","msgId":910,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PEJBWTItRjExOEhaY0JyeWpVbG4wMDAxY2JkNkBob3RtYWlsLmNvbT4="},"prevInTopic":907,"nextInTopic":911,"prevInTime":909,"nextInTime":911,"topicId":845,"numMessagesInTopic":99,"msgSnippet":"Jim, Yes, I think I might be interested in incorporating this into my fitness evaluator code.  Which I haven t even started yet, so there s no rush... :) --","rawEmail":"Return-Path: &lt;jarrowwx@...&gt;\r\nX-Sender: jarrowwx@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 1035 invoked from network); 30 May 2004 03:59:12 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m23.grp.scd.yahoo.com with QMQP; 30 May 2004 03:59:12 -0000\r\nReceived: from unknown (HELO hotmail.com) (65.54.247.118)\n  by mta2.grp.scd.yahoo.com with SMTP; 30 May 2004 03:59:12 -0000\r\nReceived: from mail pickup service by hotmail.com with Microsoft SMTPSVC;\n\t Sat, 29 May 2004 20:59:12 -0700\r\nReceived: from 24.21.57.45 by by2fd.bay2.hotmail.msn.com with HTTP;\n\tSun, 30 May 2004 03:59:11 GMT\r\nX-Originating-Email: [jarrowwx@...]\r\nX-Sender: jarrowwx@...\r\nTo: neat@yahoogroups.com\r\nBcc: \r\nDate: Sat, 29 May 2004 20:59:11 -0700\r\nMime-Version: 1.0\r\nContent-Type: text/plain; format=flowed\r\nMessage-ID: &lt;BAY2-F118HZcBryjUln0001cbd6@...&gt;\r\nX-OriginalArrivalTime: 30 May 2004 03:59:12.0205 (UTC) FILETIME=[777D2FD0:01C445FA]\r\nX-eGroups-Remote-IP: 65.54.247.118\r\nFrom: &quot;John Arrowwood&quot; &lt;jarrowwx@...&gt;\r\nReply-To: john@...\r\nSubject: Re: [neat] Re: Computation Time\r\nX-Yahoo-Group-Post: member; u=115403844\r\nX-Yahoo-Profile: jarrowwx\r\n\r\nJim,\n\nYes, I think I might be interested in incorporating this into my fitness \nevaluator code.  Which I haven&#39;t even started yet, so there&#39;s no rush... :)\n\n-- John\n\n\n&gt;From: &quot;Jim O&#39;Flaherty, Jr.&quot; &lt;jim_oflaherty_jr@...&gt;\n&gt;Reply-To: neat@yahoogroups.com\n&gt;To: &lt;neat@yahoogroups.com&gt;\n&gt;Subject: Re: [neat] Re: Computation Time\n&gt;Date: Fri, 28 May 2004 22:29:52 -0500\n&gt;\n&gt;John,\n&gt;\n&gt;Yes, I do...or did.  :^)\n&gt;\n&gt;I have currently currently constructed the first pass in Java of an ANN \n&gt;that serializes the calculations of a single pass of an ANN *including \n&gt;recurrancy*.  Additionally, I also created it with an &quot;undo&quot; functionality \n&gt;- steps back the values in the recurrent nodes to recreate previous \n&gt;activation state for recurrent connections.  I needed that for the specific \n&gt;type of network solution I was seeking.  It is still all dynamic code \n&gt;evaluation - i.e., there is still two array lookups per weight evaluation.\n&gt;\n&gt;The name of the framework is SEMIANN (Sparsely Evaluated Matrix Interface \n&gt;ANN).\n&gt;\n&gt;SEMIANN is design complete, Javadoc-ed and has a number of JUnit tests \n&gt;implemented and it passes them all.  I am a small number of hours from \n&gt;releasing it (&lt; 5).  I just have not had the time to create a site and/or \n&gt;jump on SourceForge to deploy it.  I would not be able to be responsible \n&gt;for reliably maintaining it (which really means incorporating others&#39; \n&gt;patches, determining new release drops and the like).\n&gt;\n&gt;Anyway, I intentionally designed it such that the same &quot;configuration&quot; \n&gt;classes that are used by the dynamic evaluator (serialized computation \n&gt;engine) can be submitted to a &quot;code generator&quot; mechanism that would produce \n&gt;and compile the code so it implements an interface (the same one used by \n&gt;the dynamic implementation) such that the code could be immediately used \n&gt;and optimized by the JVM.  I have not created this code generator/code \n&gt;compiler/interface provider.  Doing so is more busy work than it is hard \n&gt;work.  And by creating all the decoupling in design, I have made it such \n&gt;that the code from the code generator can be tweaked later with no impact \n&gt;to the network configuration input nor impact the resultant interface (only \n&gt;the internals of the implementation would be &quot;changed&quot;).\n&gt;\n&gt;The fact that all of this can occur at runtime and will outperform many \n&gt;hand optimized C++ code implementations is a testament to how far Java has \n&gt;come in the last 3 years.  Please don&#39;t underestimate how much progress \n&gt;Java JVM&#39;s have made, nor how productive you can be in very short periods \n&gt;of time.  I have studied the hell out of Java performance and tweaks for \n&gt;the last 4 years.  Java is very capable, if one designs with \n&gt;high-performance in mind.\n&gt;\n&gt;As to the &quot;code generator&quot; version being faster than the dynamic evaluator \n&gt;- I would predict it could be up to 10-30% faster.  However, I cannot see \n&gt;how it is going to be much more than that, even with the JVM optimizer \n&gt;attempting to move things to registers and with super effective stack \n&gt;management.  The elimination of indirection operations will become more \n&gt;obvious as the number of weights grows exponentially.  So eventually with \n&gt;sufficiently large networks, the &quot;code generator&quot; version will just save \n&gt;more time.  I am looking forward to seeing how much it actually turns out \n&gt;to be.\n&gt;\n&gt;SEMIANN&#39;s design presumes the weights are not changed during the network \n&gt;activations.  To create a copy of the network and change the weights \n&gt;requires regenerating the configuration instances and resubmitting them to \n&gt;the dynamic evaluator and/or &quot;code generator&quot;.  That&#39;s the &quot;read only&quot; \n&gt;tradeoff to ensure maximum flexibility for the JVM when it is doing runtime \n&gt;optimization.\n&gt;\n&gt;Another project has taken me away from this framework and my own AI \n&gt;development since the beginning of April.  I hope to return to it within \n&gt;the month.  I will then test the dynamic version thoroughly without the \n&gt;code generator.  Once I have ascertained it is working, I will release it \n&gt;under the GPL.  I will then work on the &quot;code generator&quot; version.  That \n&gt;will intially be a hack to reproduce the code for the dynamic version to \n&gt;ensure all the operations work corrrectly.  Then the implementation will be \n&gt;changed to use a very stack based/no-dereferencing instruction approach to \n&gt;eliminate all indirection lookup costs including; arrays, polymorphic \n&gt;calls, etc.  Additionally, I will look at implementing some sort of \n&gt;multi-threading configuration/execution to allow for parallel processing of \n&gt;independent aspects of the directed graph of calculations.  That is very \n&gt;hard work, though and will come much later.  I will likely want to do more \n&gt;AI specific work first and have the need come up before I go do the \n&gt;multi-threaded implementation.  Plus, it would be nice to have a couple of \n&gt;multiprocessor boxes with which I can actually exploit the multi-threading \n&gt;implementation!  :^)\n&gt;\n&gt;I did look at other kinds of optimization techniques, topically - I either \n&gt;did not understand them or , most of the matix optimization techniques \n&gt;presume a regular matrix, not a sparsely filled multi-dimensional matrix \n&gt;which is what almost all NEAT ANNs result in being.  From what I can see so \n&gt;far, a straight out sparse matrix evaluator in most (if not all) cases will \n&gt;outperform other techniques.  And this does not include issues like \n&gt;recurrance and or undo functionality, although both can be made orthagonal \n&gt;to the matrix calculation, if deemed desirable.\n&gt;\n&gt;If anyone is interested in this, please let me know and I will try to \n&gt;rearrange things in my personal life to get this released ASAP (like as \n&gt;just an E-mail as opposed to a full scale project on SourceForge).\n&gt;\n&gt;\n&gt;Respectfully,\n&gt;\n&gt;Jim O&#39;Flaherty, Jr.\n&gt;\n&gt;\n&gt;   ----- Original Message -----\n&gt;   From: John Arrowwood\n&gt;   To: neat@yahoogroups.com\n&gt;   Sent: Friday, May 28, 2004 5:07 PM\n&gt;   Subject: Re: [neat] Re: Computation Time\n&gt;\n&gt;\n&gt;   &gt;From: &quot;Mattias Fagerlund&quot; &lt;mattias@...&gt;\n&gt;   &gt;\n&gt;   &gt; &gt; No, such a thing is definitely overkill for xor.  But for image\n&gt;   &gt; &gt; enlargement,\n&gt;   &gt; &gt; where analyzing the fitness of a single network may involve billions\n&gt;   &gt; &gt; (yes,\n&gt;   &gt; &gt; billions) of activations, every little bit will help.\n&gt;   &gt;\n&gt;   &gt;For DelphiNEAT I wrote a &quot;Pascal decompiler&quot; that created pascal code\n&gt;   &gt;that represented the network. That way I could use a network that NEAT\n&gt;   &gt;evolved outside of my NEAT framework. It&#39;s not very hard - but I&#39;m not\n&gt;   &gt;sure how much faster it is.\n&gt;\n&gt;   I&#39;m wondering if what you did is anything like this...\n&gt;\n&gt;   A normal evaluation of a network walks through a list of connections and\n&gt;   looks up the weights and the nodes that it needs.  Time is spent \n&gt;calculating\n&gt;   offsets into arrays, index comparison, index increments, etc.  For \n&gt;manually\n&gt;   generated code, that&#39;s definitely the way to go, because it is \n&gt;maintainable.\n&gt;     But that maintainability comes at a speed price.\n&gt;\n&gt;   Imagine instead an algorithm that evaluates a feed-forward (no recurrent\n&gt;   connections) topology and does simple dependancy analysis.  It then \n&gt;produces\n&gt;   code that references hard-coded variables (e.g. hidden01..hidden0X) for\n&gt;   everything, and deliberately does every calculation exactly once.  The\n&gt;   resulting code could be orders of magnitude faster.\n&gt;\n&gt;   Anyone besides me have a need for something like this?\n&gt;\n&gt;\n&gt;\n&gt;         Yahoo! Groups Sponsor\n&gt;               ADVERTISEMENT\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;------------------------------------------------------------------------------\n&gt;   Yahoo! Groups Links\n&gt;\n&gt;     a.. To visit your group on the web, go to:\n&gt;     http://groups.yahoo.com/group/neat/\n&gt;\n&gt;     b.. To unsubscribe from this group, send an email to:\n&gt;     neat-unsubscribe@yahoogroups.com\n&gt;\n&gt;     c.. Your use of Yahoo! Groups is subject to the Yahoo! Terms of \n&gt;Service.\n&gt;\n&gt;\n\n\n\n"}}