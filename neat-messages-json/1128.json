{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":7192225,"authorName":"Ian Badcoe","from":"Ian Badcoe &lt;ian_badcoe@...&gt;","profile":"ian_badcoe","replyTo":"LIST","senderId":"vTtFvvq0Y-Fk9Zl1EEkx1QB37KyXtMH7rDA-tY16oTmRNqQwJg2t_qW97AY6B4t3i6wWPICvSREt_jP89iRtBYd_-apbtNIB2AU","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [neat] Neural network optimization details","postDate":"1087986657","msgId":1128,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDYuMS4wLjYuMC4yMDA0MDYyMzExMTk1OS4wMjUwN2ExMEBwb3AubWFpbC55YWhvby5jby51az4=","inReplyToHeader":"PDQwRDg5MUI1LjEwOTAzMDRAZHNsLnBpcGV4LmNvbT4=","referencesHeader":"PEJBWTItRjk0VmpFc0s2OTNpc3AwMDAxM2Y2OUBob3RtYWlsLmNvbT4gPDQwRDg5MUI1LjEwOTAzMDRAZHNsLnBpcGV4LmNvbT4="},"prevInTopic":1125,"nextInTopic":0,"prevInTime":1127,"nextInTime":1129,"topicId":1106,"numMessagesInTopic":7,"msgSnippet":"... Oh yes, I should have remembered this.  Note that how much this is a problem varies a bit, because CPUs have quite a bit of specialized circuitry for","rawEmail":"Return-Path: &lt;ian_badcoe@...&gt;\r\nX-Sender: ian_badcoe@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 73080 invoked from network); 23 Jun 2004 10:48:12 -0000\r\nReceived: from unknown (66.218.66.166)\n  by m22.grp.scd.yahoo.com with QMQP; 23 Jun 2004 10:48:12 -0000\r\nReceived: from unknown (HELO smtp001.mail.ukl.yahoo.com) (217.12.11.32)\n  by mta5.grp.scd.yahoo.com with SMTP; 23 Jun 2004 10:48:12 -0000\r\nReceived: from unknown (HELO ian2k.yahoo.co.uk) (ian?badcoe@212.159.73.108 with login)\n  by smtp001.mail.ukl.yahoo.com with SMTP; 23 Jun 2004 10:48:09 -0000\r\nMessage-Id: &lt;6.1.0.6.0.20040623111959.02507a10@...&gt;\r\nX-Sender: ian_badcoe@...\r\nX-Mailer: QUALCOMM Windows Eudora Version 6.1.0.6\r\nDate: Wed, 23 Jun 2004 11:30:57 +0100\r\nTo: neat@yahoogroups.com\r\nIn-Reply-To: &lt;40D891B5.1090304@...&gt;\r\nReferences: &lt;BAY2-F94VjEsK693isp00013f69@...&gt;\n &lt;40D891B5.1090304@...&gt;\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;us-ascii&quot;; format=flowed\r\nX-eGroups-Remote-IP: 217.12.11.32\r\nFrom: Ian Badcoe &lt;ian_badcoe@...&gt;\r\nSubject: Re: [neat] Neural network optimization details\r\nX-Yahoo-Group-Post: member; u=7192225\r\nX-Yahoo-Profile: ian_badcoe\r\n\r\nAt 21:08 22/06/2004, you wrote:\n&gt;int sum=0;\n&gt;int sum0=0;\n&gt;int sum1=0;\n&gt;int sum2=0;\n&gt;for(int i=0; i&lt;myarray.length; i+=3)\n&gt;{\n&gt;    sum0 += myarray[i];\n&gt;    sum1 += myarray[i+1];\n&gt;    sum2 += myarray[i+2];\n&gt;}\n&gt;sum = sum0+sum1+sum2;\n&gt;--------------------------------------\n&gt;Note that the array length has to be a multiple of 3 in this case to\n&gt;prevent an overrun.\n\nOh yes, I should have remembered this.  Note that how much this is a \nproblem varies a bit, because CPUs have quite a bit of specialized \ncircuitry for spotting these problems and short-circuiting them (e.g. a \nvalue being written to memory and then immediately read can be copied \nstraight back into the new register before the cache write completes).\n\nAnother idea is that it is sometimes quicker to do unnecessary multiplies \nthan branches, thus:\n\nint x[10] = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 };\nfloat y[10];\n\nfor(i = 0; i &lt; 10; i++) {\n   if (x[i]) {\n     y[i] = expression#1;\n   } else {\n     y[i] = expression#2;\n   }\n}\n\nCan be slower than:\n\nfor(i = 0; i &lt; 10; i++) {\n   y[i] = expression#1 * x[i] + expression#2 * (1 - x[i]);\n}\n\nIf the costs of expression#1 and #2 are not too high.\n\nBut note that if I had written it:\n\nfor(i = 0; i &lt; 10; i++) {\n   y[i] = expression#1 * (x[i] == 1) + expression#2 * (x[i] != 1);\n}\n\nThen the compiler might have used branches internally to achieve the \ncontionals.  OTOH, if I were working in assembly, there are tricks you can \ndo with SBB and sign-extending to get the value of a logical comparison \nwithout branching (search for &quot;SBB trick&quot;).\n\nBut this is getting into the realms of the obsessive :)\n\n         Ian Badcoe\n\n\n\nLiving@Home - Open Source Evolving Organisms - \nhttp://livingathome.sourceforge.net/\n\n\n\n\n"}}