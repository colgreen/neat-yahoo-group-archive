{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":54567749,"authorName":"Kenneth Stanley","from":"&quot;Kenneth Stanley&quot; &lt;kstanley@...&gt;","profile":"kenstanley01","replyTo":"LIST","senderId":"15O7iaJ8ap1GFXO5txsjehBBzCq6Bf8GvDXOXyQN6S39Y6XSAvD3solvASL_nXZOhyqi6gBE6ulnajIWIG5PxsOmvSRFybmqSphJNWpBtS8A","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: Basic Implementation Question","postDate":"1085429871","msgId":831,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGM4dGw5ZitocGhoQGVHcm91cHMuY29tPg==","inReplyToHeader":"PGM4dGNmcys3ZzU5QGVHcm91cHMuY29tPg=="},"prevInTopic":830,"nextInTopic":832,"prevInTime":830,"nextInTime":832,"topicId":829,"numMessagesInTopic":15,"msgSnippet":"... split. ... always ... innovation ... run. ... innovation ... Yes that s right, mine is like yours (Derek and Philip s) implementation except it only keeps","rawEmail":"Return-Path: &lt;kstanley@...&gt;\r\nX-Sender: kstanley@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 94232 invoked from network); 24 May 2004 20:18:11 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m22.grp.scd.yahoo.com with QMQP; 24 May 2004 20:18:11 -0000\r\nReceived: from unknown (HELO n11.grp.scd.yahoo.com) (66.218.66.66)\n  by mta3.grp.scd.yahoo.com with SMTP; 24 May 2004 20:18:11 -0000\r\nReceived: from [66.218.67.191] by n11.grp.scd.yahoo.com with NNFMP; 24 May 2004 20:17:54 -0000\r\nDate: Mon, 24 May 2004 20:17:51 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;c8tl9f+hphh@...&gt;\r\nIn-Reply-To: &lt;c8tcfs+7g59@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 2342\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-eGroups-Remote-IP: 66.218.66.66\r\nFrom: &quot;Kenneth Stanley&quot; &lt;kstanley@...&gt;\r\nSubject: Re: Basic Implementation Question\r\nX-Yahoo-Group-Post: member; u=54567749\r\nX-Yahoo-Profile: kenstanley01\r\n\r\n--- In neat@yahoogroups.com, &quot;Philip Tucker&quot; &lt;ptucker@g...&gt; wrote:\n&gt; &gt; G2 and G3 are created as mutations off of G1.  \n&gt; &gt; Do the 4-&gt;3 connections get the same innovation\n&gt; &gt; number?\n&gt; &gt;\n&gt; &gt; If not, should node additions be incremented globally,\n&gt; &gt; or at least be tracked by what connection they split \n&gt; &gt; as opposed to what new connections they create? \n&gt; \n&gt; In our implementation, we tracked it by what connection they \nsplit.  \n&gt; We track and re-use innovation IDs in 2 ways:\n&gt; \n&gt; 1) Connections between 2 neurons with the same innovation IDs \nalways \n&gt; get the same innovation ID.  Thus, if a connection evolves between \n&gt; nodes 3 and 4 in generation 25 and again in generation 50, those \n&gt; connection will have the same innovation ID.\n&gt; \n&gt; 2) Nodes created by replacing a connection with the same \ninnovation \n&gt; ID always receive the same connection ID.\n&gt; \n&gt; Unless I&#39;m mistaken Ken&#39;s implementation does something similar to \n&gt; this, but the scope is only a single generation not the entire \nrun.  \n&gt; So, in my #1 example, those connections wuld get different \ninnovation \n&gt; IDs, but another connection mutated between nodes 3 and 4 in \n&gt; generation 25 would get the same ID.\n\nYes that&#39;s right, mine is like yours (Derek and Philip&#39;s) \nimplementation except it only keeps around information on previous \ninnovations for 1 generation.\n\nHowever, there&#39;s one other thing about Karl&#39;s example that should be \nnoted.  He shows the same node id (4) being assigned to splits of \ntwo different connections.  That would never happen in any \nimplementation of NEAT.  The only way two new pieces of structure \ncan ever get the same id is if they are the same innovation.  So in \nother words, the node_id counter is *also* global and works just \nlike the connection id counter.  That is, every time a *new* node \n(i.e., splitting a link that wasn&#39;t split before) is added, the \ncounter is incremented and its value is assigned as the new node id.\n\nAs Philip said, in my version of NEAT, what&#39;s &quot;new&quot; is only kept \ntrack of within a single generation, but in their implementation \nit&#39;s kept track of forever.  The NEAT FAQ addresses the question of \nhow long to keep track of innovations:\n\nSee &quot;Should a record of innovations be kept around forever, or only \nfor the current generation&quot; at:\n\nhttp://www.cs.utexas.edu/users/kstanley/neat.html\n\nken\n\n\n"}}