{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":82117382,"authorName":"Jim O&#39;Flaherty, Jr.","from":"&quot;Jim O&#39;Flaherty, Jr.&quot; &lt;jim_oflaherty_jr@...&gt;","profile":"jim_oflaherty_jr","replyTo":"LIST","senderId":"ILoo_ehBNskinWXtrL1LxRWQ8JY1OtoRSA184mU6RRQLu2O6-8fSYnJlqylGgsp1oFFV57ALzxijTEqI-OzPwhbtp1e5rw-w_NwDJbuPByK2qdf28BsVsnM","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Re: Introduction---recurrency question","postDate":"1125525448","msgId":2226,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIwMDUwODMxMjE1NzI4LjY2OTA4LnFtYWlsQHdlYjUyODEyLm1haWwueWFob28uY29tPg==","inReplyToHeader":"PGRmNTBrcStlMTFyQGVHcm91cHMuY29tPg=="},"prevInTopic":2225,"nextInTopic":2227,"prevInTime":2225,"nextInTime":2227,"topicId":2209,"numMessagesInTopic":42,"msgSnippet":"Matt and John, There is a way to make *firing order* in an ANN always deterministic.  In Semiann (http://sourceforge.net/projects/semiann - Java based), each","rawEmail":"Return-Path: &lt;jim_oflaherty_jr@...&gt;\r\nX-Sender: jim_oflaherty_jr@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 11764 invoked from network); 31 Aug 2005 21:57:29 -0000\r\nReceived: from unknown (66.218.66.166)\n  by m29.grp.scd.yahoo.com with QMQP; 31 Aug 2005 21:57:29 -0000\r\nReceived: from unknown (HELO web52812.mail.yahoo.com) (206.190.49.1)\n  by mta5.grp.scd.yahoo.com with SMTP; 31 Aug 2005 21:57:29 -0000\r\nReceived: (qmail 66910 invoked by uid 60001); 31 Aug 2005 21:57:28 -0000\r\nMessage-ID: &lt;20050831215728.66908.qmail@...&gt;\r\nReceived: from [67.187.121.107] by web52812.mail.yahoo.com via HTTP; Wed, 31 Aug 2005 14:57:28 PDT\r\nDate: Wed, 31 Aug 2005 14:57:28 -0700 (PDT)\r\nTo: neat@yahoogroups.com\r\nIn-Reply-To: &lt;df50kq+e11r@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=iso-8859-1\r\nContent-Transfer-Encoding: 8bit\r\nX-eGroups-Msg-Info: 1:12:0:0\r\nFrom: &quot;Jim O&#39;Flaherty, Jr.&quot; &lt;jim_oflaherty_jr@...&gt;\r\nSubject: Re: [neat] Re: Introduction---recurrency question\r\nX-Yahoo-Group-Post: member; u=82117382; y=jxtXDK7OrdR9XmSAXYTKf7-u8txUsi1t-WAsV-YNIJBhxOBjhuiO38rLHg\r\nX-Yahoo-Profile: jim_oflaherty_jr\r\n\r\nMatt and John,\n\nThere is a way to make *firing order* in an ANN always deterministic.  In Semiann\n(http://sourceforge.net/projects/semiann - Java based), each Node (axon) and Connection (dendrite)\nhas an identity (id) and activation order priority (activation priority).\n\nDuring the construction of a Graph (the network topology only, not activation or weight values),\nthe client determines which Nodes and Connections have priority.  This priority is then used in\nrelated structures to ensure indentical &quot;firing&quot; order occurs each time the network is activated.\n\nThere are plenty of details in the .zip file&#39;s readme.txt and faq.txt.  Additionally, you can\nnavigate around the HTML based JavaDocs to see the interfaces, classes and implementation details.\n\nOne of the benefits of this design is that it is possible to design the use of Semiann such that\nnew nodes and connections can be inserted ANYWHERE in the firing order, not just appended. \nInstance identity is separated from activation priority/order.  Another benefit is that when\nrecurrancy is enabled, an optional &quot;undo/redo&quot; interface can be accessed allowing the client to\nstep forward/backward in &quot;activation pass time&quot;.\n\nI thought it might be use for you to understand the implementation of this design as it might help\nyou through your building your ANN.  I have been following this list for quite some time,\ncollecting &quot;needs&quot; before architecting, designing and building Semiann.  Don&#39;t hesitate to borrow\nanything you find interesting or desirable.\n\n\nJim\n\n\n--- maitrikaruna &lt;kevin@...&gt; wrote:\n\n&gt; John,\n&gt; \n&gt; thanks for the reply...wish we were all at a whiteboard together in \n&gt; which case we could come up with an elegant solution rather \n&gt; quickly...\n&gt; \n&gt; I understand all that you said, but it still creates problems.  The \n&gt; idea of recurrency is that it stores a memory that allows the net to \n&gt; anticipate and strategize based on a prior world state. \n&gt; \n&gt; Suppose I follow your idea of activating the net in several steps, \n&gt; moving my agent in those time steps if the net says to do it, but \n&gt; not checking the new world state.  \n&gt; \n&gt; After these several timesteps, I assume I should re-initialize the \n&gt; inputs to all the neurons to zero.  Then I re-scan the &quot;world&quot;, get \n&gt; my inputs, and do it all again.  But this resetting and rescanning \n&gt; implies no memory of a prior world state since in our internal \n&gt; timesteps we did not consider the world inputs again until we were \n&gt; done with our net activation.  Does this make sense?  \n&gt; \n&gt; I have come up with my own way to handle this and I&#39;m coding it \n&gt; as we speak.  Following is what I propose:\n&gt; \n&gt; 1) I do exactly what John suggested, I have a nice and tight\n&gt; recursive routine that quickly determines dependencies, which \n&gt; includes recursive dependencies\n&gt; \n&gt; 2) I then activate each neuron that has all its depedencies \n&gt; fulfilled/processed iteratively, unitl ALL neurons have been \n&gt; processed.  I also process recurrent links here, BUT if it is\n&gt; timestep 0, i store the recurrent value in its own place separate \n&gt; from the neurons non-recurrent, total inputs.  Importantly, at \n&gt; timestep 0 these recurrent weights are NOT considered in the \n&gt; firing/non-firing decision of the neuron.\n&gt; \n&gt; 3) if the output neurons tell the agent to move, it does so.\n&gt; \n&gt; 4) reset ALL the neurons...BUT, if its not timestep 0, then keep the \n&gt; recurrent totals in the neurons that had a recurrent link back to \n&gt; them..otherwise erset all neurons totals including recurrent totals\n&gt; \n&gt; 5) get the new state of the world..meaning read the input values..\n&gt; \n&gt; 6) process the net as above...if it is not timestep 0, then when \n&gt; making a fire/not-fire decision, we total the inputs for a neuron\n&gt; PLUS the recurrent values from the last net execution....so this is \n&gt; the memory of the prior state being used.\n&gt; \n&gt; 7) repeat all the above...\n&gt; \n&gt; This seems like a practical approach to me that should work, \n&gt; although I haven&#39;t got it working yet.. The code to fire the \n&gt; network, even knowing dependencies, is a little tricky.\n&gt; \n&gt; Hope this all makes some sense...hard to describe via written note...\n&gt; \n&gt; --Kevin\n&gt; \n&gt; \n&gt; \n&gt; \n&gt; \n&gt; \n&gt; \n&gt; \n\n\n\n"}}