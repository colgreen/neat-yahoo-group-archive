{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":344770313,"authorName":"Colin Green","from":"Colin Green &lt;colin.green1@...&gt;","profile":"alienseedpod","replyTo":"LIST","senderId":"ovGA87kxaULwKi6KHaf7-1ZNd_YuGgznwdQgIDbojjCWwvZrv0l60Pv-sEzlQQ_75rfipOaYGBHmn56N8ZMsnk93xMTUeqsKq-xkyycW2dc","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Evolving feedforward networks","postDate":"1260826614","msgId":5013,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDcyN2E0MDZjMDkxMjE0MTMzNnYyZWUxOTA3MGo0YzczM2MyMjM4ZGNhMWE0QG1haWwuZ21haWwuY29tPg=="},"prevInTopic":0,"nextInTopic":5014,"prevInTime":5012,"nextInTime":5014,"topicId":5013,"numMessagesInTopic":14,"msgSnippet":"Hi, Ken s response to Daniel Tuohy s yesterday briefly touched on evolution of feedforward-only networks and this is somethign I ve been meaning to think about","rawEmail":"Return-Path: &lt;colin.green1@...&gt;\r\nX-Sender: colin.green1@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 13403 invoked from network); 14 Dec 2009 21:36:57 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m4.grp.sp2.yahoo.com with QMQP; 14 Dec 2009 21:36:57 -0000\r\nX-Received: from unknown (HELO mail-yx0-f176.google.com) (209.85.210.176)\n  by mta3.grp.sp2.yahoo.com with SMTP; 14 Dec 2009 21:36:56 -0000\r\nX-Received: by yxe6 with SMTP id 6so3247373yxe.13\n        for &lt;neat@yahoogroups.com&gt;; Mon, 14 Dec 2009 13:36:56 -0800 (PST)\r\nMIME-Version: 1.0\r\nX-Received: by 10.91.160.34 with SMTP id m34mr3127312ago.68.1260826614905; Mon, \n\t14 Dec 2009 13:36:54 -0800 (PST)\r\nDate: Mon, 14 Dec 2009 21:36:54 +0000\r\nMessage-ID: &lt;727a406c0912141336v2ee19070j4c733c2238dca1a4@...&gt;\r\nTo: neat@yahoogroups.com\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Colin Green &lt;colin.green1@...&gt;\r\nSubject: Evolving feedforward networks\r\nX-Yahoo-Group-Post: member; u=344770313; y=osD9OeisZCWrawB1ExzwgmHhxANxtvv2XVemEjHxw4gBHbGlUyTJ\r\nX-Yahoo-Profile: alienseedpod\r\n\r\nHi,\n\nKen&#39;s response to Daniel Tuohy&#39;s yesterday briefly touched on\nevolution of feedforward-only networks and this is somethign I&#39;ve been\nmeaning to think about for some time. My initial thoughts on how to do\nthis relatively efficiently are as follows:\n\n1) Start out with a feedforward only graph (e.g. the typical NEAT\ninitial population with conenctions from inputs to outputs).\n2) We initialise each node with a list of all the nodes that are above\nit in the graph, let&#39;s call this the &#39;ancestor&#39; list (A-list or A-node\nlist for short)\n3) With recursive networks, in order to add a connection we typically\nrandomly search pairs of source and target node IDs until we find a\npair that does not exist in the existign connection genes. Now we can\nadd the additional test that the target node ID is not in the source\nnode&#39;s A-list. This eliminates the need to traverse the network,\neffectively recalculating each node&#39;s A-List each time.\n4) When we create a new node by splitting a conenction, the new node\ncreates it&#39;s own A-list by takign a copy the source node&#39;s A-List plus\nthe source node&#39;s ID.\n\nThe A-lists can become part of the genome so that we never have to\ntraverse networks to rebuild A-lists, they just get copied when we\ncreate offspring genomes/networks. Ok so now you&#39;re all thinking that\nthe memory requirements for this could get unwieldy. We can reduce\nmemory requirements by using bitmaps where each node ID get&#39;s it&#39;s own\nlocation in an array of bits, thus if the IDs are 32bit integers we\nget a 32x reduction in storage space requirements. As a bonus, testing\nif a node is in a given A-list should be almost intantaneous, versus\nthe O(log n) time complexity of a binary search against a sorted list\nof integer IDs.\n\nThe first problem I see is that the set of innovation IDs currently in\nuse in a given population becomes patchy, e.g. some early IDs may\nsimply not exist any more (although I&#39;m not 100% if this happens in\nreality). So lets say NEAT has been running a while and the innovation\nID variable is up to 100,000. Each node requires its own bit in each\nA-list regardless of whether it is set or not, therefore the A-lists\nare 100000/8 = 12,500 bytes in size (I&#39;m assuming the A-lists grow\nover time, along with the innovation ID counter). We can however\nreduce this memory requirement by periodically stoppign NEAT and\ndefragmenting the ID space, this allows us to reuse the low IDs that\nare no longer in use anymore (no node anywhere in the population uses\nit) and thus the size of the A-list only needs to refelct the number\nof /active/ node IDs rather than the number of IDs there has ever\nbeen.\n\nThinking ahead to distributed-NEAT algorithms this potentially creates\na new problem when/if we need to pass genome between clusteres - the\nnode IDs of like nodes no longer match up. The proposed solution there\nis to have a periodic system wide defragmentation take place\nencompassing all nodes, or alternatively each distribution node\nmaintains a mapping between &#39;global&#39; innovation IDs and the local\ndefragmented IDs.\n\nI&#39;d be interested hear other&#39;s ideas on this topic. Perhaps there&#39;s\nsome more elegant approach using clever allocation of IDs to indicate\nwhere a node lies in the network of ancestors, e.g. if node IDs are\ntaken to be a height measured from top to bottom of the network, we\ncan assign and modify node IDs so that we can simply compare two IDs\nto see their relative position in the top-down graph - the problem\nthere being that we can no longer use the IDs as innovation numbers;\nHowever we could simply use two variables - innovation ID and a\nheight/position. One downside there is that only one node can occupy a\ngiven height and since the number of height levels is limits (e.g. to\n2^32 for a 32 bit variable) the number of nodes in a network is\nlimited, on the other hand that&#39;s potentially a very high limit.\nPerhaps the tricky part is decidign what to do when mating two\nnetworks.\n\nThis post is already too long so I&#39;m going to stop :)\n\nColin\n\n"}}