{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":206967455,"authorName":"Julian Togelius","from":"&quot;Julian Togelius&quot; &lt;julian@...&gt;","profile":"jtogel","replyTo":"LIST","senderId":"cXlfLkKRQHKJ95qq4DeVASb-Xh2Utnk6PNpog40oQc9DlUzkuHB6uGYdaqEBYOf4rmr7Hokv9TlZeQUISaUOUVOSduWnmL4ZvNGfS8Lh","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Pole Balancing","postDate":"1227634746","msgId":4486,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDIzMGU0NjNlMDgxMTI1MDkzOXEzYTgxNDMyOXQ1YjFkZGRmOGMzZDg3ZTdlQG1haWwuZ21haWwuY29tPg==","inReplyToHeader":"PGdnZ2hyZitwcXRiQGVHcm91cHMuY29tPg==","referencesHeader":"PGdmbTUxNCtxZmZiQGVHcm91cHMuY29tPiA8Z2dnaHJmK3BxdGJAZUdyb3Vwcy5jb20+"},"prevInTopic":4485,"nextInTopic":4488,"prevInTime":4485,"nextInTime":4487,"topicId":4459,"numMessagesInTopic":18,"msgSnippet":"I don t think Yahoo Groups allows attachments, so here goes. In your loop, just call setupInput () to get the input values for your network, then use","rawEmail":"Return-Path: &lt;julian.togelius@...&gt;\r\nX-Sender: julian.togelius@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 23148 invoked from network); 25 Nov 2008 17:39:07 -0000\r\nX-Received: from unknown (66.218.67.97)\n  by m52.grp.scd.yahoo.com with QMQP; 25 Nov 2008 17:39:07 -0000\r\nX-Received: from unknown (HELO rv-out-0708.google.com) (209.85.198.246)\n  by mta18.grp.scd.yahoo.com with SMTP; 25 Nov 2008 17:39:07 -0000\r\nX-Received: by rv-out-0708.google.com with SMTP id b17so50110rvf.44\n        for &lt;neat@yahoogroups.com&gt;; Tue, 25 Nov 2008 09:39:07 -0800 (PST)\r\nX-Received: by 10.140.202.21 with SMTP id z21mr2493868rvf.260.1227634746942;\n        Tue, 25 Nov 2008 09:39:06 -0800 (PST)\r\nX-Received: by 10.141.122.2 with HTTP; Tue, 25 Nov 2008 09:39:06 -0800 (PST)\r\nMessage-ID: &lt;230e463e0811250939q3a814329t5b1dddf8c3d87e7e@...&gt;\r\nDate: Tue, 25 Nov 2008 18:39:06 +0100\r\nTo: neat@yahoogroups.com\r\nIn-Reply-To: &lt;ggghrf+pqtb@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\nContent-Disposition: inline\r\nReferences: &lt;gfm514+qffb@...&gt; &lt;ggghrf+pqtb@...&gt;\r\nX-Google-Sender-Auth: f211833ea8e3413f\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: &quot;Julian Togelius&quot; &lt;julian@...&gt;\r\nSubject: Re: [neat] Pole Balancing\r\nX-Yahoo-Group-Post: member; u=206967455; y=GIiae8_1cKpujD-L3qVVTRsid4e6ekjEuJaM1sg6q3-W\r\nX-Yahoo-Profile: jtogel\r\n\r\nI don&#39;t think Yahoo Groups allows attachments, so here goes.\nIn your loop, just call setupInput () to get the input values for your\nnetwork, then use performAction () with the output of your network as\nargument.\n\n-----------------------------------------------------------------------------------\npackage benchmarks.polebalancing;\n\n//////////////////////////////////////////////////////////////////////\n//   Alan Oursland\n//\n//   ESP Java implementation.\n//\n//\t This code is a direct port of Faustino Gomez&#39;s ESP code\n//   that was code started from Daniel Polani&#39;s translation of\n//   Dave Moriarty&#39;s original SANE code from C to C++.\n//\n//   $Log: DoublePole.java,v $\n//\n//   Minor modifications by Julian Togelius in order to interface it with the\n//   the Essex machinelearning framework\n//\n\n//////////////////////////////////////////////////////////////////////////\npublic class DoublePole implements Pole {\n    public static final double MUP = 0.000002;\n    public static final double MUC = 0.0005;\n    public static final double GRAVITY = -9.8;\n    public static final double MASSCART = 1.0;\n    public static final double MASSPOLE_1 = 0.1;\n    public static double MASSPOLE_2 = 0.01;\n    public static final double LENGTH_1 = 0.5;          /* actually\nhalf the pole&#39;s length */\n    public static double LENGTH_2 = 0.05;\n    public static final double FORCE_MAG = 10.0;\n    public static final double TAU = 0.01;          //seconds between\nstate updates\n\n    public static final double one_degree = 0.0174532;    /* 2pi/360 */\n    public static final double six_degrees = 0.1047192;\n    public static final double twelve_degrees = 0.2094384;\n    public static final double fifteen_degrees = 0.2617993;\n    public static final double thirty_six_degrees = 0.628329;\n    public static final double fifty_degrees = 0.87266;\n\n    public static final double CART_LIMIT = 2.4;\n    //public static final boolean MARKOV = false; // markov (full\nstate) of non-markov (no-velocities).\n\n    private static final int inputSize = 7;\n    private static final int outputSize = 1;\n    private static final double maxFitness = 1000;\n    private static final boolean RK4 = true;\n    private static final double EULER_TAU = (TAU / 4);\n\n    public static final double MIN_INC = 0.001;\n    private double state[] = new double[6];\n    private double POLE_INC = 0.05;\n    private double MASS_INC = 0.01;\n    private boolean first_time = true;\n\n    final double failureAngle = thirty_six_degrees;\n\n    public DoublePole() {\n        init();\n    }\n\n    public double[] getLenghts() {\n        return new double[]{LENGTH_1 * 2, LENGTH_2 * 2};\n    }\n\n    public double[] getPoleLimits() {\n        return new double[]{failureAngle, failureAngle};\n    }\n\n    public double getCartLimit() {\n        return CART_LIMIT;\n    }\n\n    public void init() {\n        /*if (randomize) {\n              state[0] = (lrand48()%4800)/1000.0 - 2.4;\n              state[1] = (lrand48()%2000)/1000.0 - 1;\n              state[2] = (lrand48()%400)/1000.0 - 0.2;\n              state[3] = (lrand48()%400)/1000.0 - 0.2;\n              state[4] = (lrand48()%3000)/1000.0 - 1.5;\n              state[5] = (lrand48()%3000)/1000.0 - 1.5;\n          }\n          else {*/\n        state[0] = state[1] = state[3] = state[4] = state[5] = 0;\n        state[2] = 0.07; // one_degree;\n        //}\n        if (first_time) {\n            System.out.println(&quot;Initial Long pole angle = &quot; + state[2]);\n            System.out.println(&quot;Initial Short pole length = &quot; + LENGTH_2);\n            first_time = false;\n        }\n    }\n\n\n    private static final double ML_1 = LENGTH_1 * MASSPOLE_1;\n    private static double ML_2 = LENGTH_2 * MASSPOLE_2;\n\n    void step(double action, double[] st, double[] derivs) {\n        double force = (action - 0.5) * FORCE_MAG * 2;\n        double costheta_1 = Math.cos(st[2]);\n        double sintheta_1 = Math.sin(st[2]);\n        double gsintheta_1 = GRAVITY * sintheta_1;\n        double costheta_2 = Math.cos(st[4]);\n        double sintheta_2 = Math.sin(st[4]);\n        double gsintheta_2 = GRAVITY * sintheta_2;\n\n        double temp_1 = MUP * st[3] / ML_1;\n        double temp_2 = MUP * st[5] / ML_2;\n        double fi_1 = (ML_1 * st[3] * st[3] * sintheta_1) + (0.75 *\nMASSPOLE_1 * costheta_1 * (temp_1 + gsintheta_1));\n        double fi_2 = (ML_2 * st[5] * st[5] * sintheta_2) + (0.75 *\nMASSPOLE_2 * costheta_2 * (temp_2 + gsintheta_2));\n        double mi_1 = MASSPOLE_1 * (1 - (0.75 * Math.pow(costheta_1, 2)));\n        double mi_2 = MASSPOLE_2 * (1 - (0.75 * Math.pow(costheta_2, 2)));\n\n\n        derivs[1] = (force + fi_1 + fi_2) / (mi_1 + mi_2 + MASSCART);\n\n        derivs[3] = -0.75 * (derivs[1] * costheta_1 + gsintheta_1 +\ntemp_1) / LENGTH_1;\n        derivs[5] = -0.75 * (derivs[1] * costheta_2 + gsintheta_2 +\ntemp_2) / LENGTH_2;\n    }\n\n    void performAction(double[] output) {\n        int i;\n        double[] dydx = new double[6];\n\n        /*random start state for long pole*/\n        /*state[2]= drand48();   */\n\n        /*--- Apply action to the simulated cart-pole ---*/\n\n        if (RK4) {\n            for (i = 0; i &lt; 2; ++i) {\n                dydx[0] = state[1];\n                dydx[2] = state[3];\n                dydx[4] = state[5];\n                step(output[0], state, dydx);\n                rk4(output[0], state, dydx, state);\n            }\n        } else {\n            for (i = 0; i &lt; 8; ++i) {\n                step(output[0], state, dydx);\n                state[0] += EULER_TAU * dydx[0];\n                state[1] += EULER_TAU * dydx[1];\n                state[2] += EULER_TAU * dydx[2];\n                state[3] += EULER_TAU * dydx[3];\n                state[4] += EULER_TAU * dydx[4];\n                state[5] += EULER_TAU * dydx[5];\n            }\n        }\n    }\n\n    void rk4(double f, double[] y, double[] dydx, double[] yout) {\n        int i;\n\n        double hh;\n        double h6;\n        double[] dym = new double[6];\n        double[] dyt = new double[6];\n        double[] yt = new double[6];\n\n\n        hh = TAU * 0.5;\n        h6 = TAU / 6.0;\n        for (i = 0; i &lt;= 5; i++) yt[i] = y[i] + hh * dydx[i];\n        step(f, yt, dyt);\n        dyt[0] = yt[1];\n        dyt[2] = yt[3];\n        dyt[4] = yt[5];\n        for (i = 0; i &lt;= 5; i++) yt[i] = y[i] + hh * dyt[i];\n        step(f, yt, dym);\n        dym[0] = yt[1];\n        dym[2] = yt[3];\n        dym[4] = yt[5];\n        for (i = 0; i &lt;= 5; i++) {\n            yt[i] = y[i] + TAU * dym[i];\n            dym[i] += dyt[i];\n        }\n        step(f, yt, dyt);\n        dyt[0] = yt[1];\n        dyt[2] = yt[3];\n        dyt[4] = yt[5];\n        for (i = 0; i &lt;= 5; i++)\n            yout[i] = y[i] + h6 * (dydx[i] + dyt[i] + 2.0 * dym[i]);\n    }\n\n    boolean outsideBounds() {\n\n        return\n                state[0] &lt; -CART_LIMIT ||\n                        state[0] &gt; CART_LIMIT ||\n                        state[2] &lt; -failureAngle ||\n                        state[2] &gt; failureAngle ||\n                        state[4] &lt; -failureAngle ||\n                        state[4] &gt; failureAngle;\n    }\n\n    public void nextTask() {\n        LENGTH_2 += POLE_INC;   /* LENGTH_2 * INCREASE;   */\n        MASSPOLE_2 += MASS_INC; /* MASSPOLE_2 * INCREASE; */\n        ML_2 = LENGTH_2 * MASSPOLE_2;\n        //  ++new_task;\n        System.out.println(&quot;#Pole Length &quot; + LENGTH_2);\n    }\n\n    public void simplifyTask() {\n        if (POLE_INC &gt; MIN_INC) {\n            POLE_INC = POLE_INC / 2;\n            MASS_INC = MASS_INC / 2;\n            LENGTH_2 -= POLE_INC;\n            MASSPOLE_2 -= MASS_INC;\n            ML_2 = LENGTH_2 * MASSPOLE_2;\n            System.out.println(&quot;#SIMPLIFY&quot;);\n            System.out.println(&quot;#Pole Length &quot; + LENGTH_2);\n        } else {\n            System.out.println(&quot;#NO TASK CHANGE&quot;);\n        }\n    }\n\n    public int getInputSize() {\n        return inputSize;\n    }\n\n    public int getOutputSize() {\n        return outputSize;\n    }\n\n    public double getMaxFitness() {\n        return maxFitness;\n    }\n\n    public void setupInput(double[] input, boolean markov) {\n        if (markov) {\n            input[0] = state[0] / 4.8;\n            input[1] = state[1] / 2;\n            input[2] = state[2] / 0.52;\n            input[3] = state[3] / 2;\n            input[4] = state[4] / 0.52;\n            input[5] = state[5] / 2;\n            input[6] = .5;\n        } else {\n            input[0] = state[0] / 4.8;\n            //input[1] = 0.0;\n            input[1] = state[2] / 0.52;\n            //input[3] = 0.0;\n            input[2] = state[4] / 0.52;\n            //input[5] = 0.0;\n            input[3] = .5;\n\n        }\n    }\n\n    public double[] getState() {\n        return state;\n    }\n\n}\n\n2008/11/25 matthias.linhardt &lt;faulerlennert@...&gt;:\n&gt; Hello everyone!\n&gt;\n&gt; As I&#39;m currently stuck with my 2-degrees-of-freedom arm and running\n&gt; out of good ideas, I thought it might be helpful to analyze\n&gt; different, well-established experiments in order to gain new\n&gt; perspectives and maybe find out, why other people&#39;s experiments work\n&gt; so well in contrast to mine. Pole Balancing (which I know is included\n&gt; with C+ NEAT) would be a great start for me, but shame on me, I don&#39;t\n&gt; know C+, only Java and therefore am using Ugo&#39;s JNEAT. That&#39;s when\n&gt; you guys come into play. ;-)\n&gt; I hope some of you already tried single- or double pole balancing\n&gt; with Java, so my question is the following: Would someone be so kind\n&gt; to give me the code / let me try out his pole balancing experiment?\n&gt;\n&gt; To make this clear, I don&#39;t want to steal your work or something, I\n&gt; just want to better get to know NEAT and understand what I am doing\n&gt; wrong in my own experiments.\n&gt; Your help would be very much appreciated!\n&gt;\n&gt; Thanks a lot!\n&gt; Matthias\n&gt;\n&gt; \n\n\n\n-- \nJulian Togelius\nIDSIA\nGalleria 2\n6928 Manno-Lugano\nSwitzerland\njulian@...\nhttp://julian.togelius.com\nhttp://www.idsia.ch/~togelius\n+41-764-110679\n+46-705-192088\n\n"}}