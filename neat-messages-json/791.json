{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":7192225,"authorName":"Ian Badcoe","from":"Ian Badcoe &lt;ian_badcoe@...&gt;","profile":"ian_badcoe","replyTo":"LIST","senderId":"wjxv_jTSS4ecPhtP0Cph-J35DofYUnWaDH6JkmJAiCdvC1fItX4ABDMkzcsvt0-zt8A-OAHp6I8bHaoSUk6MJQgCrt2gjLnRwl0","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [neat] differentiation","postDate":"1084811901","msgId":791,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDYuMS4wLjYuMC4yMDA0MDUxNzE3MzYxOS4wMjUxYWYyOEBwb3AubWFpbC55YWhvby5jby51az4="},"prevInTopic":773,"nextInTopic":0,"prevInTime":790,"nextInTime":792,"topicId":745,"numMessagesInTopic":9,"msgSnippet":"... Right, I guess I phrased it that way because it seemed simpler.  But actually there are two closely related ideas here: 1) add inputs with a similar","rawEmail":"Return-Path: &lt;ian_badcoe@...&gt;\r\nX-Sender: ian_badcoe@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 44052 invoked from network); 17 May 2004 16:39:40 -0000\r\nReceived: from unknown (66.218.66.166)\n  by m23.grp.scd.yahoo.com with QMQP; 17 May 2004 16:39:40 -0000\r\nReceived: from unknown (HELO smtp005.mail.ukl.yahoo.com) (217.12.11.36)\n  by mta5.grp.scd.yahoo.com with SMTP; 17 May 2004 16:39:39 -0000\r\nReceived: from unknown (HELO ian2k.yahoo.co.uk) (ian?badcoe@212.159.73.108 with login)\n  by smtp005.mail.ukl.yahoo.com with SMTP; 17 May 2004 16:37:34 -0000\r\nMessage-Id: &lt;6.1.0.6.0.20040517173619.0251af28@...&gt;\r\nX-Sender: ian_badcoe@...\r\nX-Mailer: QUALCOMM Windows Eudora Version 6.1.0.6\r\nDate: Mon, 17 May 2004 17:38:21 +0100\r\nTo: neat@yahoogroups.com\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;us-ascii&quot;; format=flowed\r\nX-eGroups-Remote-IP: 217.12.11.36\r\nFrom: Ian Badcoe &lt;ian_badcoe@...&gt;\r\nSubject: Re: [neat] differentiation\r\nX-Yahoo-Group-Post: member; u=7192225\r\nX-Yahoo-Profile: ian_badcoe\r\n\r\nAt 00:21 13/05/2004, you wrote:\n&gt;Ion,\n&gt;I suppose that was one take one the question, but I didn&#39;t infer that the \n&gt;*meaning* of any inputs would change,\n\nRight, I guess I phrased it that way because it seemed simpler.  But \nactually there are two closely related ideas here:\n\n1) add inputs with a &quot;similar&quot; nature to some existing input and try to \nleverage existing paths from the existing one to jump start the new ones \n(e.g. if we consider intensity to be similar to red, green and blue)\n\n2) add inputs with &quot;identical&quot; nature to an existing input and try to clone \nthe relevant subset of the existing net (e.g. if we started with just red \nand then cloned some nodes and connections in an attempt to incorporate \ngreen and blue).\n\n-----\n\nI&#39;ve quite a lot of ideas on this area but as yet they form an amorphous \nand non-navigable mess, so I&#39;ll try to just skim the surface here and we \ncan get into what I actually mean if you like the sound of any of \nit.  So... sound bite format:\n\n1) this is not purely an NEAT issue, other ANN approaches can consider it \nand so can other evolving SW techniques (GP, GA...) and so, ultimately \ncould any learning technique...\n\n2) I&#39;m trying to formalize &quot;evolving agent frameworks&quot; which are systems \nthat include evolving core (such as NEAT, GP, ...).  I define them in terms \nof various desirable properties, one of which would be this one we&#39;re \ndiscussing, which we might loosely term &quot;exploiting \nsymmetries/classification of input data over multiple test problems&quot;\n\n2a) generally I assume that an agent will need multiple evolving \ncomponents, call them genes, to enable it to handle a variety of input \nproblems (that&#39;s another desirable property: &quot;learn a new task without \nimmediately forgetting previous learning&quot;).  This would equate to mutiple, \nseparately evolving ANN networks (or GP programs...).  Obviously this moves \na away from normal NEAT methodology.\n\n2b) agents should have higher &quot;evolvability&quot; than their core systems, by \nvirtue of implementing &quot;loose connectivity&quot; between the multiple components \n(see literature on &quot;evolvability&quot;)\n\n3) (to get away from my evolving agent obsession), this is closely related \nto attempts to build modularity into NEAT.  e.g. any modular network will \n(a) be able to process similar inputs with copies of the same module, (b) \nneed to merge outputs from multiple modules, and (c) (to take it to a more \ngeneral case) need to distinguish types of input according to which modules \nmight apply to them.  Obviously one could leave it to naked evolution to \nreconfigure the whole network when the inputs change, but that is \nnecessarily a bigger search space than one which might already have hints \nabout how to treat new inputs\n\n4) one could specify a network in terms of an unknown number of inputs, IF, \none had some symmetry relationships to guide the construction.  Thus, \nsuppose we evolve a network to process just the red channel.  When the \nother two colours are added, we can take it as a principle that r, g and b \nare equivalent, which implies that there is no justification for ever \npassing one of them through any sub-net which is not also mirrored for the \nother two.  E.g. you could implement this with a scheme not so different \nfrom standard NEAT, instead of part of a genome reading &quot;create a node A \nand connect it as follows...&quot; it would read &quot;for every input of type: x \ncreate a node A and connect it...&quot;  And the next part would now read &quot;for \neach node A, create a node B and connect it...&quot; etc etc\n\n4a) (4) permits the duplication of an entire network as new inputs are \nadded, but not the creation of new interactions between the inputs (e.g. if \nwe needed to calculate red - green somewhere) but one merely needs to \ngeneralise the system a little more.  E.g. a &quot;gene&quot; might read &quot;for each \npair of different inputs of type: _colour_ construct a node A and connect \nwith weight (+0.5, -0.5)&quot; -- this would construct six nodes (roughly) \nrepresenting (red - green), (green - red), (red - blue), (blue - red), \n(blue - green) and (green - blue)\n\n4b) and (4a) can readily be seen with enough syntax for variants like:\n         &quot;for each three inputs...&quot;\n         &quot;for each pair of inputs of type (_colour_, _speed_)&quot;\n         &quot;for all inputs of type _colour_ construct one node...&quot;\n         &quot;for each pair of nodes (A, B)&quot;\n         &quot;for each unordered pair of...&quot;\n         &quot;for 10% of all possible quads...&quot;\n\n4c) To summarize, this would allow the genome to specify not a single \nnetwork with a fixed number of inputs, but a whole family of networks each \ntaking a different number of inputs.  To make it make sense, one would need \nto train it on varying input patterns -- because for a single input pattern \na variety of different genomes might happen to make the right network.  But \nthe acid test would be, if you trained it on inputs of size 1, 2, 3 and 4, \nwould it have validity on problems of size 5, 6, 7...\n\n5) Akin to 4, except consider nodes to have constructed types instead of \nunique names, thus ten rules might lead to nodes of type_4, and a single \nfurther rule act on all their outputs\n\n6) Akin to 4, except assume that the dynamic connection by type/name only \nneed occur between &quot;modules&quot; and not for every node.  Saying this another \nway, each rule in 4 would construct a small subnet with it&#39;s inputs bound \nto existing types/names and its outputs labelled with new types/names\n\n         Anyway, this is deliberately very vague talk, but I hope there&#39;s \nenough for you to get the idea.  I&#39;d be very interested in any existing \nwork which touches on this (it&#39;s so hard to know what to search for :).\n\n         Ian B\n\n\n\nLiving@Home - Open Source Evolving Organisms - \nhttp://livingathome.sourceforge.net/\n\n\n\n\n"}}