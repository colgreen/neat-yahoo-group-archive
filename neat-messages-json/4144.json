{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":130984297,"authorName":"joel278","from":"&quot;joel278&quot; &lt;lehman.154@...&gt;","profile":"joel278","replyTo":"LIST","senderId":"lzecbtgEwSnmrQKDClfP5SSsvRSpyQQ_000j_fAjBOetLySuhHYorRxhZhGebRAAhGH3Iu-h-2osdRzO-07MhzuvG110","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: Parallelizing novelty search","postDate":"1213106042","msgId":4144,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGcybTExcStobDk3QGVHcm91cHMuY29tPg==","inReplyToHeader":"PGcybG9oaytrMm5pQGVHcm91cHMuY29tPg=="},"prevInTopic":4142,"nextInTopic":0,"prevInTime":4143,"nextInTime":4145,"topicId":4137,"numMessagesInTopic":4,"msgSnippet":"Hey Peter, I ve been working on an MPI implementation of novelty search, so it is interesting to hear other people s ideas about parallelizing the algorithm. ","rawEmail":"Return-Path: &lt;lehman.154@...&gt;\r\nX-Sender: lehman.154@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 58686 invoked from network); 10 Jun 2008 13:54:02 -0000\r\nX-Received: from unknown (66.218.67.94)\n  by m50.grp.scd.yahoo.com with QMQP; 10 Jun 2008 13:54:02 -0000\r\nX-Received: from unknown (HELO n19a.bullet.scd.yahoo.com) (66.94.237.48)\n  by mta15.grp.scd.yahoo.com with SMTP; 10 Jun 2008 13:54:02 -0000\r\nX-Received: from [66.218.69.4] by n19.bullet.scd.yahoo.com with NNFMP; 10 Jun 2008 13:54:02 -0000\r\nX-Received: from [66.218.66.76] by t4.bullet.scd.yahoo.com with NNFMP; 10 Jun 2008 13:54:02 -0000\r\nDate: Tue, 10 Jun 2008 13:54:02 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;g2m11q+hl97@...&gt;\r\nIn-Reply-To: &lt;g2lohk+k2ni@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;joel278&quot; &lt;lehman.154@...&gt;\r\nSubject: Re: Parallelizing novelty search\r\nX-Yahoo-Group-Post: member; u=130984297; y=6998oJbGYnKg482E7fy28uVZjXisGQjLsmo4v6j9In1R1_JLc-R4\r\nX-Yahoo-Profile: joel278\r\n\r\nHey Peter,\n\nI&#39;ve been working on an MPI implementation of novelty search, s=\r\no it\nis interesting to hear other people&#39;s ideas about parallelizing the\nal=\r\ngorithm. \n\nThe way that we&#39;ve gone is to try not to change the dynamics of =\r\nthe\nalgorithm so that any results we end up with are directly comparable\nto=\r\n a serial run. Thus, we have not tried anything such as your\nanastomosis id=\r\nea, which sounds interesting, but may be complex to\nimplement. \n\nYour anast=\r\nomosis idea sounds to be somewhat similar to an island model\nGA with separa=\r\nte populations that sometimes interact -- this would be \nanother way to go =\r\nfor parallelizing - having a separate population for\neach CPU and having so=\r\nme organisms/species migrate to other CPUs on\na regular basis.\n\nInstead, wh=\r\nat we&#39;ve done is after the initial population is evaluated,\nspawn off a dif=\r\nferent individual for each client computer to be\nevaluated asynchronously. =\r\nThen the algorithm proceeds unchanged from \nthere -- in the main loop, we s=\r\nimply wait for one individual to\nfinish from the client CPUS, remove the wo=\r\nrst, re-estimate averages,\nand spawn off another genome to throw to the CPU=\r\n that just finished,\nand repeat.\n\nJoel\n\n--- In neat@yahoogroups.com, &quot;peter=\r\nberrington&quot; &lt;peterberrington@...&gt;\nwrote:\n&gt;\n&gt; Petar, I understand what you a=\r\nre saying, and indeed you can do it\n&gt; exactly as you described using rtneat=\r\n. I should have clarified, my\n&gt; implementation is not a direct copy of the =\r\nrtneat algorithm; I do not\n&gt; continuously evaluate individuals in my implem=\r\nentation and remove\n&gt; according to eligibility requirements; while that may=\r\n work for a\n&gt; videogame, its not necessary and the search dynamics are pres=\r\nerved so\n&gt; long as you follow the dynamic of removing and adding one indivi=\r\ndual\n&gt; at time. That is all besides the point, I realize I can probably do\n=\r\n&gt; things your way, I was trying to hint at adapting the search itself.\n&gt; \n&gt;=\r\n The point I was making (and why I used the word is anastomosis) is\n&gt; that =\r\nevolutionary search is in many respects like a kind of branching\n&gt; explorat=\r\nion through some parameter-dimensional space. We always like\n&gt; to imagine a=\r\n tree branching out into all the possible points in search\n&gt; space, but it =\r\nis instructive to look at actual phylogenetic networks\n&gt; from biology; beca=\r\nuse of features like lateral gene transfer,\n&gt; recombination, hybridization =\r\nand gene duplication, biological search\n&gt; not only branches but reconverges=\r\n. This is why taxonomic\n&gt; classification of some species is complicated, an=\r\nd hence we use\n&gt; networks (with closed cycles) rather than bifurcating tree=\r\ns for some\n&gt; taxonomic data. \n&gt; \n&gt; I&#39;m getting a little philosophical but m=\r\ny point is, novelty search\n&gt; could probably benefit from a separate level o=\r\nf forced\n&gt; diversification; the fact that it can be done concurrently if yo=\r\nu have\n&gt; multiple cores on your computer or a big cluster of cpus is icing =\r\non\n&gt; the cake.  If you look at a picture of a leaf skeleton or a\n&gt; circulat=\r\nory/venous system you will notice that a vast area is able to\n&gt; be spanned =\r\nby recursively branching out and joining in again; I think\n&gt; this metaphor/=\r\npattern is applicable to search as well because of some\n&gt; inherent properti=\r\nes: for one, a large area is spanned because the root\n&gt; branches are equidi=\r\nstant from each other in space and each spans\n&gt; outward. Secondly, effort i=\r\ns not duplicated because when the branches\n&gt; are full enough to converge on=\r\n each others space, they rejoin. \n&gt; \n&gt; To combine those two properties and =\r\nexploit parallel processing, I\n&gt; think novelty search (all of it, not just =\r\nevaluation) should be done\n&gt; in parallel with regular forced merging of the=\r\n disparate populations.\n&gt; If this can be done nondestructively, all of the =\r\ninformation obtained\n&gt; from each separate search will be unified and used a=\r\ns starting points\n&gt; for the next phase. \n&gt; \n&gt; In effect I feel this will re=\r\nify the anastomosis pattern in search and\n&gt; allow it to cover a VAST amount=\r\n more space (limited by the number of\n&gt; cpus you have and the amount of ove=\r\nrlap in search). \n&gt; \n&gt; --- In neat@yahoogroups.com, &quot;petar_chervenski&quot; &lt;pet=\r\nar_chervenski@&gt;\n&gt; wrote:\n&gt; &gt;\n&gt; &gt; You welcome :) I will upload more stuff wh=\r\nen I have the time. I have \n&gt; &gt; some other interesting projects in mind. No=\r\nw let me tell you about \n&gt; &gt; the parallel/distributed NS. The most CPU reso=\r\nurces are taken by the \n&gt; &gt; evaluation process. In real-time NEAT (which is=\r\n the steady state \n&gt; &gt; evolution) you can evaluate all individuals in the p=\r\nopulation *in the \n&gt; &gt; same time*, not one after another. So this should be=\r\n the way to \n&gt; &gt; parallelize it. And then you replace the worst individual =\r\nevery few \n&gt; &gt; ticks in a separate thread or something. This part of the al=\r\ngorithm \n&gt; &gt; doesn&#39;t take much time. The time spent in NEAT genetic routine=\r\ns is \n&gt; &gt; very small compared to the time spent evaluating the phenotypes. =\r\nOr \n&gt; &gt; at least this is true in most domains. So you should focus on how t=\r\no \n&gt; &gt; evaluate the individuals in parallel, because you only need the \n&gt; &gt;=\r\n fitness scores of the whole population for the NEAT part. Getting \n&gt; &gt; the=\r\nse scores takes most of the time :) \n&gt; &gt; \n&gt; &gt; Peter\n&gt; &gt; \n&gt; &gt; --- In neat@ya=\r\nhoogroups.com, &quot;peterberrington&quot; &lt;peterberrington@&gt; \n&gt; &gt; wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt;=\r\n Thanks a lot to Petar C for his novelty-based nevh, its really \n&gt; &gt; coming=\r\n\n&gt; &gt; &gt; along nicely.\n&gt; &gt; &gt; \n&gt; &gt; &gt; In the past while I have been thinking of=\r\n how to best exploit \n&gt; &gt; parallel\n&gt; &gt; &gt; architecture with novelty search. =\r\n\n&gt; &gt; &gt; I have a pretty good idea of how to do this in general, but the\n&gt; &gt; =\r\n&gt; details need a lot of work and I could use as much help and input \n&gt; &gt; as=\r\n I\n&gt; &gt; &gt; can get.\n&gt; &gt; &gt; \n&gt; &gt; &gt; With generational dynamics its quite easy to=\r\n simply divide the\n&gt; &gt; &gt; population into the number of working processors y=\r\nou have and \n&gt; &gt; perform\n&gt; &gt; &gt; evaluation in parallel, exploiting the extra=\r\n cpu power to do the \n&gt; &gt; most\n&gt; &gt; &gt; cpu intensive part of the NEAT algorit=\r\nhm. \n&gt; &gt; &gt; \n&gt; &gt; &gt; However, since steady state novelty search only modifies =\r\na single\n&gt; &gt; &gt; population member each tick, a different approach is necessa=\r\nry. \n&gt; &gt; &gt; (When I say tick from henceforth I am just referring to the 3 st=\r\neps \n&gt; &gt; of\n&gt; &gt; &gt; remove worst, sort by fitness/species_size, add new \n&gt; &gt; =\r\nprobabilistically).\n&gt; &gt; &gt; \n&gt; &gt; &gt; At first I thought an easy modification to=\r\n implement is this: view \n&gt; &gt; the\n&gt; &gt; &gt; tick() method as a function which t=\r\nakes a population and returns a\n&gt; &gt; &gt; population of the same size, with the=\r\n worst individual replaced with\n&gt; &gt; &gt; an new individual. Simply performing =\r\nn concurrent ticks and \n&gt; &gt; selecting\n&gt; &gt; &gt; the resulting population which =\r\nis the best could then be done, which\n&gt; &gt; &gt; bears some resemblance to the i=\r\ndea of tournament selection.\n&gt; &gt; &gt; \n&gt; &gt; &gt; Thinking on this further though, =\r\nit occurred to me that this is \n&gt; &gt; greedy\n&gt; &gt; &gt; and in a way wasteful/inef=\r\nficient. In some sense you can view \n&gt; &gt; novelty\n&gt; &gt; &gt; search&#39;s tick() meth=\r\nod as not only adding a new individual; it also\n&gt; &gt; &gt; alters the search &quot;fr=\r\nontier&quot;. Since each species has a different \n&gt; &gt; spawn\n&gt; &gt; &gt; probability yo=\r\nu are getting information about which directions in\n&gt; &gt; &gt; search space are =\r\nless or more fruitful; by simply selecting the best\n&gt; &gt; &gt; of N populations =\r\neach tick we are discarding this useful info. \n&gt; &gt; &gt; \n&gt; &gt; &gt; So after lookin=\r\ng at a picture of the skeleton of a leaf, I thought\n&gt; &gt; &gt; that the best app=\r\nroach is to take an idea from nature; faced with \n&gt; &gt; the\n&gt; &gt; &gt; problem of =\r\ncovering the most area and the tools of forking and\n&gt; &gt; &gt; merging, nature h=\r\nas evolved circulatory systems which branch and\n&gt; &gt; &gt; converge regularly in=\r\n specific ways (in particular, one noticed\n&gt; &gt; &gt; recursion). The process is=\r\n called anastomosis I think. NEAT already\n&gt; &gt; &gt; does this in a way with spe=\r\ncies, which has the effect of packaging \n&gt; &gt; the\n&gt; &gt; &gt; population into disc=\r\nrete chunks which explore particular regions of\n&gt; &gt; &gt; search space. I propo=\r\nse simply doing this at a higher level in order\n&gt; &gt; &gt; to benefit from multi=\r\n-core machines and distributed processing.\n&gt; &gt; &gt; \n&gt; &gt; &gt; There is normally a=\r\n certain amount of ticks that are performed \n&gt; &gt; between\n&gt; &gt; &gt; speciation. =\r\nThe easiest way to split up the algorithm I think is to\n&gt; &gt; &gt; perform these=\r\n ticks in parallel, then have a &quot;merge&quot; function which\n&gt; &gt; &gt; selectively de=\r\ncides how to combine the n disparate populations into \n&gt; &gt; a\n&gt; &gt; &gt; unified =\r\none, for speciation. This is made easier if a &quot;control&quot;\n&gt; &gt; &gt; population is=\r\n saved before forking, for comparison later. To be a\n&gt; &gt; &gt; little more clea=\r\nr, a &#39;population&#39; object actually consists of 3 \n&gt; &gt; objects:\n&gt; &gt; &gt; A set o=\r\nf member chromosomes, each with their own attributes\n&gt; &gt; &gt; A set of member =\r\nspecies, each with their own attributes and member\n&gt; &gt; &gt; chromosomes\n&gt; &gt; &gt; =\r\nA set of behaviours (i.e. the archive), which I call a &quot;novelty \n&gt; &gt; pool&quot;\n=\r\n&gt; &gt; &gt; in my implementations. \n&gt; &gt; &gt; Each parallel tick() should take a copy=\r\n of these 3 objects and \n&gt; &gt; return\n&gt; &gt; &gt; 3 new ones. \n&gt; &gt; &gt; \n&gt; &gt; &gt; So in p=\r\nython the main loop would look superficially like this:\n&gt; &gt; &gt; \n&gt; &gt; &gt; while =\r\n( not time_to_stop )\n&gt; &gt; &gt;     speciate\n&gt; &gt; &gt;     for i in range ( j )\n&gt; &gt; =\r\n&gt;         do tick in parallel()\n&gt; &gt; &gt;     if reached_goal: time_to_stop =3D=\r\n True\n&gt; &gt; &gt; \n&gt; &gt; &gt; j is the integer that controls how many ticks are perfor=\r\nmed between\n&gt; &gt; &gt; speciation, which in nero is 5 but I&#39;m sure is robust to =\r\nsome \n&gt; &gt; variation.\n&gt; &gt; &gt; \n&gt; &gt; &gt; Novelty search should be performed with a=\r\n single consolidated\n&gt; &gt; &gt; behaviour archive to avoid duplication of work, =\r\nbut should branch \n&gt; &gt; out\n&gt; &gt; &gt; when exploring new individuals and harvest=\r\n information about the\n&gt; &gt; &gt; search frontier whenever possible. Because of =\r\nthis, the\n&gt; &gt; &gt; merge/selection operation should be carefully designed to \n=\r\n&gt; &gt; incorporate\n&gt; &gt; &gt; this information non-destructively.\n&gt; &gt; &gt; \n&gt; &gt; &gt; Nove=\r\nlty search often results in the most recently added individual\n&gt; &gt; &gt; being =\r\nremoved on the next available tick (this is because a species\n&gt; &gt; &gt; with ma=\r\nny members often has a high spawn probability, and \n&gt; &gt; the &#39;remove\n&gt; &gt; &gt; w=\r\norst chromosome&#39; operation tends to remove the worst of larger\n&gt; &gt; &gt; specie=\r\ns before smaller species). This has the effect that between \n&gt; &gt; many\n&gt; &gt; &gt;=\r\n ticks, no new individuals are added, but nonetheless the search\n&gt; &gt; &gt; fron=\r\ntier is altered by way of aging, stagnation, and changes to\n&gt; &gt; &gt; average f=\r\nitness. When comparing the reference/control population to\n&gt; &gt; &gt; the result=\r\n of a few ticks, we can tabulate a list of member\n&gt; &gt; &gt; chromosomes which a=\r\nre disjoint between the two sets; the chromosomes\n&gt; &gt; &gt; which are in refere=\r\nnce but not the new population can be considered\n&gt; &gt; &gt; dead-ends, and conve=\r\nrsely the chromosomes in the new population not\n&gt; &gt; &gt; present in the refere=\r\nnce can be considered improvements.\n&gt; &gt; &gt; \n&gt; &gt; &gt; The total set of improveme=\r\nnts between all n concurrent set of ticks\n&gt; &gt; &gt; should be preserved in the =\r\nnew unified population, and conversely \n&gt; &gt; the\n&gt; &gt; &gt; dead ends should be r=\r\nemoved, but doing this is more difficult than \n&gt; &gt; it\n&gt; &gt; &gt; seems. This is =\r\npartly because the list of member chromosomes is also\n&gt; &gt; &gt; intimately coup=\r\nled with the list of member species.\n&gt; &gt; &gt; \n&gt; &gt; &gt; Of the species which are =\r\ncommon to both a new population and the\n&gt; &gt; &gt; reference population, there m=\r\nay be differences in the species &quot;no\n&gt; &gt; &gt; improvement age&quot;, age, average f=\r\nitness, and member chromosomes. \n&gt; &gt; &gt; Unifying these disparate sets presen=\r\nts a problem for me.\n&gt; &gt; &gt; \n&gt; &gt; &gt; For example, what if an improvement from =\r\none of the new populations \n&gt; &gt; is\n&gt; &gt; &gt; a member of a species which was re=\r\nmoved in all the other new\n&gt; &gt; &gt; populations? What if a species has aged an=\r\nd stagnated in most of the\n&gt; &gt; &gt; populations but has produced an improvemen=\r\nt in another population? \n&gt; &gt; How\n&gt; &gt; &gt; can we produced a unified populatio=\r\nn which reflects the \n&gt; &gt; contributions\n&gt; &gt; &gt; to search that each concurren=\r\nt salvo of ticks has made?\n&gt; &gt; &gt; \n&gt; &gt; &gt; \n&gt; &gt; &gt; Any thoughts people have are=\r\n welcome.\n&gt; &gt; &gt;\n&gt; &gt;\n&gt;\n\n\n\n"}}