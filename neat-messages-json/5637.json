{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":54567749,"authorName":"Ken","from":"&quot;Ken&quot; &lt;kstanley@...&gt;","profile":"kenstanley01","replyTo":"LIST","senderId":"3q_6Y7fvdRdwqGArOsyMSjj60_g5ViKyQaIT621kLG_k33WAc_ffIg10gn17EQOqzr9DyEaMgSzV2wtTvnhG_ga8hMcm","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: technical question about custom number of sensors and output nodes","postDate":"1315713711","msgId":5637,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGo0aGJyZitzdjcxQGVHcm91cHMuY29tPg==","inReplyToHeader":"PGo0NDlrcytsbDM1QGVHcm91cHMuY29tPg=="},"prevInTopic":5636,"nextInTopic":0,"prevInTime":5636,"nextInTime":5638,"topicId":5623,"numMessagesInTopic":7,"msgSnippet":"Arman, yes, NEAT will only ever use sensors that are included in the starter genome file.  However, if those sensors are not connected to the network by a","rawEmail":"Return-Path: &lt;kstanley@...&gt;\r\nX-Sender: kstanley@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 33303 invoked from network); 11 Sep 2011 04:01:54 -0000\r\nX-Received: from unknown (98.137.35.162)\n  by m14.grp.sp2.yahoo.com with QMQP; 11 Sep 2011 04:01:54 -0000\r\nX-Received: from unknown (HELO n46b.bullet.mail.sp1.yahoo.com) (66.163.168.160)\n  by mta6.grp.sp2.yahoo.com with SMTP; 11 Sep 2011 04:01:54 -0000\r\nX-Received: from [69.147.65.171] by n46.bullet.mail.sp1.yahoo.com with NNFMP; 11 Sep 2011 04:01:53 -0000\r\nX-Received: from [98.137.34.72] by t13.bullet.mail.sp1.yahoo.com with NNFMP; 11 Sep 2011 04:01:53 -0000\r\nDate: Sun, 11 Sep 2011 04:01:51 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;j4hbrf+sv71@...&gt;\r\nIn-Reply-To: &lt;j449ks+ll35@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;Ken&quot; &lt;kstanley@...&gt;\r\nSubject: Re: technical question about custom number of sensors and output nodes\r\nX-Yahoo-Group-Post: member; u=54567749; y=xBaTSrsqreAX7gm0dcvSojTc95-x_O_uTtRGZVU8in8_bhiA_6P4\r\nX-Yahoo-Profile: kenstanley01\r\n\r\n\n\nArman, yes, NEAT will only ever use sensors that are included in the star=\r\nter genome file.  However, if those sensors are not connected to the networ=\r\nk by a connection, then they will not actually cause any activation of the =\r\nnetwork.  If NEAT later adds connections from such sensors, then they would=\r\n start to be used by the network.  So in other words, you can implement a k=\r\nind of FS-NEAT by not connecting the sensors to the network.\n\nI believe the=\r\n rtNEAT package has some population initialization options that allows a ra=\r\nndom subset of sensors (from the total set that are in the starter genome) =\r\nto be connected into the network in each genome in the initial population. =\r\n \n\nIn any case, so if you want several hundred inputs to be considered, the=\r\ny would indeed need to be included in the starter file, but they should not=\r\n cause great computational overhead because they are not necessarily connec=\r\nted into the network itself.  However, at the same time, I would also note =\r\nthat hundreds of inputs is a lot for NEAT to consider and it may take a lon=\r\ng time for NEAT to figure out which ones to use.\n\nken\n\n--- In neat@yahoogro=\r\nups.com, &quot;arman.schwarz&quot; &lt;arman.schwarz@...&gt; wrote:\n&gt;\n&gt; I also noticed that=\r\n the NETWORK::load_sensors function accepts a double pointer, so NEAT conce=\r\nivably has no knowledge of the number of inputs that are available (unless =\r\na vector is passed to the function).\n&gt; \n&gt; So am I correct in understanding =\r\nthat the rtNEAT package will not try adding inputs beyond those specified i=\r\nn the input file? This would be unfortunate as I might have several hundred=\r\n inputs and always using all of them in the genome start file would generat=\r\ne considerable computational (as well as human workload) overhead.\n&gt; \n&gt; How=\r\never, contrary to this you have previously mentioned in another post that F=\r\nSNEAT is supposed by rtNEAT, which does give me some hope. I&#39;m sorry I&#39;ve b=\r\neen somewhat unclear with my questions (I&#39;m still in the process of getting=\r\n my head around NEAT itself), but if the addition of sensors is supported, =\r\nwhere does this take place in rtNEAT? \n&gt; \n&gt; Arman\n&gt; \n&gt; --- In neat@yahoogro=\r\nups.com, &quot;arman.schwarz&quot; &lt;arman.schwarz@&gt; wrote:\n&gt; &gt;\n&gt; &gt; Thanks Ken,\n&gt; &gt; \n&gt;=\r\n &gt; I tried to create a simple starting genome that simply connects the inpu=\r\nt to the output;\n&gt; &gt; \n&gt; &gt; genomestart 1\n&gt; &gt; trait 1 1.0 0 0 0 0 0 0 0\n&gt; &gt; n=\r\node 1 1 1 1\n&gt; &gt; node 1 0 1 2\n&gt; &gt; gene 1 1 1 1.0 0 1 0 1\n&gt; &gt; genomeend 1\n&gt; &gt;=\r\n \n&gt; &gt; when I allow this to run it does a surprisingly good job at finding a=\r\n solution, but it doesn&#39;t use the other inputs. That is to say, I end up wi=\r\nth very complex networks that do a reasonable job of predicting the timeser=\r\nies (but not as well as they could if they used all the inputs), but none o=\r\nf the nodes, other than the first, are ever input nodes.\n&gt; &gt; \n&gt; &gt; Supposing=\r\n that I have 25 inputs, I am creating the following start genes file:\n&gt; &gt; \n=\r\n&gt; &gt; genomestart 1\n&gt; &gt; trait 1 1 0 0 0 0 0 0 0\n&gt; &gt; node 1 0 1 1\n&gt; &gt; node 2 0=\r\n 1 1\n&gt; &gt; node 3 0 1 1\n&gt; &gt; node 4 0 1 1\n&gt; &gt; node 5 0 1 1\n&gt; &gt; node 6 0 1 1\n&gt; =\r\n&gt; node 7 0 1 1\n&gt; &gt; node 8 0 1 1\n&gt; &gt; node 9 0 1 1\n&gt; &gt; node 10 0 1 1\n&gt; &gt; node=\r\n 11 0 1 1\n&gt; &gt; node 12 0 1 1\n&gt; &gt; node 13 0 1 1\n&gt; &gt; node 14 0 1 1\n&gt; &gt; node 15=\r\n 0 1 1\n&gt; &gt; node 16 0 1 1\n&gt; &gt; node 17 0 1 1\n&gt; &gt; node 18 0 1 1\n&gt; &gt; node 19 0 =\r\n1 1\n&gt; &gt; node 20 0 1 1\n&gt; &gt; node 21 0 1 1\n&gt; &gt; node 22 0 1 1\n&gt; &gt; node 23 0 1 1=\r\n\n&gt; &gt; node 24 0 1 1\n&gt; &gt; node 25 0 1 1\n&gt; &gt; node 26 0 0 2\n&gt; &gt; node 27 0 0 3\n&gt; =\r\n&gt; node 28 0 0 0\n&gt; &gt; gene 1 1 26 1 0 1 0 1\n&gt; &gt; genomeend 1\n&gt; &gt; \n&gt; &gt; Will thi=\r\ns ensure that NEAT makes use of any available inputs (assuming there are on=\r\nly 25)?\n&gt; &gt; \n&gt; &gt; Arman\n&gt; &gt; \n&gt; &gt; --- In neat@yahoogroups.com, &quot;Ken&quot; &lt;kstanle=\r\ny@&gt; wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; \n&gt; &gt; &gt; \n&gt; &gt; &gt; Hi Arman, nodes.size() is not constant=\r\n because nodes is a variable-length list, so it can grow or shrink.  Asking=\r\n for its size just gives the current number of nodes in the list.  The &quot;inl=\r\nist&quot; and &quot;outlist&quot; (lists of inputs and outputs internally generated by NEA=\r\nT) work the same way, so they too can change.  Therefore, in principle, I b=\r\nelieve that your idea should be feasible.  However, you need to make sure t=\r\nhat if you ever add new inputs that those new nodes have the right flags ma=\r\nrking them as input nodes and sensors.\n&gt; &gt; &gt; \n&gt; &gt; &gt; There used to be a tuto=\r\nrial that comes with NEAT that explained the file format, but it gone out o=\r\nf date as NEAT was updated, so I believe unfortunately it&#39;s no longer inclu=\r\nded.  Let me try to explain a little:\n&gt; &gt; &gt; \n&gt; &gt; &gt; Traits are reserved for =\r\nspecial genetic information that nodes or connections can point to.  They a=\r\nre not used in most NEAT experiments.  I believe you just need one dummy tr=\r\nait in a genome file trait but it won&#39;t be used.\n&gt; &gt; &gt; \n&gt; &gt; &gt; node 1 0 1 1\n=\r\n&gt; &gt; &gt; \n&gt; &gt; &gt; The first number is the node ID #, the second is the trait poi=\r\nnter (which can be left at zero), the third says whether the node is NEURON=\r\n/SENSOR (0,1), and the fourth is HIDDEN/INPUT/OUTPUT/BIAS (0,1,2,3).  It&#39;s =\r\ntrue that the third and fourth numbers are a little confusing because they =\r\nseem to be about a similar issue, but that is how they are defined.\n&gt; &gt; &gt; \n=\r\n&gt; &gt; &gt; gene 1 1 5 0.0 0 1 0 1\n&gt; &gt; &gt; \n&gt; &gt; &gt; The parameters are: trait # (not =\r\nusually used), in_node id, out_node id, weight, is_recurrent flag, innovati=\r\non_num, mutation_num, and enable flag.\n&gt; &gt; &gt; \n&gt; &gt; &gt; Note that mutation_num =\r\nis generally set the same as the weight and does not have a real specific u=\r\nse in NEAT.\n&gt; &gt; &gt; \n&gt; &gt; &gt; As you may notice some parameters seem unnecessary=\r\n or redundant, but I initially created this format before I was sure about =\r\neverything that would be needed and the legacy parameters stuck around, whi=\r\nch unfortunately can be confusing.\n&gt; &gt; &gt; \n&gt; &gt; &gt; ken\n&gt; &gt; &gt; \n&gt; &gt; &gt; --- In nea=\r\nt@yahoogroups.com, &quot;arman.schwarz&quot; &lt;arman.schwarz@&gt; wrote:\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; =\r\n\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; Thanks Ken,\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; I think I understand what yo=\r\nu mean. So when a new genome is created, NEAT will search through the &quot;node=\r\ns&quot; vector to look for candidates. The nodes vector in turn is generated ini=\r\ntially by what it finds in the call to this function during the initial cre=\r\nation of the population:\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; Genome::Genome(int id, std::ifstr=\r\neam &iFile)\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; Does this mean that nodes.size() is constant a=\r\nnd initially constrained to what is given in the genome start file, or does=\r\n can it adapt depending on the size of the array passed to the &quot;load_sensor=\r\ns&quot; function?\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; The reason I ask is because I have about 200 =\r\ninputs, and I would like to create a start file which simply takes the firs=\r\nt input as output, and tries to improve based on that, preferably allowing =\r\nme to use any number of inputs with a single genome start file. Can I do th=\r\nat without destroying NEAT&#39;s ability to recognise the existence of all the =\r\nsensors?\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; I&#39;m also somewhat confused about the format of th=\r\nose start files, is there any documentation for these files that I can lear=\r\nn from, or will I just need to look through the source code? I understand N=\r\nEAT&#39;s concept of bias nodes, but not so much the idea of &quot;traits&quot;, so it wo=\r\nuld be nice to know if any documentation does exist.\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; Thank=\r\ns again for your help.\n&gt; &gt; &gt; &gt; Arman\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; --- In neat@yahoogrou=\r\nps.com, &quot;Ken&quot; &lt;kstanley@&gt; wrote:\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; =\r\nHi Arman, from what you wrote I think you understand how to pass in and rea=\r\nd out the input and output arrays.  I think the main question you are askin=\r\ng is how it knows how long those arrays are.\n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; The answe=\r\nr is that rtNEAT (or plain NEAT) C++ counts the number of inputs and number=\r\n of outputs when it creates a neural network from a genome, which happens i=\r\nn the method \n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; Network *Genome::genesis(int id)\n&gt; &gt; &gt; &gt;=\r\n &gt; \n&gt; &gt; &gt; &gt; &gt; When it creates the network, it creates separate lists of inp=\r\nuts, hidden nodes, and outputs, as you can see here:\n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt;  =\r\n               //Check for input or output designation of node\n&gt; &gt; &gt; &gt; &gt;   =\r\n              if (((*curnode)-&gt;gen_node_label)=3D=3DINPUT)\n&gt; &gt; &gt; &gt; &gt;       =\r\n                  inlist.push_back(newnode);\n&gt; &gt; &gt; &gt; &gt;                 if (=\r\n((*curnode)-&gt;gen_node_label)=3D=3DBIAS)\n&gt; &gt; &gt; &gt; &gt;                         i=\r\nnlist.push_back(newnode);\n&gt; &gt; &gt; &gt; &gt;                 if (((*curnode)-&gt;gen_no=\r\nde_label)=3D=3DOUTPUT)\n&gt; &gt; &gt; &gt; &gt;                         outlist.push_back(=\r\nnewnode);\n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; Then it knows how many inputs there are and =\r\nhow many outputs there are because it knows how long those lists are.\n&gt; &gt; &gt;=\r\n &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; Going back further in the chain, usually the first place th=\r\nis issue will ultimately be specified is in the starter genome file, which =\r\nis usually the origin of the genome data structures (which are created from=\r\n this file).  Here is a pole balancing starter genome:\n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt;=\r\n genomestart 1\n&gt; &gt; &gt; &gt; &gt; trait 1 0.1 0 0 0 0 0 0 0\n&gt; &gt; &gt; &gt; &gt; node 1 0 1 1\n&gt;=\r\n &gt; &gt; &gt; &gt; node 2 0 1 1\n&gt; &gt; &gt; &gt; &gt; node 3 0 1 1\n&gt; &gt; &gt; &gt; &gt; node 4 0 1 3\n&gt; &gt; &gt; &gt;=\r\n &gt; node 5 0 0 2\n&gt; &gt; &gt; &gt; &gt; gene 1 1 5 0.0 0 1 0 1\n&gt; &gt; &gt; &gt; &gt; gene 1 2 5 0.0 0=\r\n 2 0 1\n&gt; &gt; &gt; &gt; &gt; gene 1 3 5 0.0 0 3 0 1\n&gt; &gt; &gt; &gt; &gt; gene 1 4 5 0.0 0 4 0 1\n&gt; =\r\n&gt; &gt; &gt; &gt; genomeend 1\n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; Here the numerical codes next the =\r\nnodes specify what type of nodes they are.  In this case, there are 4 input=\r\ns (one is a bias) and 1 output.  These codes are defined in nnode.h:\n&gt; &gt; &gt; =\r\n&gt; &gt; \n&gt; &gt; &gt; &gt; &gt;         enum nodetype {\n&gt; &gt; &gt; &gt; &gt;                 NEURON =3D=\r\n 0,\n&gt; &gt; &gt; &gt; &gt;                 SENSOR =3D 1\n&gt; &gt; &gt; &gt; &gt;         };\n&gt; &gt; &gt; &gt; &gt; \n=\r\n&gt; &gt; &gt; &gt; &gt;         enum nodeplace {\n&gt; &gt; &gt; &gt; &gt;                 HIDDEN =3D 0,\n=\r\n&gt; &gt; &gt; &gt; &gt;                 INPUT =3D 1,\n&gt; &gt; &gt; &gt; &gt;                 OUTPUT =3D=\r\n 2,\n&gt; &gt; &gt; &gt; &gt;                 BIAS =3D 3\n&gt; &gt; &gt; &gt; &gt;         };\n&gt; &gt; &gt; &gt; &gt; \n&gt; =\r\n&gt; &gt; &gt; &gt; So usually that is from where NEAT ultimately ends up knowing these=\r\n counts.  I hope that helps answer your question.\n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; ken\n=\r\n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; --- In neat@yahoogroups.com, &quot;arman.schwarz=\r\n&quot; &lt;arman.schwarz@&gt; wrote:\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; hi everyone, \n&gt; &gt; &gt; &gt; &gt; &gt;=\r\n I am currently trying to apply timeseries prediction to the rtNEAT c++ pac=\r\nkage, to compare its search performance to a fixed-size, evolving topology =\r\nrecurrent neural net I wrote.\n&gt; &gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; &gt; I have written a cus=\r\ntom experiments.h/cpp file to cycle through the activate() function for eve=\r\nry time step, after loading an array of ~75 sensor inputs.\n&gt; &gt; &gt; &gt; &gt; &gt; \n&gt; &gt;=\r\n &gt; &gt; &gt; &gt; So while I understand how to load the inputs and retrieve the outp=\r\nuts, I don&#39;t quite understand how I am supposed to tell NEAT how many input=\r\ns and outputs there are. after all, that array I&#39;m passing to load_sensor i=\r\ns nothing more than a pointer to a value.\n&gt; &gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; &gt; so where=\r\n do I tell NEAT how many inputs I will give each net, and how many outputs =\r\nI will be expecting? (in my RNN the outputs were simply the last x neurons,=\r\n but the inputs do need to be defined).\n&gt; &gt; &gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; &gt; &gt; thanks in =\r\nadvance for the help!\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt;\n&gt;\n\n\n\n"}}