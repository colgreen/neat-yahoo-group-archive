{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":130984297,"authorName":"joel278","from":"&quot;joel278&quot; &lt;lehman.154@...&gt;","profile":"joel278","replyTo":"LIST","senderId":"2cILqPSkxUjj0_KTAlWZ9y0vDkjWDmfnarvgvRUZ2uSPaLMeC47WgZzANzKgmqWIRbk4B5fHMordf_qXMF_fdpl9jWAC","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: rtNEAT: max_depth() in an endless loop","postDate":"1225740367","msgId":4409,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGdlbmo4ZitmbjFrQGVHcm91cHMuY29tPg==","inReplyToHeader":"PDQ5MEY0QjgyLjYwMzA4MDZAeWFob28uY29tPg=="},"prevInTopic":4408,"nextInTopic":4410,"prevInTime":4408,"nextInTime":4410,"topicId":4396,"numMessagesInTopic":16,"msgSnippet":"Hey Jim, I think there is some confusion here because the issue in question is specific to the rtNEAT implementation (the bug may be present in the original","rawEmail":"Return-Path: &lt;lehman.154@...&gt;\r\nX-Sender: lehman.154@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 7887 invoked from network); 3 Nov 2008 19:26:17 -0000\r\nX-Received: from unknown (66.218.67.97)\n  by m47.grp.scd.yahoo.com with QMQP; 3 Nov 2008 19:26:17 -0000\r\nX-Received: from unknown (HELO n41b.bullet.mail.sp1.yahoo.com) (66.163.168.155)\n  by mta18.grp.scd.yahoo.com with SMTP; 3 Nov 2008 19:26:17 -0000\r\nX-Received: from [69.147.65.174] by n41.bullet.mail.sp1.yahoo.com with NNFMP; 03 Nov 2008 19:26:11 -0000\r\nX-Received: from [66.218.67.200] by t12.bullet.mail.sp1.yahoo.com with NNFMP; 03 Nov 2008 19:26:10 -0000\r\nDate: Mon, 03 Nov 2008 19:26:07 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;genj8f+fn1k@...&gt;\r\nIn-Reply-To: &lt;490F4B82.6030806@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;joel278&quot; &lt;lehman.154@...&gt;\r\nSubject: Re: rtNEAT: max_depth() in an endless loop\r\nX-Yahoo-Group-Post: member; u=130984297; y=S6eLlabXxIv26nnWHlnfjY053oNIcNYBm8UBpyH78Vxj1T5w0quB\r\nX-Yahoo-Profile: joel278\r\n\r\nHey Jim,\n\nI think there is some confusion here because the issue in questio=\r\nn\nis specific to the rtNEAT implementation (the bug may be present in  \nthe=\r\n original C++ version as well, although I haven&#39;t checked).\n\nIn rtNEAT, the=\r\nre is a function that calculates the maximum depth of\na network, and is mea=\r\nnt only to be applied to non-recurrent networks.\nThis is useful if you are =\r\ntrying to query a net efficiently, so you\nonly have to activate it enough t=\r\nimes for the input signals to \npropagate all the way to the output.\n\nHoweve=\r\nr, there is a bug in the rtNEAT implementation such that\neven with recurren=\r\nt connections disabled, somehow they can still seep\ninto a network occasion=\r\nally. \n\nIf this happens, and the maximum depth function is called on a net\n=\r\nwith recurrent connections, an endless loop can result. This is\nbecause the=\r\n function was designed only to work with non-recurrent\nnetworks.\n\nTom, you =\r\nare right in that this method cannot easily be extended to\ndealing with rec=\r\nurrent networks.\n\nOften the strategy that you mention is applied, arbitrari=\r\nly activating\nthe net a reasonable number of times. It is an\neasy way to av=\r\noid this bug until it is fixed.\n\nJoel\n\n\n--- In neat@yahoogroups.com, Jim O&#39;=\r\nFlaherty &lt;jim_oflaherty_jr@...&gt; wrote:\n&gt;\n&gt; Peter,\n&gt; \n&gt; That doesn&#39;t make se=\r\nnse to me. Cesar&#39;s comments indicate he has a \n&gt; similar implementation to =\r\nmine. Basically, every node&#39;s value in a \n&gt; single instance of an ANN is ca=\r\nlculated just once on an activation\npass. \n&gt; When the node is calculated, e=\r\nach of the nodes attached to it as\n&quot;input&quot; \n&gt; are used (whether they have b=\r\neen activated in this pass, or hold a \n&gt; residual value from the previous p=\r\nass) to calculate it&#39;s current value. \n&gt; And assuming the ordering of the a=\r\nctivations is lined up by dependency \n&gt; and they by node age, the network o=\r\nught to activate deterministically \n&gt; meaning that starting with an empty n=\r\network (all node activation values \n&gt; are set to 0.0), providing the same i=\r\nnput and making several activation \n&gt; passes ought to be able to return rel=\r\niably repeatable results given the \n&gt; node activation values are reset to 0=\r\n.0 and precisely the same input is \n&gt; submitted for the same number of acti=\r\nvation passes.\n&gt; \n&gt; I get that the network graph can have cycles, as in rec=\r\nurrent \n&gt; connections. However, those have no relevance to activation order=\r\n or \n&gt; cause any sort of &quot;loop&quot; in a straightforward ANN implementation. So=\r\n, I \n&gt; am getting confused about where and how an &quot;endless loop&quot; could form=\r\n. \n&gt; Perhaps they are talking about the network output never stabilizing to=\r\n \n&gt; within some stable value ranges when activating it repeatedly with the =\r\n\n&gt; same input. That&#39;s to be expected in a network with enough recurrent \n&gt; =\r\nconnections - non-uniformity in the output following activations with \n&gt; th=\r\ne same input. Each additional recurrent connection increases the \n&gt; &quot;echos =\r\nfrom the past&quot; causing a stable output cycle to become less and \n&gt; less pro=\r\nbable.\n&gt; \n&gt; Said another way, a single activation of an ANN, with or withou=\r\nt \n&gt; recurrent connections, will results in exactly the same number of node=\r\n \n&gt; activation calculations each time it is told to process input. There \n&gt;=\r\n should not be any variability to the number of node activations AT ALL. \n&gt;=\r\n If so, then some sort of different activation strategy is being \n&gt; employe=\r\nd. And if so, what is it? And why?\n&gt; \n&gt; \n&gt; Jim\n&gt; \n&gt; \n&gt; petar_chervenski wro=\r\nte:\n&gt; &gt;\n&gt; &gt; It is about the loop in which you calculate the longest path fr=\r\nom an\n&gt; &gt; input node to an output node. Not the activation loop in which yo=\r\nu\n&gt; &gt; activate the network.\n&gt; &gt;\n&gt; &gt; Peter\n&gt; &gt;\n&gt; &gt; --- In neat@yahoogroups.c=\r\nom &lt;mailto:neat%40yahoogroups.com&gt;, Jim \n&gt; &gt; O&#39;Flaherty &lt;jim_oflaherty_jr@&gt;=\r\n\n&gt; &gt; wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; Ken,\n&gt; &gt; &gt;\n&gt; &gt; &gt; I am confused how you could end up=\r\n in an endless activation loop. If\n&gt; &gt; you\n&gt; &gt; &gt; are moving from the input =\r\nnodes forward through the hidden nodes to\n&gt; &gt; the\n&gt; &gt; &gt; output nodes as a s=\r\ntate calculation progression, there would be no\n&gt; &gt; need\n&gt; &gt; &gt; to worry abo=\r\nut activation loops - you would only calculate the value\n&gt; &gt; of\n&gt; &gt; &gt; each =\r\nnode once in a single pass. The point of a recurrent connection\n&gt; &gt; is\n&gt; &gt; =\r\n&gt; to carry state between full network activations. So, the value\n&gt; &gt; provid=\r\ned\n&gt; &gt; &gt; by a recurrent connection would not be used until the next\n&gt; &gt; act=\r\nivation\n&gt; &gt; &gt; pass (assuming all the nodes from the previous pass have not =\r\nbe\n&gt; &gt; &quot;zeroed\n&gt; &gt; &gt; out&quot;).\n&gt; &gt; &gt;\n&gt; &gt; &gt; How is it there is an endless loop?=\r\n\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; Jim\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; Kenneth Stanley wrote:\n&gt; &gt; &gt; &gt;\n&gt; &gt;=\r\n &gt; &gt; Yes I have heard about this problem coming up in the XOR\n&gt; &gt; experimen=\r\nt.\n&gt; &gt; &gt; &gt; Most neuroevolution experiments are not classification experimen=\r\nts\n&gt; &gt; &gt; &gt; (i.e. they don&#39;t have a &quot;final&quot; output), or they allow recurrent=\r\n\n&gt; &gt; &gt; &gt; connections, and therefore do not require depth to be computed.\n&gt; =\r\n&gt; &gt; &gt; Therefore, this problem will not come up in most expeirments.\n&gt; &gt; &gt; &gt;=\r\n\n&gt; &gt; &gt; &gt; However, XOR is a benchmark classification problem that is only\n&gt; =\r\n&gt; meant\n&gt; &gt; &gt; &gt; to be attempted by feedforward networks so it needs to have=\r\n depth\n&gt; &gt; &gt; &gt; computed. It appears that my attempts to keep the network\n&gt; =\r\n&gt; feedforward\n&gt; &gt; &gt; &gt; in all cases is not perfect, so sometimes when a loop=\r\n arises, it\n&gt; &gt; sends\n&gt; &gt; &gt; &gt; the depth computation into an infinite loop. =\r\nI have not had time\n&gt; &gt; to\n&gt; &gt; &gt; &gt; think about the most elegant solution to=\r\n this problem: Maybe it\n&gt; &gt; should\n&gt; &gt; &gt; &gt; be a stronger check on recurrenc=\r\ne, perhaps entirely different from\n&gt; &gt; how\n&gt; &gt; &gt; &gt; it works now. Or perhaps=\r\n it should be a fixed abort-iteration for\n&gt; &gt; the\n&gt; &gt; &gt; &gt; depth routine.\n&gt; =\r\n&gt; &gt; &gt;\n&gt; &gt; &gt; &gt; If someone does feel they have an elegant bit of code to addr=\r\ness\n&gt; &gt; the\n&gt; &gt; &gt; &gt; issue, I will be happy to take a look.\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; =\r\nIn any case, it should not cause serious problems in general. I\n&gt; &gt; &gt; &gt; apo=\r\nlogize for any inconvenience.\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; ken\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; --- In ne=\r\nat@yahoogroups.com &lt;mailto:neat%40yahoogroups.com&gt; \n&gt; &gt; &lt;mailto:neat%40yaho=\r\nogroups.com&gt;,\n&gt; &gt; &gt; &gt; &quot;petar_chervenski&quot; &lt;petar_chervenski@&gt;\n&gt; &gt; &gt; &gt; wrote:=\r\n\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; Hi Cesar,\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; I know of this problem. =\r\nIt is obvious that depth cannot be\n&gt; &gt; determined\n&gt; &gt; &gt; &gt; &gt; in a recurrent =\r\nnetwork, but in general it depends, what is your\n&gt; &gt; way to\n&gt; &gt; &gt; &gt; &gt; handl=\r\ne the situation. Try improving the add_link() code so that\n&gt; &gt; the\n&gt; &gt; &gt; &gt; =\r\n&gt; right nodes are picked up when trying to add a forward or a\n&gt; &gt; recurrent=\r\n\n&gt; &gt; &gt; &gt; &gt; connection. This is a good solution but in general the problem\n&gt;=\r\n &gt; with\n&gt; &gt; &gt; &gt; &gt; looped networks cannot be avoided. Suppose you have 3 hid=\r\nden\n&gt; &gt; nodes, A,\n&gt; &gt; &gt; &gt; &gt; B, and C. If you link these like A-&gt;B, B-&gt;C, C-=\r\n&gt;A, it is a loop\n&gt; &gt; in the\n&gt; &gt; &gt; &gt; &gt; network, even though all connections =\r\nare meant to be forward.\n&gt; &gt; &gt; &gt; &gt; The best solution in my opinion is to pu=\r\nt a limit on the\n&gt; &gt; possible\n&gt; &gt; &gt; &gt; &gt; depth, say 32, if the depth exceeds=\r\n 32, quit the recursion and\n&gt; &gt; &gt; &gt; &gt; activate the network 32 times. It slo=\r\nws things down but at least\n&gt; &gt; it\n&gt; &gt; &gt; &gt; &gt; will not hurt evolution as if =\r\nyou penalize looped networks.\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; Peter\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;=\r\n --- In neat@yahoogroups.com &lt;mailto:neat%40yahoogroups.com&gt; \n&gt; &gt; &lt;mailto:n=\r\neat%40yahoogroups.com&gt;,\n&gt; &gt; &quot;Cesar\n&gt; &gt; &gt; &gt; G. Miguel&quot; &lt;cesar.gomes@&gt;\n&gt; &gt; &gt; =\r\n&gt; &gt; wrote:\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; Hi all,\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; I&#39;m not =\r\nsure if someone else has notice this &quot;bug&quot; in rtNEAT,\n&gt; &gt; but\n&gt; &gt; &gt; &gt; &gt; the=\r\n\n&gt; &gt; &gt; &gt; &gt; &gt; max_depth() method in network.cpp has the potential to be\n&gt; &gt; =\r\nforever in\n&gt; &gt; &gt; &gt; &gt; &gt; loop if a recurrent link is added in a feedforward t=\r\nopology,\n&gt; &gt; e.g.,\n&gt; &gt; &gt; &gt; &gt; the\n&gt; &gt; &gt; &gt; &gt; &gt; XOR experiment (and that can h=\r\nappen even when the\n&gt; &gt; recur_only_prob\n&gt; &gt; &gt; &gt; &gt; &gt; parameter is set to zer=\r\no). A real example is attached.\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; It seems to happen =\r\nin 1 out of 10 runs. The max_depth() method\n&gt; &gt; calls\n&gt; &gt; &gt; &gt; &gt; &gt; depth() i=\r\nn nnode.cpp, which should return the max depth of\n&gt; &gt; that\n&gt; &gt; &gt; &gt; &gt; node.\n=\r\n&gt; &gt; &gt; &gt; &gt; &gt; But it can get trapped in a loop if any recurrent link is\n&gt; &gt; p=\r\nresent\n&gt; &gt; &gt; &gt; &gt; (as\n&gt; &gt; &gt; &gt; &gt; &gt; it is commented out in the source: DEPTH N=\r\nOT DETERMINED FOR\n&gt; &gt; NETWORK\n&gt; &gt; &gt; &gt; &gt; &gt; WITH LOOP).\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;=\r\n &gt; For those cases I have to force a return if an endless loop is\n&gt; &gt; &gt; &gt; &gt;=\r\n &gt; detected and then set the chromosome&#39;s fitness to zero in\n&gt; &gt; order to\n&gt;=\r\n &gt; &gt; &gt; &gt; &gt; continue.\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; Has anyone dealed with that be=\r\nfore?\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; []&#39;s\n&gt; &gt; &gt; &gt; &gt; &gt; Cesar\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;\n=\r\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt;\n\n\n\n"}}