{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":197999825,"authorName":"John Arrowwood","from":"John Arrowwood &lt;jarrowwx@...&gt;","profile":"jarrowwx","replyTo":"LIST","senderId":"S3MTNlLfv1HS8Nv1_kmBf1VldmjbjPTE7Pu63l_Iy92xFvf_5yO3zBY6S8JZOk41QxOuczZbFbDY5GswtmTE19fF9F6eQ1NALiY","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Re: Introduction---recurrency question","postDate":"1125610704","msgId":2233,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDUxN2ZhNmYxMDUwOTAxMTQzODI3MzgzYjFAbWFpbC5nbWFpbC5jb20+","inReplyToHeader":"PDIwMDUwOTAxMjA0ODI4Lk0yMzA2N0BkZWFyZG9yZmYuY29tPg==","referencesHeader":"PGRmMzh1MCtkNGhvQGVHcm91cHMuY29tPiA8ZGY1MGtxK2UxMXJAZUdyb3Vwcy5jb20+CSA8NTE3ZmE2ZjEwNTA4MzExNzI3NzU5ZTVjZGNAbWFpbC5nbWFpbC5jb20+CSA8Ni4yLjAuMTQuMC4yMDA1MDkwMTEyMjQyNS4wMzI4NDliMEBwb3AubWFpbC55YWhvby5jby51az4JIDwyMDA1MDkwMTIwNDgyOC5NMjMwNjdAZGVhcmRvcmZmLmNvbT4="},"prevInTopic":2232,"nextInTopic":2234,"prevInTime":2232,"nextInTime":2234,"topicId":2209,"numMessagesInTopic":42,"msgSnippet":"... A wise move...  :) ... What is fair ?  REAL networks don t have the privilege of being able to see the OLD state of the neuron they are connected to... ","rawEmail":"Return-Path: &lt;jarrowwx@...&gt;\r\nX-Sender: jarrowwx@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 91547 invoked from network); 1 Sep 2005 21:38:25 -0000\r\nReceived: from unknown (66.218.66.166)\n  by m33.grp.scd.yahoo.com with QMQP; 1 Sep 2005 21:38:25 -0000\r\nReceived: from unknown (HELO wproxy.gmail.com) (64.233.184.196)\n  by mta5.grp.scd.yahoo.com with SMTP; 1 Sep 2005 21:38:25 -0000\r\nReceived: by wproxy.gmail.com with SMTP id i6so450382wra\n        for &lt;neat@yahoogroups.com&gt;; Thu, 01 Sep 2005 14:38:24 -0700 (PDT)\r\nReceived: by 10.54.21.63 with SMTP id 63mr1987276wru;\n        Thu, 01 Sep 2005 14:38:24 -0700 (PDT)\r\nReceived: by 10.54.80.10 with HTTP; Thu, 1 Sep 2005 14:38:24 -0700 (PDT)\r\nMessage-ID: &lt;517fa6f1050901143827383b1@...&gt;\r\nDate: Thu, 1 Sep 2005 14:38:24 -0700\r\nTo: neat@yahoogroups.com\r\nIn-Reply-To: &lt;20050901204828.M23067@...&gt;\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: quoted-printable\r\nContent-Disposition: inline\r\nReferences: &lt;df38u0+d4ho@...&gt; &lt;df50kq+e11r@...&gt;\n\t &lt;517fa6f10508311727759e5cdc@...&gt;\n\t &lt;6.2.0.14.0.20050901122425.032849b0@...&gt;\n\t &lt;20050901204828.M23067@...&gt;\r\nX-eGroups-Msg-Info: 1:12:0:0\r\nFrom: John Arrowwood &lt;jarrowwx@...&gt;\r\nReply-To: John@...\r\nSubject: Re: [neat] Re: Introduction---recurrency question\r\nX-Yahoo-Group-Post: member; u=197999825; y=9xd6Kx3oJLoE5pMIwZlqXUgqVaaXTQ7YfQ0szyN-ijOAKJ4\r\nX-Yahoo-Profile: jarrowwx\r\n\r\nOn 9/1/05, Jeff Haynes &lt;jeff@...&gt; wrote:\n&gt; This is all very inter=\r\nesting to me as I hadn&#39;t really thought about the single\n&gt; value approach. =\r\n I think my mind briefly forayed into the possibility of a\n&gt; massively para=\r\nllel system with threads representing signals, got very scared,\n&gt; and retre=\r\nated.  \n\nA wise move...  :)\n\n&gt; Does anyone have any experience comparing th=\r\ne two?  Is one\n&gt; &quot;more correct&quot;?  It seems to me that the sink/source model=\r\n is &quot;correct&quot; in\n&gt; that it &quot;fairly&quot; propogates all signals\n\nWhat is &#39;fair&#39;?=\r\n  REAL networks don&#39;t have the privilege of being able\nto see the OLD state=\r\n of the neuron they are connected to...\n\n&gt; and that the single source model=\r\n *could* be equally &quot;correct&quot;.\n\nFor a standard feed-forward network with no=\r\n recurrency that is a\nsimple discriminator, it produces IDENTICAL results w=\r\nith the &#39;more\ncorrect&#39; model.  It just does it in a fraction of the time an=\r\nd\ncomputational resources.\n\nYou will get DIFFERENT results for a controller=\r\n depending on which\nmethod you use.  But if the network was evolved using t=\r\nhat firing\nmechanism, and it therefore WORKS with that firing mechanism, th=\r\nen it\ndoesn&#39;t make any difference which one you use, as long as you pick on=\r\ne\nand stick with it throughout the life of the experiment.\n\nIt is possible,=\r\n as I mentioned before, that the high-speed alternative\nmight make some thi=\r\nngs harder to evolve.  Or it might make mutations\nhave unintended consequen=\r\nces on the behavior of a controller, causing\nan initial hit in fitness.  Bu=\r\nt heck, let&#39;s face it, that is true of\nthe &#39;right&#39; way of activating, too..=\r\n.  New topology always brings that\nrisk.  We mitigate that risk by careful =\r\nselection of initial weights.\n\n&gt; However, the single source model also seem=\r\ns\n&gt; much more susceptible to evolution-induced sequencing.  \n\nThat&#39;s why I =\r\nsaid, the method you use to determine firing order is\nimportant.  It matter=\r\ns...\n\n&gt; I think I would need to be assured that the single value model was =\r\nin practice equivelent \n&gt; to the s/s model although I&#39;m not sure why...\n\nI =\r\ncan assure you that it is NOT equivalent.  Not for a controller.  \n\n&gt; I sup=\r\npose as long as the single value\n&gt; model converges to a solution, I don&#39;t r=\r\neally care.  \n\nExactly!\n\n&gt; Perhaps I feel that any deviation from the s/s b=\r\nehavior would lead to unstable and \n&gt; nonrobust networks that would be over=\r\nly sensitive to change.\n\nThat depends entirely on the mechanism you used to=\r\n determine firing\norder.  And it depends on the nature of the change.\n\nAgai=\r\nn, it ONLY matters when there is recurrence.  For a non-recurrent\nnetwork, =\r\nthe optimized method accomplishes in 1 pass what the other\naccomplishes in =\r\n&#39;N&#39; timesteps.  And the results are IDENTICAL.\n\nFor recurrence, you need a =\r\ngood algorithm for determining firing\norder.  If you choose it poorly, it m=\r\nay cause the addition of a new\nnode to cause undue hassle and impact evolut=\r\nion.  If you choose it\nwisely, it shouldn&#39;t be much different than the stan=\r\ndard way at least\nas far as how hard it is to evolve a solution.  Remember,=\r\n evolution\nisn&#39;t necessarily easy to begin with...\n\nHere&#39;s an easy, determi=\r\nnistic method for you:\n\nMark all input nodes as &#39;satisfied&#39;. \nIf you &#39;fire&#39;=\r\n input nodes, push them onto the head of the firing order\nlist, first.\nScan=\r\n through the list of nodes.  For each node that hasn&#39;t already\nbeen added t=\r\no the fire list\n  inspect all of the nodes that this node depends on\n    if=\r\n any of those nodes is not &#39;satisfied&#39; yet, skip this node and\ngo on to the=\r\n next one\n  If all of the nodes that this node depends on are &#39;satisfied&#39; t=\r\nhen \n    mark this node as satisfied\n    and make a note that shows that yo=\r\nu found another node in this pass through\nAt the end of the scan pass, if y=\r\nou found at least one node that was\nnewly marked satisfied, go back and do =\r\nit again (if there are any\nleft)\nIf not, see if there are any nodes not yet=\r\n added to the list.  If not,\nyou are done.\nIf there are, choose one to flag=\r\n as &#39;satisfied&#39; and then loop through\nagain.  For example, pick the one wit=\r\nh the smallest ID.\nRepeat until all nodes have been added to the firing ord=\r\ner list.  \n\nThe key is how you choose which one to mark as &#39;satisfied&#39; even=\r\n though\nit isn&#39;t really satisfied.  You could say &#39;choose the one closest t=\r\no\nbeing satisfied&#39; but then that might change when something else is\nadded =\r\nto the topology.  But then again, the addition of more topology\nmight cause=\r\n the loop or recurrency to go away, so that there is again\na deterministic =\r\norder in which to fire the nodes, too.  That changes\nthe behavior of the ne=\r\ntwork, however slightly.\n\nOnce you have generated the firing order list, SA=\r\nVE THAT LIST.  It&#39;s\nvery CPU expensive to generate that list.  Keep that li=\r\nst with that\ntopology.  All variants of that topology that just alter weigh=\r\nts\nshould maintain the firing order list.  Store the list as part of the\nge=\r\nnome object, for example.  Then, only invalidate the list if you add\na conn=\r\nection or split a connection (or drop a connection).  At which\npoint, recal=\r\nculate the firing order.  Otherwise, save and propagate\nthis firing order t=\r\no all offspring whose topology is unchanged from\nthis one, be they elites o=\r\nr weight mutations or weight-only\ncrossovers.\n\nCan this firing method get i=\r\nrrational results?  Maybe.  But I couldn&#39;t\ntell you under what circumstance=\r\ns.  I&#39;m trying to picture a topology\nwhere the addition of new topology cau=\r\nses a major change in firing\nsequence, but I&#39;m having trouble coming up wit=\r\nh one.  Can anybody else\npicture such a scenario?\n\n-- John\n\n"}}