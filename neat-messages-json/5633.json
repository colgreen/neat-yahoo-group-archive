{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":54567749,"authorName":"Ken","from":"&quot;Ken&quot; &lt;kstanley@...&gt;","profile":"kenstanley01","replyTo":"LIST","senderId":"tD4GXZm1lNXteuYFNKlsvGN38b_rIGfJuaF2ArvRKchxqAMLASXTmJJZyVZ8FlQdBQUppRkxl0r2oDviuDvX3JXIVG_U","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: technical question about custom number of sensors and output nodes","postDate":"1314153129","msgId":5633,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGozMW5yOStrcXRuQGVHcm91cHMuY29tPg==","inReplyToHeader":"PGoyN2JuZCtxZjkzQGVHcm91cHMuY29tPg=="},"prevInTopic":5625,"nextInTopic":5635,"prevInTime":5632,"nextInTime":5634,"topicId":5623,"numMessagesInTopic":7,"msgSnippet":"Hi Arman, nodes.size() is not constant because nodes is a variable-length list, so it can grow or shrink.  Asking for its size just gives the current number of","rawEmail":"Return-Path: &lt;kstanley@...&gt;\r\nX-Sender: kstanley@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 49277 invoked from network); 24 Aug 2011 02:32:10 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m4.grp.sp2.yahoo.com with QMQP; 24 Aug 2011 02:32:10 -0000\r\nX-Received: from unknown (HELO n37b.bullet.mail.sp1.yahoo.com) (66.163.168.151)\n  by mta3.grp.sp2.yahoo.com with SMTP; 24 Aug 2011 02:32:10 -0000\r\nX-Received: from [69.147.65.173] by n37.bullet.mail.sp1.yahoo.com with NNFMP; 24 Aug 2011 02:32:10 -0000\r\nX-Received: from [98.137.34.34] by t15.bullet.mail.sp1.yahoo.com with NNFMP; 24 Aug 2011 02:32:09 -0000\r\nDate: Wed, 24 Aug 2011 02:32:09 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;j31nr9+kqtn@...&gt;\r\nIn-Reply-To: &lt;j27bnd+qf93@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;Ken&quot; &lt;kstanley@...&gt;\r\nSubject: Re: technical question about custom number of sensors and output nodes\r\nX-Yahoo-Group-Post: member; u=54567749; y=XFMoJPD1Zsg4-NrspstZzDu5T9frd0130QkKadbvU5t4E9t9-NZO\r\nX-Yahoo-Profile: kenstanley01\r\n\r\n\n\nHi Arman, nodes.size() is not constant because nodes is a variable-length=\r\n list, so it can grow or shrink.  Asking for its size just gives the curren=\r\nt number of nodes in the list.  The &quot;inlist&quot; and &quot;outlist&quot; (lists of inputs=\r\n and outputs internally generated by NEAT) work the same way, so they too c=\r\nan change.  Therefore, in principle, I believe that your idea should be fea=\r\nsible.  However, you need to make sure that if you ever add new inputs that=\r\n those new nodes have the right flags marking them as input nodes and senso=\r\nrs.\n\nThere used to be a tutorial that comes with NEAT that explained the fi=\r\nle format, but it gone out of date as NEAT was updated, so I believe unfort=\r\nunately it&#39;s no longer included.  Let me try to explain a little:\n\nTraits a=\r\nre reserved for special genetic information that nodes or connections can p=\r\noint to.  They are not used in most NEAT experiments.  I believe you just n=\r\need one dummy trait in a genome file trait but it won&#39;t be used.\n\nnode 1 0 =\r\n1 1\n\nThe first number is the node ID #, the second is the trait pointer (wh=\r\nich can be left at zero), the third says whether the node is NEURON/SENSOR =\r\n(0,1), and the fourth is HIDDEN/INPUT/OUTPUT/BIAS (0,1,2,3).  It&#39;s true tha=\r\nt the third and fourth numbers are a little confusing because they seem to =\r\nbe about a similar issue, but that is how they are defined.\n\ngene 1 1 5 0.0=\r\n 0 1 0 1\n\nThe parameters are: trait # (not usually used), in_node id, out_n=\r\node id, weight, is_recurrent flag, innovation_num, mutation_num, and enable=\r\n flag.\n\nNote that mutation_num is generally set the same as the weight and =\r\ndoes not have a real specific use in NEAT.\n\nAs you may notice some paramete=\r\nrs seem unnecessary or redundant, but I initially created this format befor=\r\ne I was sure about everything that would be needed and the legacy parameter=\r\ns stuck around, which unfortunately can be confusing.\n\nken\n\n--- In neat@yah=\r\noogroups.com, &quot;arman.schwarz&quot; &lt;arman.schwarz@...&gt; wrote:\n&gt;\n&gt; \n&gt; \n&gt; Thanks K=\r\nen,\n&gt; \n&gt; I think I understand what you mean. So when a new genome is create=\r\nd, NEAT will search through the &quot;nodes&quot; vector to look for candidates. The =\r\nnodes vector in turn is generated initially by what it finds in the call to=\r\n this function during the initial creation of the population:\n&gt; \n&gt; Genome::=\r\nGenome(int id, std::ifstream &iFile)\n&gt; \n&gt; Does this mean that nodes.size() =\r\nis constant and initially constrained to what is given in the genome start =\r\nfile, or does can it adapt depending on the size of the array passed to the=\r\n &quot;load_sensors&quot; function?\n&gt; \n&gt; The reason I ask is because I have about 200=\r\n inputs, and I would like to create a start file which simply takes the fir=\r\nst input as output, and tries to improve based on that, preferably allowing=\r\n me to use any number of inputs with a single genome start file. Can I do t=\r\nhat without destroying NEAT&#39;s ability to recognise the existence of all the=\r\n sensors?\n&gt; \n&gt; I&#39;m also somewhat confused about the format of those start f=\r\niles, is there any documentation for these files that I can learn from, or =\r\nwill I just need to look through the source code? I understand NEAT&#39;s conce=\r\npt of bias nodes, but not so much the idea of &quot;traits&quot;, so it would be nice=\r\n to know if any documentation does exist.\n&gt; \n&gt; Thanks again for your help.\n=\r\n&gt; Arman\n&gt; \n&gt; --- In neat@yahoogroups.com, &quot;Ken&quot; &lt;kstanley@&gt; wrote:\n&gt; &gt;\n&gt; &gt; =\r\n\n&gt; &gt; \n&gt; &gt; Hi Arman, from what you wrote I think you understand how to pass =\r\nin and read out the input and output arrays.  I think the main question you=\r\n are asking is how it knows how long those arrays are.\n&gt; &gt; \n&gt; &gt; The answer =\r\nis that rtNEAT (or plain NEAT) C++ counts the number of inputs and number o=\r\nf outputs when it creates a neural network from a genome, which happens in =\r\nthe method \n&gt; &gt; \n&gt; &gt; Network *Genome::genesis(int id)\n&gt; &gt; \n&gt; &gt; When it crea=\r\ntes the network, it creates separate lists of inputs, hidden nodes, and out=\r\nputs, as you can see here:\n&gt; &gt; \n&gt; &gt;                 //Check for input or ou=\r\ntput designation of node\n&gt; &gt;                 if (((*curnode)-&gt;gen_node_labe=\r\nl)=3D=3DINPUT)\n&gt; &gt;                         inlist.push_back(newnode);\n&gt; &gt;  =\r\n               if (((*curnode)-&gt;gen_node_label)=3D=3DBIAS)\n&gt; &gt;             =\r\n            inlist.push_back(newnode);\n&gt; &gt;                 if (((*curnode)-=\r\n&gt;gen_node_label)=3D=3DOUTPUT)\n&gt; &gt;                         outlist.push_back=\r\n(newnode);\n&gt; &gt; \n&gt; &gt; Then it knows how many inputs there are and how many ou=\r\ntputs there are because it knows how long those lists are.\n&gt; &gt; \n&gt; &gt; Going b=\r\nack further in the chain, usually the first place this issue will ultimatel=\r\ny be specified is in the starter genome file, which is usually the origin o=\r\nf the genome data structures (which are created from this file).  Here is a=\r\n pole balancing starter genome:\n&gt; &gt; \n&gt; &gt; genomestart 1\n&gt; &gt; trait 1 0.1 0 0 =\r\n0 0 0 0 0\n&gt; &gt; node 1 0 1 1\n&gt; &gt; node 2 0 1 1\n&gt; &gt; node 3 0 1 1\n&gt; &gt; node 4 0 1=\r\n 3\n&gt; &gt; node 5 0 0 2\n&gt; &gt; gene 1 1 5 0.0 0 1 0 1\n&gt; &gt; gene 1 2 5 0.0 0 2 0 1\n&gt;=\r\n &gt; gene 1 3 5 0.0 0 3 0 1\n&gt; &gt; gene 1 4 5 0.0 0 4 0 1\n&gt; &gt; genomeend 1\n&gt; &gt; \n&gt;=\r\n &gt; Here the numerical codes next the nodes specify what type of nodes they =\r\nare.  In this case, there are 4 inputs (one is a bias) and 1 output.  These=\r\n codes are defined in nnode.h:\n&gt; &gt; \n&gt; &gt;         enum nodetype {\n&gt; &gt;        =\r\n         NEURON =3D 0,\n&gt; &gt;                 SENSOR =3D 1\n&gt; &gt;         };\n&gt; &gt; =\r\n\n&gt; &gt;         enum nodeplace {\n&gt; &gt;                 HIDDEN =3D 0,\n&gt; &gt;        =\r\n         INPUT =3D 1,\n&gt; &gt;                 OUTPUT =3D 2,\n&gt; &gt;                =\r\n BIAS =3D 3\n&gt; &gt;         };\n&gt; &gt; \n&gt; &gt; So usually that is from where NEAT ulti=\r\nmately ends up knowing these counts.  I hope that helps answer your questio=\r\nn.\n&gt; &gt; \n&gt; &gt; ken\n&gt; &gt; \n&gt; &gt; \n&gt; &gt; --- In neat@yahoogroups.com, &quot;arman.schwarz&quot; =\r\n&lt;arman.schwarz@&gt; wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; hi everyone, \n&gt; &gt; &gt; I am currently tryi=\r\nng to apply timeseries prediction to the rtNEAT c++ package, to compare its=\r\n search performance to a fixed-size, evolving topology recurrent neural net=\r\n I wrote.\n&gt; &gt; &gt; \n&gt; &gt; &gt; I have written a custom experiments.h/cpp file to cy=\r\ncle through the activate() function for every time step, after loading an a=\r\nrray of ~75 sensor inputs.\n&gt; &gt; &gt; \n&gt; &gt; &gt; So while I understand how to load t=\r\nhe inputs and retrieve the outputs, I don&#39;t quite understand how I am suppo=\r\nsed to tell NEAT how many inputs and outputs there are. after all, that arr=\r\nay I&#39;m passing to load_sensor is nothing more than a pointer to a value.\n&gt; =\r\n&gt; &gt; \n&gt; &gt; &gt; so where do I tell NEAT how many inputs I will give each net, an=\r\nd how many outputs I will be expecting? (in my RNN the outputs were simply =\r\nthe last x neurons, but the inputs do need to be defined).\n&gt; &gt; &gt; \n&gt; &gt; &gt; tha=\r\nnks in advance for the help!\n&gt; &gt; &gt;\n&gt; &gt;\n&gt;\n\n\n\n"}}