{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":190115458,"authorName":"ze_dakster","from":"&quot;ze_dakster&quot; &lt;drew.kirkpatrick@...&gt;","profile":"ze_dakster","replyTo":"LIST","senderId":"niDHHMSj4FjtLjSZ_vjb3hP3xur3m7ULjZrOSe0L8v06ocOo-RX2pozcGVVDLs30l10OjJp5HKUEvz_eG4UbkxjMUMX1JQyCL_TaCQG-MoE","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: Problems with competitive coevolution implementation","postDate":"1319401178","msgId":5661,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGo4MXNzcSszYmc2QGVHcm91cHMuY29tPg==","inReplyToHeader":"PENBRmNVUFFaWi0xeTZSMFpNTVEwa1o0djlIVVU3UUt2S0hmNEFQVXFoSDJfWl9HaFlFd0BtYWlsLmdtYWlsLmNvbT4="},"prevInTopic":5660,"nextInTopic":5695,"prevInTime":5660,"nextInTime":5662,"topicId":5660,"numMessagesInTopic":4,"msgSnippet":"Well, I think I m onto at least one major problem, the use of the best fitness ever comparisons in the Cga class. While this would work for standard NEAT, in","rawEmail":"Return-Path: &lt;drew.kirkpatrick@...&gt;\r\nX-Sender: drew.kirkpatrick@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 91108 invoked from network); 23 Oct 2011 20:19:41 -0000\r\nX-Received: from unknown (98.137.34.45)\n  by m13.grp.sp2.yahoo.com with QMQP; 23 Oct 2011 20:19:41 -0000\r\nX-Received: from unknown (HELO n45b.bullet.mail.sp1.yahoo.com) (66.163.168.159)\n  by mta2.grp.sp2.yahoo.com with SMTP; 23 Oct 2011 20:19:41 -0000\r\nX-Received: from [69.147.65.150] by n45.bullet.mail.sp1.yahoo.com with NNFMP; 23 Oct 2011 20:19:41 -0000\r\nX-Received: from [98.137.34.119] by t7.bullet.mail.sp1.yahoo.com with NNFMP; 23 Oct 2011 20:19:41 -0000\r\nDate: Sun, 23 Oct 2011 20:19:38 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;j81ssq+3bg6@...&gt;\r\nIn-Reply-To: &lt;CAFcUPQZZ-1y6R0ZMMQ0kZ4v9HUU7QKvKHf4APUqhH2_Z_GhYEw@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;ze_dakster&quot; &lt;drew.kirkpatrick@...&gt;\r\nSubject: Re: Problems with competitive coevolution implementation\r\nX-Yahoo-Group-Post: member; u=190115458; y=E79qEVNeHl_00fOs4qdZclq23Fe--_kLl2M5vm2Z-WYf7BbYTLbJP0mq_JdLo3vRPvF6u_N4Dzf9cM4\r\nX-Yahoo-Profile: ze_dakster\r\n\r\nWell, I think I&#39;m onto at least one major problem, the use of the &quot;best fit=\r\nness ever&quot; comparisons in the Cga class. While this would work for standard=\r\n NEAT, in a competitive environment where fitness is relative, these compar=\r\nisons don&#39;t make sense. \n\nMaybe I should not be doing this, or reset it eve=\r\nr generation. Perhaps use a &quot;best fitness this generation&quot; instead. I&#39;ll ha=\r\nve to ponder and go back over the original paper. \n\nAny other tips are welc=\r\nome :)\n\n-Drew\n\n--- In neat@yahoogroups.com, Drew Kirkpatrick &lt;drew.kirkpatr=\r\nick@...&gt; wrote:\n&gt;\n&gt; I&#39;m in the process of working on an experiment in compe=\r\ntitive\n&gt; coevolution for my MS thesis work. My first step is to recreate\n&gt; =\r\n(relatively closely) Ken Stanley&#39;s original competitive coevolution\n&gt; robot=\r\n duel experiment, which is where I am at now. This is my first\n&gt; real proje=\r\nct with NEAT, so I&#39;m probably messing up some pretty basic\n&gt; stuff.\n&gt; \n&gt; No=\r\nw that I can run the experiment, I&#39;m seeing my first problems. I&#39;m\n&gt; not se=\r\neing nearly enough complexification compared to the original\n&gt; experiment. =\r\nI figure a good chunk of that is my parameters need\n&gt; tweaking, but I could=\r\n also be missing something essential in my\n&gt; implementation.\n&gt; \n&gt; I have 10=\r\n runs, and all seemed to do rather poorly:\n&gt; Average of 7.9 dominant strate=\r\ngies\n&gt; Final dominant strategies have an average of 0.3 hidden nodes\n&gt; Fina=\r\nl dominant strategies have an average of 43.6 connections\n&gt; \n&gt; Similarly to=\r\n Ken&#39;s original experiment, I have 500 generations, with\n&gt; two teams (red a=\r\nnd blue) with 256 robots per team. Each generation\n&gt; each robot competes in=\r\n 24 matches (both left and right starts against\n&gt; 4 best agents from the ot=\r\nher team, and 8 randomly selected\n&gt; hall-of-famers).\n&gt; \n&gt; The team champs c=\r\nompete in a tournament against each other to figure\n&gt; out which is the gene=\r\nration champ. I differ slightly from the original\n&gt; experiment as I only ha=\r\nve them compete in 158 matches (79 food\n&gt; configurations, with both left an=\r\nd right starts). If they tie, I\n&gt; randomly select one to be the generation =\r\nchamp (not sure if this is\n&gt; how it wad done in the original experiment).\n&gt;=\r\n \n&gt; The generation champ them plays all prior dominant strategies in the\n&gt; =\r\nsame style tournament, and if it defeats them all, it is the newest\n&gt; domin=\r\nant strategy (ties are counted as a loss, not sure if this is the\n&gt; same as=\r\n the original experiment).\n&gt; \n&gt; My implementation is highly multi-threaded,=\r\n written in C++ for Linux\n&gt; (I have lots of multicore linux boxes I can use=\r\n at work). The\n&gt; underlying NEAT implementation is basically a Linux port o=\r\nf Mat\n&gt; Buckland&#39;s implementation from his gaming AI book, extended a bit h=\r\nere\n&gt; and there, particularly to support neural net duplication to support\n=\r\n&gt; safe multi-threading.\n&gt; \n&gt; All the experimental stuff is in the\n&gt; competi=\r\ntiveCoevolutionNeatMain.cpp file. There are two threads defined\n&gt; in there,=\r\n the runJobManagerThread (of which only 1 is run), and the\n&gt; runExecutionTh=\r\nread (of which any number will run based on parameters).\n&gt; All the NEAT stu=\r\nff is encapsulated in classes, with most work going\n&gt; through the higher le=\r\nvel Cga class.\n&gt; \n&gt; I&#39;m attaching a tarball of my source code (it&#39;s a work =\r\nin progress and\n&gt; pretty rough), and my spreadsheet with my 10 run results =\r\n(summary\n&gt; sheet, and then a sheet for each run with the name of the machin=\r\ne I\n&gt; used).\n&gt; \n&gt; All the data in the spreadsheet is from the .csv files in=\r\n the\n&gt; dataFiles directory in the tarball.\n&gt; \n&gt; \n&gt; Parameters are found in =\r\nthe parameters.h file, but here are the values\n&gt; I&#39;m using:\n&gt; const int    =\r\nparam_numAgents                        =3D 256;\n&gt; const int    param_numTic=\r\nks                           =3D 750;\n&gt; const int    param_maxNumGeneration=\r\ns           =3D 500;\n&gt; \n&gt; const int    param_numBestAgentsPerTeam     =3D 4=\r\n;\n&gt; const int    param_numHallOfFamers                =3D 8;\n&gt; \n&gt; const int=\r\n    param_numInputs                           =3D 13;\n&gt; const int    param_=\r\nnumOutputs                        =3D 3;\n&gt; const int    param_maxPermittedN=\r\neurons         =3D 2000;\n&gt; const int    param_numTrysToFindOldLink        =\r\n=3D 5;\n&gt; const int    param_numTrysToFindLoopedLink   =3D 5;\n&gt; const int   =\r\n param_numAddLinkAttempts          =3D 5;\n&gt; \n&gt; const int    param_numGensAl=\r\nlowedNoImprovement =3D 30;\n&gt; const int    param_youngBonusAgeThreshold     =\r\n      =3D 10;\n&gt; const int    param_oldAgeThreshold                         =\r\n=3D 50;\n&gt; const double param_youngFitnessBonus                 =3D 1.3;\n&gt; c=\r\nonst double param_oldAgePenalty                         =3D 0.7;\n&gt; const do=\r\nuble param_survivalRate                             =3D 0.2;\n&gt; \n&gt; // Mutati=\r\non stuff\n&gt; const double param_crossoverRate                          =3D 0.=\r\n7;\n&gt; const double param_chanceAddNode                      =3D 0.01;\n&gt; cons=\r\nt double param_chanceAddLink                       =3D 0.1;\n&gt; const double =\r\nparam_chanceAddRecurrentLink          =3D 0.05;\n&gt; const double param_mutati=\r\nonRate                           =3D 0.8;\n&gt; const double param_probabilityW=\r\neightReplaced       =3D 0.1;\n&gt; const double param_maxWeightPerturbation    =\r\n        =3D 0.9;\n&gt; const double param_activationMutationRate             =\r\n=3D 0.1;\n&gt; const double param_maxActivationPerturbation        =3D 0.1;\n&gt; \n=\r\n&gt; \n&gt; // Compatibility calculation parameters\n&gt; const double param_mExcess  =\r\n                    =3D 1.0; // C1\n&gt; const double param_mDisjoint          =\r\n            =3D 1.0; // C2\n&gt; const double param_mMatched                   =\r\n =3D 2.0; // C3\n&gt; \n&gt; // Can be overridden using Cga::SetCompatibilityThresh=\r\nold for dynamic use\n&gt; const double param_compatibilityThreshold      =3D 3.=\r\n0;\n&gt; \n&gt; // If using dynamic compatibility thresholds,\n&gt; // Cga will use the=\r\nse parameters as a minimum\n&gt; // and maximum\n&gt; const double param_minCompati=\r\nbilityThreshold   =3D   0.1;\n&gt; const double param_maxCompatibilityThreshold=\r\n   =3D 500.0;\n&gt; \n&gt; // If using dynamic compatibility thresholds, here&#39;s\n&gt; /=\r\n/ a convenient place to stash the target number\n&gt; // of species. Dynamic ch=\r\nanging of compatibility\n&gt; // threshold is NOT handled by the Cga class,\n&gt; /=\r\n/ you need to handle that in your own code\n&gt; const int    param_targetNumSp=\r\necies            =3D 10;\n&gt; \n&gt; \n&gt; // For tournaments, this is the number of\n=\r\n&gt; // results the job manager will look to\n&gt; // indicate that all tournament=\r\n results\n&gt; // are in\n&gt; // This number is half of the number of\n&gt; // tournam=\r\nent evals, since left and right\n&gt; // start results are lumped together.\n&gt; c=\r\nonst int    param_numTournamentResultRecords =3D 79;\n&gt; \n&gt; \n&gt; \n&gt; // Parallel=\r\nl processing parameters:\n&gt; // Number of execution processes to\n&gt; // use for=\r\n evaluations.\n&gt; const int    param_numExecutionThreads         =3D 9;\n&gt; \n&gt; =\r\n// How many jobs the execution threads will snag\n&gt; // at once from global j=\r\nob queue\n&gt; const int    param_numJobsToLoad               =3D 30;\n&gt; \n&gt; \n&gt; /=\r\n/ The port number the tcp network server will listen on\n&gt; const int    para=\r\nm_networkPort                 =3D 7474;\n&gt; \n&gt; \n&gt; No doubt I need to tweak my=\r\n parameters, but I&#39;m wondering if my\n&gt; implementation is missing something =\r\nessential from the original one.\n&gt; \n&gt; \n&gt; Any tips from the NEAT gurus out t=\r\nhere would be *most* appreciated,\n&gt; It&#39;s taken me far longer to get to this=\r\n point than I imagined, and I&#39;m\n&gt; quickly running short of time to finish m=\r\ny thesis.\n&gt; \n&gt; \n&gt; -Drew Kirkpatrick\n&gt;\n\n\n\n"}}