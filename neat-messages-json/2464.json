{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":127853030,"authorName":"Colin Green","from":"Colin Green &lt;cgreen@...&gt;","profile":"alienseedpod","replyTo":"LIST","senderId":"C0VLUpvSTPfEXLnrFVprFHa_58_NXNIfsx7UI5y8aQU4Gdt8hxp6h-FYgtIpzASzR-oC31h7OHI_QURIjZx63Z4HUYyN_7zyGg","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Terminology - Genome/Phenome super system","postDate":"1133907846","msgId":2464,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQzOTYwRjg2LjUwNzA5MDlAZHNsLnBpcGV4LmNvbT4=","inReplyToHeader":"PDYuMi4zLjQuMC4yMDA1MTIwNjExMTkyNi4wMzNiMmVlMEBwb3AubWFpbC55YWhvby5jby51az4=","referencesHeader":"PDQzOTM2QUNCLjMwOTAxQGRzbC5waXBleC5jb20+IDw2LjIuMy40LjAuMjAwNTEyMDUxMTU2NTcuMDMzYWZjMzhAcG9wLm1haWwueWFob28uY28udWs+IDw0Mzk0QTlGNi44MDAwNTA2QGRzbC5waXBleC5jb20+IDw2LjIuMy40LjAuMjAwNTEyMDYxMTE5MjYuMDMzYjJlZTBAcG9wLm1haWwueWFob28uY28udWs+"},"prevInTopic":2463,"nextInTopic":2465,"prevInTime":2463,"nextInTime":2465,"topicId":2451,"numMessagesInTopic":11,"msgSnippet":"First up, thanks Philip, Ken and Ian for your comments so far. It s becoming apparent that I didn t know quite what I was trying to achieve when I started the","rawEmail":"Return-Path: &lt;cgreen@...&gt;\r\nX-Sender: cgreen@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 57374 invoked from network); 6 Dec 2005 22:24:17 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m33.grp.scd.yahoo.com with QMQP; 6 Dec 2005 22:24:17 -0000\r\nReceived: from unknown (HELO astro.systems.pipex.net) (62.241.163.6)\n  by mta1.grp.scd.yahoo.com with SMTP; 6 Dec 2005 22:24:16 -0000\r\nReceived: from [10.0.0.10] (81-86-161-87.dsl.pipex.com [81.86.161.87])\n\tby astro.systems.pipex.net (Postfix) with ESMTP id 57CFEE00031B\n\tfor &lt;neat@yahoogroups.com&gt;; Tue,  6 Dec 2005 22:24:04 +0000 (GMT)\r\nMessage-ID: &lt;43960F86.5070909@...&gt;\r\nDate: Tue, 06 Dec 2005 22:24:06 +0000\r\nUser-Agent: Mozilla Thunderbird 1.0.7 (Windows/20050923)\r\nX-Accept-Language: en-us, en\r\nMIME-Version: 1.0\r\nTo: neat@yahoogroups.com\r\nReferences: &lt;43936ACB.30901@...&gt; &lt;6.2.3.4.0.20051205115657.033afc38@...&gt; &lt;4394A9F6.8000506@...&gt; &lt;6.2.3.4.0.20051206111926.033b2ee0@...&gt;\r\nIn-Reply-To: &lt;6.2.3.4.0.20051206111926.033b2ee0@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0\r\nFrom: Colin Green &lt;cgreen@...&gt;\r\nSubject: Re: [neat] Terminology - Genome/Phenome super system\r\nX-Yahoo-Group-Post: member; u=127853030; y=t3tqSZuk_iH89ttwzPFfZc166p9SPS6QwqRWSMMdk5pqALkyzEi0\r\nX-Yahoo-Profile: alienseedpod\r\n\r\nFirst up, thanks Philip, Ken and Ian for your comments so far. It&#39;s \nbecoming apparent that I didn&#39;t know quite what I was trying to achieve \nwhen I started the thread, but I&#39;m getting a clearer picture now.\n\nI need to reduce the level of abstraction a tad by defining a phenome as \nbeing something that (line an ANN) has a fixed number of inputs, outputs \nand that can be activated to generate a set of outputs from the inputs. \nSo the phenome becomes a black box with some functionality in it and an \nANN happens to be one possible way of describing the functionality \nwithin the box.\n\nAll that fitness functions do then is evaluate the fitness of the black \nbox, or boxes in the case of co-evolution. This keeps the fitness \nfunctions seperated from specific genome/phenome class implementations \nas Philip was saying.\n\nIan Badcoe wrote:\n\n&gt;\tIt sounds to me that the only way in which different implementations \n&gt;of IGenome would be related is that they have to display a small set \n&gt;of standard functions for the evolution algorithm to operate \n&gt;on.  Everything else about them is custom.\n&gt;  \n&gt;\nYeh the common functions are things like CreateOffspring() or Mutate(), \nthe actual &#39;guts&#39; of the genome are going to be specific to each genome \nclass.\n\n&gt;\tSimilarly, the only relationship between different iPhenomes is that \n&gt;the fitness function has to understand them, but since the fitness \n&gt;functions are custom anyway (needing to be written afresh for each \n&gt;problem) that doesn&#39;t necessarily translate into any degree of \n&gt;relatedness at all, with the exception of needing a common anonymous \n&gt;pointer type for the algorithm to hand over to the fitness function.\n&gt;  \n&gt;\nBut if we take the black box approach as described above then we have \nour IPhenome that all fitness functions can understand. Admittedly it&#39;s \na huge step backwards in terms of the level of abstraction. Anyway lets \nkeep the idea going...\n\n&gt;--\n&gt;\n&gt;On this basis, if I were doing it in C++, my first thought would be templates:\n&gt;\n&gt;template class NEAT&lt;typename GType, typename PType, typename FitnessType&gt; {\n&gt;...\n&gt;};\n&gt;\n&gt;\t- where FitnessType would be a pure abstract class that defined a \n&gt;static fitness function (you can pass functions as template \n&gt;arguments, but it has a history of weirdness in some compilers so \n&gt;it&#39;s not my habit to do it).\n&gt;\n&gt;\tThe types used for GType and PType would be constrained only in \n&gt;needed to exhibit certain public methods so that NEAT could operate \n&gt;on it.  If you have multiple algorithms, and if they shared enough of \n&gt;the way they were used, then NEAT could be inherited from an abstract \n&gt;base class called something like &quot;Algorithm&quot;...\n&gt;\n&gt;\tI&#39;m not assuming that there is anything that particularly binds a \n&gt;PType to a GType, e.g. you could have a PType:\n&gt;\n&gt;class PT_PlainNeuralNetwork {\n&gt;...\n&gt;};\n&gt;\n&gt;\tAnd two GTypes:\n&gt;\n&gt;class GT_DirectEncoding {\n&gt;...\n&gt;\tpublic:\n&gt;\n&gt;\tPT_PlainNeuralNetwork *Decode() const;\n&gt;};\n&gt;\n&gt;\t- and:\n&gt;\n&gt;class GT_IndirectEncoding {\n&gt;...\n&gt;\tpublic:\n&gt;\n&gt;\tPT_PlainNeuralNetwork *Decode() const;\n&gt;};\n&gt;\n&gt;\tWhen another GType might return a completely unrelated PType...\n&gt;\n&gt;\tOther methods in required in the GType would be to do mutation \n&gt;(possibly taking a standard MutationRates structure; or even a \n&gt;templated one), breeding etc...\n&gt;\n&gt;Thus you would use this:\n&gt;\n&gt;class FT_TravellingSalesmanJokeProblem {\n&gt;\tstatic float AbsFitness(const PT_PlainNeuralNet &phenome);\n&gt;//\tstatic float RelFitness(const PT_PlainNeuralNet &phenome1, const \n&gt;PT_PlainNeuralNet &phenome2);\t\t// not doing coevolution yet\n&gt;};\n&gt;\n&gt;in main() {\n&gt;\tNEAT&lt;GT_DirectEncoding, PT_PlainNeuralNet, \n&gt;FT_TravellingSalesmanJokeProblem&gt; MyNEAT(...);\n&gt;\tMyNeat.Generations(1000000000000);\n&gt;\n&gt;\t...\n&gt;\n&gt;\treturn 0;\n&gt;}\n&gt;\n&gt;--\n&gt;  \n&gt;\nOk so I provide a GType, PType and FitnessType and it&#39;s up to the coder \nsupplying the types to provide 3 types that are compatible with each \nother. So if a GType decodes itself into a PType that the FitnessType \ndoesn&#39;t understand then does this get detected at compile time or does \nit result in a runtime exception?\n\n&gt;\tNow I think C# doesn&#39;t have templates?  \n&gt;\nC# 2.0 and Net 2.0 are now officially released and support &#39;generics&#39;, \nwhich is a similar concept although I understand there are differences - \nbut I have yet to swot up on this aspect of dotnet 2.\n\n&gt;So in that case it may be \n&gt;that the best you can do is to have some abstract base classes for \n&gt;[...]\n&gt;\n&gt;\tTemplates _might_ be better, anyone&#39;s guess really.\n&gt;  \n&gt;\nTime to start scribbling on the back of envelopes again.\n\n&gt;\t[[The problem that I have had with generic schemes of this type in \n&gt;the past, is that the algorithms that you try to crowbar into them \n&gt;differ just a little too much for there to much useful left in the \n&gt;generic framework.\n&gt;\nYes I accept this point. All I can do is think about the types of \nproblem domain I want to support right now (e.g. co-evolution) and \ndesign a system that is flexible enough to support these, but no more \nflexible. The danger in getting too abstract is that the system becomes \ndifficult to understand (Keep it simple!) and therefore maintain and \ndevelop against. So say you end up with some big complex framework that \ncan do everything, but all I want to do is one simple experiment, I&#39;m \njust not going to bother learning how to use the framework, it&#39;s less \nhastle to just hard code my own small algorithm to do what I want.\n\n&gt;  For example, a single run of a search algorithm \n&gt;has certain non-population parameters such as &quot;mutation rate&quot;, \n&gt;&quot;number of species&quot;, &quot;last file saved&quot;, &quot;champion individuals&quot; and \n&gt;what those parameters are differs algorithm to algorithm.  Now you \n&gt;are fine for somewhere to store them, e.g. the NEAT class itself, but \n&gt;what happens when some of the parameters are needed by a Genome (or \n&gt;Phenome), you either have to guess all the ones that will ever be and \n&gt;pass them all to the method call in the Genome, or else hand over \n&gt;some sort of abstract &quot;RunData&quot; struct, whose definition depends on \n&gt;_both_ the Genome and the Algorithm...\n&gt;  \n&gt;\nRight now I pass around references to a &#39;NeatParameters&#39; class and a ref \nto the &#39;EvolutionAlgorithm&#39; class itself - this latter class keeps track \nof and generates IDs (for historic markings etc). Anything new data that \nis needed just gets added to one of these two classes. Of course some of \nthis data is specific to NEAT genomes (historic markings) and not \ngenomes in general.\n\n\n\n&gt;\tI went through this six months ago when I started on SLEAT, and my \n&gt;ultimate conclusion was &quot;this is a prototype, it won&#39;t be generic&quot; :) ]]\n&gt;  \n&gt;\nErr, that&#39;s where I started out too! BTW support for SLEAT or a \nSLEAT-like genome/phenome is on my list. I did some reading on graph \nbased GP recently and my thought&#39;s were drifting towards SLEAT at one point.\n\nCheers all,\n\nColin.\n\n\n\n\n"}}