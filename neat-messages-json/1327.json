{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":115403844,"authorName":"John Arrowwood","from":"&quot;John Arrowwood&quot; &lt;jarrowwx@...&gt;","profile":"jarrowwx","replyTo":"LIST","senderId":"zu5_k8tA42DDDft8Jsv5vpriYj1pijxH9BmBWdzweuRuMAO82oFuETSc2Rqv-61YTIGPZ5YyaMP0-Tbq9K0Mmj4w29pAtEtG00UxT1Tp","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [neat] innovation record","postDate":"1091668620","msgId":1327,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PEJBWTItRjEzaXRsY0tOOW1ZcjEwMDA0M2EwN0Bob3RtYWlsLmNvbT4="},"prevInTopic":1326,"nextInTopic":1340,"prevInTime":1326,"nextInTime":1328,"topicId":1321,"numMessagesInTopic":6,"msgSnippet":"... It really depends on your programming language.  For Perl NEAT, it s no more cumbersome to have 2000000 innovations on record than it is to have 2. Having","rawEmail":"Return-Path: &lt;jarrowwx@...&gt;\r\nX-Sender: jarrowwx@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 27555 invoked from network); 5 Aug 2004 01:17:05 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m21.grp.scd.yahoo.com with QMQP; 5 Aug 2004 01:17:05 -0000\r\nReceived: from unknown (HELO hotmail.com) (65.54.247.13)\n  by mta1.grp.scd.yahoo.com with SMTP; 5 Aug 2004 01:17:05 -0000\r\nReceived: from mail pickup service by hotmail.com with Microsoft SMTPSVC;\n\t Wed, 4 Aug 2004 18:17:01 -0700\r\nReceived: from 67.170.177.71 by by2fd.bay2.hotmail.msn.com with HTTP;\n\tThu, 05 Aug 2004 01:17:00 GMT\r\nX-Originating-Email: [jarrowwx@...]\r\nX-Sender: jarrowwx@...\r\nTo: neat@yahoogroups.com\r\nBcc: \r\nDate: Wed, 04 Aug 2004 18:17:00 -0700\r\nMime-Version: 1.0\r\nContent-Type: text/plain; format=flowed\r\nMessage-ID: &lt;BAY2-F13itlcKN9mYr100043a07@...&gt;\r\nX-OriginalArrivalTime: 05 Aug 2004 01:17:01.0030 (UTC) FILETIME=[E8EEF860:01C47A89]\r\nX-eGroups-Remote-IP: 65.54.247.13\r\nFrom: &quot;John Arrowwood&quot; &lt;jarrowwx@...&gt;\r\nReply-To: john@...\r\nSubject: Re: [neat] innovation record\r\nX-Yahoo-Group-Post: member; u=115403844\r\nX-Yahoo-Profile: jarrowwx\r\n\r\n&gt;From: Colin Green &lt;cgreen@...&gt;\n\n&gt; &gt;And whenever a new one (topology, node) is created, I always look through \n&gt;a\n&gt; &gt;hash record to see if it is a duplicate of one created earlier.  If it \n&gt;is, I\n&gt; &gt;re-use the old ID, which makes things a lot easier.  You may or may not \n&gt;want\n&gt; &gt;to do that, but I suggest that it will simplify the search, if not the \n&gt;code.\n&gt; &gt;  And if you are coding in a language that makes the hash lookup easy, \n&gt;then\n&gt; &gt;it&#39;s even easy in the code.\n&gt; &gt;\n&gt; &gt;\n&gt;\n&gt;I suppose it depends on the implementation but keeping track of ALL\n&gt;innovations might become cumbersome during a long run. Perhaps then you\n&gt;could keep track of a fixed number of innovations. Old innovation\n&gt;records will be discarded as new ones are inserted into the table,\n&gt;effectively creating a First-In/First-Out buffer of innovation records.\n\nIt really depends on your programming language.  For Perl NEAT, it&#39;s no more \ncumbersome to have 2000000 innovations on record than it is to have 2.  \nHaving an effectively unlimited memory doesn&#39;t make the programming any more \ndifficult.  It just increases load-times because the size of the data \nstructure that is persisted to disk gets large.  But if you don&#39;t persist it \nto disk, then it really doesn&#39;t matter.  Until you run out of RAM, anyway...\n\nI suppose that if you wanted to cut costs, you could have it forget those \nthat are extinct.  If you have a node that does not exist in any living \nnetworks, you can forget about it.  Likewise, if you have a topology that \nhas gone extinct, you could forget about that, too.\n\nBut knowing which to delete adds processing time.  And, it means that if a \ntopology is re-invented after it has gone extinct, you won&#39;t know it.  \nWhereas, when I re-invent an extinct topology, I also resurrect the old \nchampion network from that topology.  Which means that the new version of it \nhas a chance to breed with the old champion network.\n\nBut in the end, it probably boils down to whether or not you want to put in \nthe effort, and not on which is &#39;right&#39; or &#39;wrong.&#39;  For Perl NEAT, there \nwas no real effort involved.  The same mechanism used to determine if a \nconnection was already created earlier in that same generation will work \njust as well to determine if it was created 1000 generations ago.  And since \nit is a hash-table lookup, the speed for the lookup doesn&#39;t fall off as the \nnumber of innovations increases.  And it guarantees me that I will know that \nNetwork A and network A&#39; are really the same.  This prevents me from \nspending computational resources on two &#39;different&#39; but functionally \nidentical topologies.\n\nAnd as you know, my problem domain is so huge, every little thing I can do \nto reduce unnecessary computation is &#39;a good thing.&#39;  :)\n\n-- John\n\n\n\n"}}