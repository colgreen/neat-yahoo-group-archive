{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":54567749,"authorName":"Kenneth Stanley","from":"&quot;Kenneth Stanley&quot; &lt;kstanley@...&gt;","profile":"kenstanley01","replyTo":"LIST","senderId":"lt-NvGajV0NxGc48mPsx--NVLk_PrQ8Wa8IVu_wLuqx7ertJh7EKQbTvmXVBFcGDiYbIyW5TSi-9l3cWwp04ulMgPhGnPUU6-uI4c858tXzH","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: multi-agent net inputs","postDate":"1084575834","msgId":781,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGM4M2o4cStmNWEwQGVHcm91cHMuY29tPg==","inReplyToHeader":"PFBpbmUuTE5YLjQuNDQuMDQwNTE0MjMyNDI0MC4xOTQzOC0xMDAwMDBAdGlua3ktd2lua3kuY3MuYmhhbS5hYy51az4="},"prevInTopic":780,"nextInTopic":782,"prevInTime":780,"nextInTime":782,"topicId":780,"numMessagesInTopic":11,"msgSnippet":"Hey Kennon, to answer your first question, dividing the senses into radar arc is the best solution.  An arc can be activated in proportion to how close or how","rawEmail":"Return-Path: &lt;kstanley@...&gt;\r\nX-Sender: kstanley@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 16359 invoked from network); 14 May 2004 23:08:13 -0000\r\nReceived: from unknown (66.218.66.167)\n  by m21.grp.scd.yahoo.com with QMQP; 14 May 2004 23:08:13 -0000\r\nReceived: from unknown (HELO n11.grp.scd.yahoo.com) (66.218.66.66)\n  by mta6.grp.scd.yahoo.com with SMTP; 14 May 2004 23:08:12 -0000\r\nReceived: from [66.218.67.248] by n11.grp.scd.yahoo.com with NNFMP; 14 May 2004 23:03:55 -0000\r\nDate: Fri, 14 May 2004 23:03:54 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;c83j8q+f5a0@...&gt;\r\nIn-Reply-To: &lt;Pine.LNX.4.44.0405142324240.19438-100000@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 4382\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-eGroups-Remote-IP: 66.218.66.66\r\nFrom: &quot;Kenneth Stanley&quot; &lt;kstanley@...&gt;\r\nSubject: Re: multi-agent net inputs\r\nX-Yahoo-Group-Post: member; u=54567749\r\nX-Yahoo-Profile: kenstanley01\r\n\r\nHey Kennon, to answer your first question, dividing the senses into \nradar arc is the best solution.  An arc can be activated in \nproportion to how close or how many other agents are in that arc.  I \nhave used this kind of sensor alot.  It&#39;s nice since it&#39;s egocentric.\n\nAs for a &quot;drop-in&quot; NEAT, you can check all the versions of NEAT that \nare out now, but I don&#39;t know that any are so simple you can just \ndrop them into any code without some coding yourself to hook things \nup.  It shouldn&#39;t be too complicated, even with my code (since you \ndon&#39;t actually have to edit the NEAT code itself).  The one real \nproblem with my code is getting it to compile on different \nplatforms.  But there is a windows version of my code now in the \nfiles section which may be easier, and a lot of people here have \ncompiled it on different platforms, so they may be able to help.\nMy homepage has a list of NEATs that are now available.\n\nken\n\n--- In neat@yahoogroups.com, Kennon Lynn Ballou &lt;msc92klb@c...&gt; \nwrote:\n&gt; hi, i&#39;m making a multi-agent sim thingy where i&#39;m hoping to evolve \nagents \n&gt; that can play tag -- although i seem to remember seeing a paper \nabout this \n&gt; somewhere, but i&#39;m enjoying doing it on my own.\n&gt; \n&gt; the basic idea is to have a finite size area, agents with \n&gt; position/velocity, and at any one time, an &quot;it&quot; - which can change \nif the \n&gt; current It touches another. I figure that this would be an \ninteresting \n&gt; thing to learn, since when an agent is not It they will be trying \nto run \n&gt; away from It, and when they are It they will try to run towards \nanother \n&gt; agent. i want to use competitive co-evolution and NN controllers \n&gt; (eventually using neat, although i&#39;m using a simple \ncrossover+mutation GA \n&gt; with binary tournament selection right now). fitness is the \naverage \n&gt; distance from the target over a certain number of time steps.\n&gt; \n&gt; my first task was just for agents to follow around a moving \ntarget, where \n&gt; their input is a bearing to the target and their outputs is a \nchange to \n&gt; their current x and y velocities - this is basically evolving sin \nand \n&gt; cosine in the network. with a population size of 10, with 5 new \noffspring \n&gt; each turn, it readily solves this problem within a couple hundred \n&gt; generations. even though ive done all sorts of evolutionary \nalgorithms, \n&gt; its still DAMN cool to see the little dots start out moving \nrandomly and \n&gt; then over time start swarming around the target ... hehe this \nstuff is so \n&gt; cool. anyway, i then changed their output to be their new heading \nand \n&gt; velocity, and they also learn how to follow the target fairly \neasily, \n&gt; although now that i think about it since one of the inputs is the \nbearing \n&gt; they pretty much just need to learn to turn to the bearing.\n&gt; \n&gt; anyway, my question is this: what do you use as inputs for \nsomething \n&gt; like the tag \n&gt; problem? i mean \n&gt; i guess \n&gt; technically i could have an input which gives the bearing for each \nother \n&gt; agent and then a binary input whether or not they are It. i don&#39;t \nreally \n&gt; like this, though, because you have to change the number of inputs \nbased \n&gt; on the current number of agents in the simulation. other ideas ive \nhad \n&gt; were to divide the circle around the agent into a discrete number \nof arcs \n&gt; and then flag the inputs that have something in their field of \nvision ... \n&gt; has anyone tried anything with that kind of thing?\n&gt; \n&gt; --\n&gt; \n&gt; a separate question, what is the best solution for a light-weight, \ndrop-in \n&gt; with as little change as possible c++ implementation of neat? hehe \nno \n&gt; offense, \n&gt; Ken, but i saw your code a few years ago - hope you cleaned it up \nsince \n&gt; then :) if there isn&#39;t an existing implementation that has a very \nclean \n&gt; interface, are there any plans to develop one?\n&gt; \n&gt; anyway, i really should be studying for my exams, but i&#39;ve \nconvinced \n&gt; myself that this really is revision -- which, actually, it is, \nsince \n&gt; monday&#39;s exam is neural computation and tuesday&#39;s is nature \ninspired \n&gt; design, so i&#39;m actually using concepts from both of those classes \nin this \n&gt; little system.\n&gt; \n&gt; cheers,\n&gt; -KB-\n&gt; \n&gt; -- \n&gt; --------------------------------------------------------\n&gt;  k e n n o n  b a l l o u\n&gt;  msc natural computation : the university of birmingham \n&gt;  http://studentweb.cs.bham.ac.uk/~msc92klb/             \n&gt; --------------------------------------------------------\n\n\n"}}