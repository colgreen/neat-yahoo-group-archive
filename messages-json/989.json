{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":7192225,"authorName":"Ian Badcoe","from":"Ian Badcoe &lt;ian_badcoe@...&gt;","profile":"ian_badcoe","replyTo":"LIST","senderId":"LioIYN_bs52aZNqITNiBPIvhm7RSOoPk26XQu_a5UrNK7KOq8bxOVcKtuhdDLx_1LA8XyNl6WHbLO6WWyLU7ksM11yTCMKTEMDs","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [neat] Re: Computation Time","postDate":"1086343650","msgId":989,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDYuMS4wLjYuMC4yMDA0MDYwNDEwNDQ0MS4wMjRjOWFiMEBwb3AubWFpbC55YWhvby5jby51az4=","inReplyToHeader":"PGM5bnI1aSs5YjE0QGVHcm91cHMuY29tPg==","referencesHeader":"PDYuMS4wLjYuMC4yMDA0MDYwMzE2NDkzMi4wMjUxMmUzMEBwb3AubWFpbC55YWhvby5jby51az4gPGM5bnI1aSs5YjE0QGVHcm91cHMuY29tPg=="},"prevInTopic":982,"nextInTopic":990,"prevInTime":988,"nextInTime":990,"topicId":845,"numMessagesInTopic":99,"msgSnippet":"... That s also pretty nice. However, conditionals are quite expensive on some modern CPUs (e.g. all non-risk super-scalar things -- like x86 descendants)","rawEmail":"Return-Path: &lt;ian_badcoe@...&gt;\r\nX-Sender: ian_badcoe@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 4327 invoked from network); 4 Jun 2004 10:05:07 -0000\r\nReceived: from unknown (66.218.66.167)\n  by m23.grp.scd.yahoo.com with QMQP; 4 Jun 2004 10:05:07 -0000\r\nReceived: from unknown (HELO smtp001.mail.ukl.yahoo.com) (217.12.11.32)\n  by mta6.grp.scd.yahoo.com with SMTP; 4 Jun 2004 10:05:07 -0000\r\nReceived: from unknown (HELO ian2k.yahoo.co.uk) (ian?badcoe@212.159.73.108 with login)\n  by smtp001.mail.ukl.yahoo.com with SMTP; 4 Jun 2004 10:05:05 -0000\r\nMessage-Id: &lt;6.1.0.6.0.20040604104441.024c9ab0@...&gt;\r\nX-Sender: ian_badcoe@...\r\nX-Mailer: QUALCOMM Windows Eudora Version 6.1.0.6\r\nDate: Fri, 04 Jun 2004 11:07:30 +0100\r\nTo: neat@yahoogroups.com\r\nIn-Reply-To: &lt;c9nr5i+9b14@...&gt;\r\nReferences: &lt;6.1.0.6.0.20040603164932.02512e30@...&gt;\n &lt;c9nr5i+9b14@...&gt;\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;us-ascii&quot;; format=flowed\r\nX-eGroups-Remote-IP: 217.12.11.32\r\nFrom: Ian Badcoe &lt;ian_badcoe@...&gt;\r\nSubject: Re: [neat] Re: Computation Time\r\nX-Yahoo-Group-Post: member; u=7192225\r\nX-Yahoo-Profile: ian_badcoe\r\n\r\nAt 19:37 03/06/2004, you wrote:\n&gt;--- In neat@yahoogroups.com, Ian Badcoe &lt;ian_badcoe@y...&gt; wrote:\n&gt;&lt;snip&gt;\n&gt; &gt; real killers.  So, if I were doing this, I would try to code an\n&gt;activation\n&gt; &gt; function using:\n&gt; &gt;\n&gt; &gt; i) float maths\n&gt; &gt; ii) no loops\n&gt; &gt; iii) minimal terms\n&gt; &gt; iv) no transcendental functions\n&gt; &gt; v) _one_ divide (on the basis that you won&#39;t manage none)\n&gt; &gt;\n&gt; &gt;          But I would want to see profiling results to prove this\n&gt;was a\n&gt; &gt; significant CPU hot spot before putting too much work into it.\n&gt;\n&gt;Unless it&#39;s already been done!  Here is a ready-to-use sigmoid\n&gt;approximator in C, taken from the file neursubs.c of the EvSail\n&gt;package:\n&gt;\n&gt;/* This 4 piece curve is a good sigmoid approximator. */\n&gt;float sigAprox(register float x)  {\n&gt;     register float z;\n&gt;\n&gt;     if(x &lt;= -4.0)\n&gt;         return 0.0;\n&gt;     else if(x &lt;= 0.0) {\n&gt;         z = x + 4.0;\n&gt;         return z*z/32;\n&gt;     }\n&gt;     else if(x &lt; 4.0)  {\n&gt;         z = x - 4.0;\n&gt;         return 1.0 - z*z/32;\n&gt;     }\n&gt;     else\n&gt;         return 1.0;\n&gt;}\n\nThat&#39;s also pretty nice.\n\nHowever, conditionals are quite expensive on some modern CPUs (e.g. all \nnon-risk super-scalar things -- like x86 descendants) because they break \nthe asynchronous pipelining.  The CPU guesses which way the branch will go, \nand starts loading instructions from after the branch, if the branch goes \nthe other way, all that has to be discarded.  Some maths expressions are \nfaster if you evaluate all the parts of a piecewise equation, and multiply \nthem by zero or one according to where in the range they fall -- _some_ \nthat is -- with two divides coming in, that trick would probably not work \nfor you (although a lot of CPUs have two dividers now-a-days so...)\n\nSince you only use the divide some of the time, you might win if most x \nvalues were outside the -4 -&gt; +4 range, because I&#39;d still be dividing out \nthere.  OTOH, the conditionals might slow you right down.\n\nSee Colin&#39;s email below, however, which suggests that this is not the \nrate-limiting step...\n\n(the activation calculation situation is not the acceleration limitation :)\n\n         Ian Badcoe\n\n\n\nLiving@Home - Open Source Evolving Organisms - \nhttp://livingathome.sourceforge.net/\n\n\n\n"}}