{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":190115458,"authorName":"Drew Kirkpatrick","from":"Drew Kirkpatrick &lt;drew.kirkpatrick@...&gt;","profile":"ze_dakster","replyTo":"LIST","senderId":"hX75UjSC_lHn8BSExPOhtxKZo66P9lRQUNFsYhU-35hm9YsgFCulthomSsN4U5VbvV7RB4H0Oc_QKZQp0AOWPQQS-4-EBZwiKjnBVP__JIvNHYwP","spamInfo":{"isSpam":false,"reason":"4"},"subject":"Re: [neat] Re: Problems with competitive coevolution implementation","postDate":"1321891369","msgId":5696,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PENBRmNVUFFiZnEyV2g4NlVMcXRUUEo1Qlg5MnRiTU44eEtkVzNkZW9tZmZoWHUtXzlIUUBtYWlsLmdtYWlsLmNvbT4=","inReplyToHeader":"PGphZHB2dStibWc0QGVHcm91cHMuY29tPg==","referencesHeader":"PGo4MXNzcSszYmc2QGVHcm91cHMuY29tPiA8amFkcHZ1K2JtZzRAZUdyb3Vwcy5jb20+"},"prevInTopic":5695,"nextInTopic":0,"prevInTime":5695,"nextInTime":5697,"topicId":5660,"numMessagesInTopic":4,"msgSnippet":"Ken, Since my last email/post I ve been on a code audit, and have been fixing tons of problems in my own code, and some in the Mat Buckland implementation I","rawEmail":"Return-Path: &lt;drew.kirkpatrick@...&gt;\r\nX-Sender: drew.kirkpatrick@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 24131 invoked from network); 21 Nov 2011 16:03:06 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m2.grp.sp2.yahoo.com with QMQP; 21 Nov 2011 16:03:06 -0000\r\nX-Received: from unknown (HELO mail-gx0-f178.google.com) (209.85.161.178)\n  by mta3.grp.sp2.yahoo.com with SMTP; 21 Nov 2011 16:03:05 -0000\r\nX-Received: by ggnk4 with SMTP id k4so6443574ggn.23\n        for &lt;neat@yahoogroups.com&gt;; Mon, 21 Nov 2011 08:03:05 -0800 (PST)\r\nX-Received: by 10.236.114.195 with SMTP id c43mr20967061yhh.12.1321891385156;\n Mon, 21 Nov 2011 08:03:05 -0800 (PST)\r\nMIME-Version: 1.0\r\nX-Received: by 10.100.241.14 with HTTP; Mon, 21 Nov 2011 08:02:49 -0800 (PST)\r\nIn-Reply-To: &lt;jadpvu+bmg4@...&gt;\r\nReferences: &lt;j81ssq+3bg6@...&gt; &lt;jadpvu+bmg4@...&gt;\r\nDate: Mon, 21 Nov 2011 11:02:49 -0500\r\nMessage-ID: &lt;CAFcUPQbfq2Wh86ULqtTPJ5BX92tbMN8xKdW3deomffhXu-_9HQ@...&gt;\r\nTo: neat@yahoogroups.com\r\nContent-Type: multipart/alternative; boundary=20cf303dda7c71a2b104b240d2cc\r\nX-eGroups-Msg-Info: 2:4:8:0:0\r\nFrom: Drew Kirkpatrick &lt;drew.kirkpatrick@...&gt;\r\nSubject: Re: [neat] Re: Problems with competitive coevolution implementation\r\nX-Yahoo-Group-Post: member; u=190115458; y=qwfCVK7xgQhpD_pBAHeBSD8DaMPNMoBEfv23ESr2L4s2SWU5HtUc_q2CVUkpn_9pFuQqotml1jComUU\r\nX-Yahoo-Profile: ze_dakster\r\n\r\n\r\n--20cf303dda7c71a2b104b240d2cc\r\nContent-Type: text/plain; charset=windows-1252\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\nKen,\n\nSince my last email/post I&#39;ve been on a code audit, and have been fix=\r\ning\ntons of problems in my own code, and some in the Mat Buckland\nimplement=\r\nation I started working from. Things are working much better, but\nstill not=\r\n the level of complexification seen in the original paper, but I\nhave more =\r\nwork to do yet.\n\nI&#39;m not necessarily trying to recreate the original experi=\r\nment, but produce\nsomething representative of objective based neat approach=\r\n in competitive\ncoevolution to compare against when I try using general NCD=\r\n/hamming\ndistance measures of novel behavior in competitive coevolution.\n\nJ=\r\nust this weekend I started my second program that loads saved genomes from\n=\r\na competitive coevolution run into a real-time opengl match system so I can=\r\n\nsee what strategies are actually being developed (my evaluation system run=\r\ns\nabout 2000 matches a second on my 8 core box at work, so I stripped all\nr=\r\nendering out of it to be handled in post-run analysis). Naturally, I&#39;m\nfind=\r\ning new bugs to fix, but the robots are being quite helpful pointing\nout my=\r\n errors with their sometimes entertaining strategies.\n\nStuck at work now, b=\r\nut over the holidays I&#39;ll get back on the thesis work,\nand try out the hall=\r\n-of-fame fix. That makes a lot of sense.\n\nAs for scoring, you&#39;re correct. F=\r\nor the standard matches the host only gets\na point if it wins. Zero if it l=\r\noses, or time expires (750 ticks, or about\n30 seconds in real-time from wha=\r\nt I recall).\n\nIt&#39;s the tournament where it&#39;s possible to have ties since th=\r\nere is no\n&quot;host&quot; or &quot;parasite&quot;, neither competitor gets an advantage (gener=\r\nation\nchamp & dominance tournament matches). If the match ends in the tourn=\r\nament\nwithout either winning, neither gets a point. So I do see ties in\ngen=\r\neration champ tournaments, and when the generation champ takes on the\ndomin=\r\nant strategies.\n\nFor generation champ tournaments, if they do tie, the geno=\r\nme with the\nhighest unadjusted fitness gets the tie breaker. If those are a=\r\nlso tied, I\npick one at random.\n\nI do see a number of dominant strategy mat=\r\nches end in ties of 0-0. This is\nlikely due to the ability to develop a poo=\r\nr/uninteresting strategy based on\nbad game world design, and I&#39;ll be diggin=\r\ng into that more when I polish off\nmy visualization program some more and g=\r\net a better feel for what&#39;s\nhappening.\n\nMy implementation of tournaments cu=\r\nrrently involves 158 matches (different\nfood layouts than your original exp=\r\neriment), although I&#39;m probably going to\nadd more as I see what sort of str=\r\nategies are being developed. Need more\nwork on my rendering program before =\r\nI can really dig into that topic.\n\nI was just thinking this weekend I shoul=\r\nd setup a XOR validation setup just\nfor sanity checking. Probably overkill =\r\nsince I can see that new more\ncomplex strategies are being developed, but p=\r\nrobably a good exercise\nnonetheless if it doesn&#39;t take too much time (gotta=\r\n defend in the Spring\nsemester, and job-work is unfortunately crazy at the =\r\nsame time).\n\nThanks again for all the help. Can&#39;t promise you won&#39;t hear fr=\r\nom me again\nbefore I defend, but I can promise to post up my results/paper/=\r\nsourcecode\non the board when I&#39;m done.\n\n\n\n-Drew\n\nOn Mon, Nov 21, 2011 at 10=\r\n:16 AM, Ken &lt;kstanley@...&gt; wrote:\n\n&gt; **\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; Hi Drew, sorry =\r\nfor the long time in response. I hope your experiment is\n&gt; going better now=\r\n, but I do have a couple suggestions:\n&gt;\n&gt; First, you mention the &quot;8 randoml=\r\ny selected hall-of-famers.&quot; I would\n&gt; suggest that for a given generation y=\r\nou select the same 8 hall-of-famers\n&gt; for every individual being evaluated.=\r\n In other words, do not select a new\n&gt; random set for every new individual =\r\nbeing evaluated. That will reduce noisy\n&gt; evaluation significantly.\n&gt;\n&gt; Sec=\r\nond, at one point you note that &quot;ties are counted as a loss, not sure\n&gt; if =\r\nthis is the same as the original experiment.&quot; I think you are talking\n&gt; her=\r\ne about how you compute dominance, and I believe this statement is\n&gt; correc=\r\nt. However, how are you treating ties during evaluation itself? It is\n&gt; imp=\r\nortant that ties are also given zero credit there as well. As the\n&gt; origina=\r\nl paper notes:\n&gt;\n&gt; &quot;Host networks received a single fitness point for each =\r\nwin, and no points\n&gt; for losing. If a competition lasted 750 time steps wit=\r\nh no winner, the host\n&gt; received zero points.&quot;\n&gt;\n&gt; It turns out that this r=\r\nule for ties is very important because otherwise\n&gt; you can get a form of co=\r\nllusion in which competing individuals effectively\n&gt; agree not to bother ea=\r\nch other to avoid the penalty of losing without\n&gt; having to try to win.\n&gt;\n&gt;=\r\n Finally, indeed the parameters could be having an important effect.\n&gt; Unfo=\r\nrtunately, I am not an expert in the parameters in Mat Buckland&#39;s\n&gt; version=\r\n of NEAT, but one aspect of parameters that can be significant is\n&gt; how wei=\r\nght mutations occur. The first thing I would do is validate any\n&gt; parameter=\r\n settings in XOR - if that does not work then there is potentially\n&gt; a seri=\r\nous problem. If XOR works, then consider two parameters:\n&gt;\n&gt; -Weight mutati=\r\non rate/proportion (both words are used by different\n&gt; people): The probabi=\r\nlity for a single gene that its weight will be changes.\n&gt;\n&gt; -Weight mutatio=\r\nn power/jiggle (both words are used by different people):\n&gt; The amount by w=\r\nhich a random number between -1.0 and 1.0 is multiplied\n&gt; before it is adde=\r\nd to a weight that is being mutated.\n&gt;\n&gt; These can both have a big effect a=\r\nnd should be considered carefully. You\n&gt; might try proportions between 0.2 =\r\nand 0.8, and powers between 0.25 and 1.5.\n&gt;\n&gt; Good luck,\n&gt;\n&gt; ken\n&gt;\n&gt;\n&gt; --- =\r\nIn neat@yahoogroups.com, &quot;ze_dakster&quot; &lt;drew.kirkpatrick@...&gt; wrote:\n&gt; &gt;\n&gt; &gt;=\r\n Well, I think I&#39;m onto at least one major problem, the use of the &quot;best\n&gt; =\r\nfitness ever&quot; comparisons in the Cga class. While this would work for\n&gt; sta=\r\nndard NEAT, in a competitive environment where fitness is relative,\n&gt; these=\r\n comparisons don&#39;t make sense.\n&gt; &gt;\n&gt; &gt; Maybe I should not be doing this, or=\r\n reset it ever generation. Perhaps\n&gt; use a &quot;best fitness this generation&quot; i=\r\nnstead. I&#39;ll have to ponder and go\n&gt; back over the original paper.\n&gt; &gt;\n&gt; &gt; =\r\nAny other tips are welcome :)\n&gt; &gt;\n&gt; &gt; -Drew\n&gt; &gt;\n&gt; &gt; --- In neat@yahoogroups=\r\n.com, Drew Kirkpatrick &lt;drew.kirkpatrick@&gt; wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; I&#39;m in the pr=\r\nocess of working on an experiment in competitive\n&gt; &gt; &gt; coevolution for my M=\r\nS thesis work. My first step is to recreate\n&gt; &gt; &gt; (relatively closely) Ken =\r\nStanley&#39;s original competitive coevolution\n&gt; &gt; &gt; robot duel experiment, whi=\r\nch is where I am at now. This is my first\n&gt; &gt; &gt; real project with NEAT, so =\r\nI&#39;m probably messing up some pretty basic\n&gt; &gt; &gt; stuff.\n&gt; &gt; &gt;\n&gt; &gt; &gt; Now that=\r\n I can run the experiment, I&#39;m seeing my first problems. I&#39;m\n&gt; &gt; &gt; not seei=\r\nng nearly enough complexification compared to the original\n&gt; &gt; &gt; experiment=\r\n. I figure a good chunk of that is my parameters need\n&gt; &gt; &gt; tweaking, but I=\r\n could also be missing something essential in my\n&gt; &gt; &gt; implementation.\n&gt; &gt; =\r\n&gt;\n&gt; &gt; &gt; I have 10 runs, and all seemed to do rather poorly:\n&gt; &gt; &gt; Average o=\r\nf 7.9 dominant strategies\n&gt; &gt; &gt; Final dominant strategies have an average o=\r\nf 0.3 hidden nodes\n&gt; &gt; &gt; Final dominant strategies have an average of 43.6 =\r\nconnections\n&gt; &gt; &gt;\n&gt; &gt; &gt; Similarly to Ken&#39;s original experiment, I have 500 =\r\ngenerations, with\n&gt; &gt; &gt; two teams (red and blue) with 256 robots per team. =\r\nEach generation\n&gt; &gt; &gt; each robot competes in 24 matches (both left and righ=\r\nt starts against\n&gt; &gt; &gt; 4 best agents from the other team, and 8 randomly se=\r\nlected\n&gt; &gt; &gt; hall-of-famers).\n&gt; &gt; &gt;\n&gt; &gt; &gt; The team champs compete in a tour=\r\nnament against each other to figure\n&gt; &gt; &gt; out which is the generation champ=\r\n. I differ slightly from the original\n&gt; &gt; &gt; experiment as I only have them =\r\ncompete in 158 matches (79 food\n&gt; &gt; &gt; configurations, with both left and ri=\r\nght starts). If they tie, I\n&gt; &gt; &gt; randomly select one to be the generation =\r\nchamp (not sure if this is\n&gt; &gt; &gt; how it wad done in the original experiment=\r\n).\n&gt; &gt; &gt;\n&gt; &gt; &gt; The generation champ them plays all prior dominant strategie=\r\ns in the\n&gt; &gt; &gt; same style tournament, and if it defeats them all, it is the=\r\n newest\n&gt; &gt; &gt; dominant strategy (ties are counted as a loss, not sure if th=\r\nis is the\n&gt; &gt; &gt; same as the original experiment).\n&gt; &gt; &gt;\n&gt; &gt; &gt; My implementa=\r\ntion is highly multi-threaded, written in C++ for Linux\n&gt; &gt; &gt; (I have lots =\r\nof multicore linux boxes I can use at work). The\n&gt; &gt; &gt; underlying NEAT impl=\r\nementation is basically a Linux port of Mat\n&gt; &gt; &gt; Buckland&#39;s implementation=\r\n from his gaming AI book, extended a bit here\n&gt; &gt; &gt; and there, particularly=\r\n to support neural net duplication to support\n&gt; &gt; &gt; safe multi-threading.\n&gt;=\r\n &gt; &gt;\n&gt; &gt; &gt; All the experimental stuff is in the\n&gt; &gt; &gt; competitiveCoevolutio=\r\nnNeatMain.cpp file. There are two threads defined\n&gt; &gt; &gt; in there, the runJo=\r\nbManagerThread (of which only 1 is run), and the\n&gt; &gt; &gt; runExecutionThread (=\r\nof which any number will run based on parameters).\n&gt; &gt; &gt; All the NEAT stuff=\r\n is encapsulated in classes, with most work going\n&gt; &gt; &gt; through the higher =\r\nlevel Cga class.\n&gt; &gt; &gt;\n&gt; &gt; &gt; I&#39;m attaching a tarball of my source code (it&#39;=\r\ns a work in progress and\n&gt; &gt; &gt; pretty rough), and my spreadsheet with my 10=\r\n run results (summary\n&gt; &gt; &gt; sheet, and then a sheet for each run with the n=\r\name of the machine I\n&gt; &gt; &gt; used).\n&gt; &gt; &gt;\n&gt; &gt; &gt; All the data in the spreadshe=\r\net is from the .csv files in the\n&gt; &gt; &gt; dataFiles directory in the tarball.\n=\r\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; Parameters are found in the parameters.h file, but here a=\r\nre the values\n&gt; &gt; &gt; I&#39;m using:\n&gt; &gt; &gt; const int param_numAgents =3D 256;\n&gt; &gt;=\r\n &gt; const int param_numTicks =3D 750;\n&gt; &gt; &gt; const int param_maxNumGeneration=\r\ns =3D 500;\n&gt; &gt; &gt;\n&gt; &gt; &gt; const int param_numBestAgentsPerTeam =3D 4;\n&gt; &gt; &gt; co=\r\nnst int param_numHallOfFamers =3D 8;\n&gt; &gt; &gt;\n&gt; &gt; &gt; const int param_numInputs =\r\n=3D 13;\n&gt; &gt; &gt; const int param_numOutputs =3D 3;\n&gt; &gt; &gt; const int param_maxPe=\r\nrmittedNeurons =3D 2000;\n&gt; &gt; &gt; const int param_numTrysToFindOldLink =3D 5;\n=\r\n&gt; &gt; &gt; const int param_numTrysToFindLoopedLink =3D 5;\n&gt; &gt; &gt; const int param_=\r\nnumAddLinkAttempts =3D 5;\n&gt; &gt; &gt;\n&gt; &gt; &gt; const int param_numGensAllowedNoImpro=\r\nvement =3D 30;\n&gt; &gt; &gt; const int param_youngBonusAgeThreshold =3D 10;\n&gt; &gt; &gt; c=\r\nonst int param_oldAgeThreshold =3D 50;\n&gt; &gt; &gt; const double param_youngFitnes=\r\nsBonus =3D 1.3;\n&gt; &gt; &gt; const double param_oldAgePenalty =3D 0.7;\n&gt; &gt; &gt; const=\r\n double param_survivalRate =3D 0.2;\n&gt; &gt; &gt;\n&gt; &gt; &gt; // Mutation stuff\n&gt; &gt; &gt; con=\r\nst double param_crossoverRate =3D 0.7;\n&gt; &gt; &gt; const double param_chanceAddNo=\r\nde =3D 0.01;\n&gt; &gt; &gt; const double param_chanceAddLink =3D 0.1;\n&gt; &gt; &gt; const do=\r\nuble param_chanceAddRecurrentLink =3D 0.05;\n&gt; &gt; &gt; const double param_mutati=\r\nonRate =3D 0.8;\n&gt; &gt; &gt; const double param_probabilityWeightReplaced =3D 0.1;=\r\n\n&gt; &gt; &gt; const double param_maxWeightPerturbation =3D 0.9;\n&gt; &gt; &gt; const double=\r\n param_activationMutationRate =3D 0.1;\n&gt; &gt; &gt; const double param_maxActivati=\r\nonPerturbation =3D 0.1;\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; // Compatibility calculation para=\r\nmeters\n&gt; &gt; &gt; const double param_mExcess =3D 1.0; // C1\n&gt; &gt; &gt; const double p=\r\naram_mDisjoint =3D 1.0; // C2\n&gt; &gt; &gt; const double param_mMatched =3D 2.0; //=\r\n C3\n&gt; &gt; &gt;\n&gt; &gt; &gt; // Can be overridden using Cga::SetCompatibilityThreshold f=\r\nor dynamic\n&gt; use\n&gt; &gt; &gt; const double param_compatibilityThreshold =3D 3.0;\n&gt;=\r\n &gt; &gt;\n&gt; &gt; &gt; // If using dynamic compatibility thresholds,\n&gt; &gt; &gt; // Cga will =\r\nuse these parameters as a minimum\n&gt; &gt; &gt; // and maximum\n&gt; &gt; &gt; const double p=\r\naram_minCompatibilityThreshold =3D 0.1;\n&gt; &gt; &gt; const double param_maxCompati=\r\nbilityThreshold =3D 500.0;\n&gt; &gt; &gt;\n&gt; &gt; &gt; // If using dynamic compatibility th=\r\nresholds, here&#39;s\n&gt; &gt; &gt; // a convenient place to stash the target number\n&gt; &gt;=\r\n &gt; // of species. Dynamic changing of compatibility\n&gt; &gt; &gt; // threshold is N=\r\nOT handled by the Cga class,\n&gt; &gt; &gt; // you need to handle that in your own c=\r\node\n&gt; &gt; &gt; const int param_targetNumSpecies =3D 10;\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; // For=\r\n tournaments, this is the number of\n&gt; &gt; &gt; // results the job manager will l=\r\nook to\n&gt; &gt; &gt; // indicate that all tournament results\n&gt; &gt; &gt; // are in\n&gt; &gt; &gt; =\r\n// This number is half of the number of\n&gt; &gt; &gt; // tournament evals, since le=\r\nft and right\n&gt; &gt; &gt; // start results are lumped together.\n&gt; &gt; &gt; const int pa=\r\nram_numTournamentResultRecords =3D 79;\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; // Parallell=\r\n processing parameters:\n&gt; &gt; &gt; // Number of execution processes to\n&gt; &gt; &gt; // =\r\nuse for evaluations.\n&gt; &gt; &gt; const int param_numExecutionThreads =3D 9;\n&gt; &gt; &gt;=\r\n\n&gt; &gt; &gt; // How many jobs the execution threads will snag\n&gt; &gt; &gt; // at once fr=\r\nom global job queue\n&gt; &gt; &gt; const int param_numJobsToLoad =3D 30;\n&gt; &gt; &gt;\n&gt; &gt; &gt;=\r\n\n&gt; &gt; &gt; // The port number the tcp network server will listen on\n&gt; &gt; &gt; const=\r\n int param_networkPort =3D 7474;\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; No doubt I need to tweak=\r\n my parameters, but I&#39;m wondering if my\n&gt; &gt; &gt; implementation is missing som=\r\nething essential from the original one.\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; Any tips from the=\r\n NEAT gurus out there would be *most* appreciated,\n&gt; &gt; &gt; It&#39;s taken me far =\r\nlonger to get to this point than I imagined, and I&#39;m\n&gt; &gt; &gt; quickly running =\r\nshort of time to finish my thesis.\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt; -Drew Kirkpatrick\n&gt; &gt; =\r\n&gt;\n&gt; &gt;\n&gt;\n&gt;  \n&gt;\n\r\n--20cf303dda7c71a2b104b240d2cc\r\nContent-Type: text/html; charset=windows-1252\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\nKen,&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Since my last email/post I&#39;ve been on a code au=\r\ndit, and have been fixing tons of problems in my own code, and some in the =\r\nMat Buckland implementation I started working from. Things are working much=\r\n better, but still not the level of complexification seen in the original p=\r\naper, but I have more work to do yet.=A0&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;I&#39;m=\r\n not necessarily trying to recreate the original experiment, but produce so=\r\nmething representative of objective based neat approach in competitive coev=\r\nolution to compare against when I try using general NCD/hamming distance me=\r\nasures of novel behavior in competitive coevolution.=A0&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/d=\r\niv&gt;&lt;div&gt;Just this weekend I started my second program that loads saved geno=\r\nmes from a competitive coevolution run into a=A0real-time=A0opengl match sy=\r\nstem so I can see what strategies are actually being developed (my evaluati=\r\non system runs about 2000 matches a second on my 8 core box at work, so I s=\r\ntripped all rendering out of it to be handled in post-run analysis). Natura=\r\nlly, I&#39;m finding new bugs to fix, but the robots are being quite helpfu=\r\nl pointing out my errors with their sometimes entertaining strategies.=A0&lt;/=\r\ndiv&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Stuck at work now, but over the holidays I&#39;ll=\r\n get back on the thesis work, and try out the hall-of-fame fix. That makes =\r\na lot of sense.=A0&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;As for scoring, you&#39;re corr=\r\nect. For the standard matches the host only gets a point if it wins. Zero i=\r\nf it loses, or time expires (750 ticks, or about 30 seconds in real-time fr=\r\nom what I recall).=A0&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;It&#39;s the tournament wh=\r\nere it&#39;s possible to have ties since there is no &quot;host&quot; or &q=\r\nuot;parasite&quot;, neither=A0competitor=A0gets an advantage (generation ch=\r\namp &amp; dominance tournament matches). If the match ends in the tournamen=\r\nt without either winning, neither gets a point. So I do see ties in generat=\r\nion champ tournaments, and when the generation champ takes on the dominant =\r\nstrategies.=A0&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;For generation champ tournaments,=\r\n if they do tie, the genome with the highest unadjusted fitness gets the ti=\r\ne breaker. If those are also tied, I pick one at random.=A0&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;=\r\n/div&gt;&lt;div&gt;I do see a number of dominant strategy matches end in ties of 0-0=\r\n. This is likely due to the ability to develop a poor/uninteresting strateg=\r\ny based on bad game world design, and I&#39;ll be digging into that more wh=\r\nen I polish off my visualization program some more and get a better feel fo=\r\nr what&#39;s happening.=A0&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;My implementation of =\r\ntournaments currently involves 158 matches (different food layouts than you=\r\nr original experiment), although I&#39;m probably going to add more as I se=\r\ne what sort of strategies are being developed. Need more work on my renderi=\r\nng program before I can really dig into that topic.=A0&lt;/div&gt;\n\n&lt;div&gt;&lt;br&gt;&lt;/di=\r\nv&gt;&lt;div&gt;I was just thinking this weekend I should setup a XOR validation set=\r\nup just for sanity checking. Probably overkill since I can see that new mor=\r\ne complex strategies are being developed, but probably a good exercise none=\r\ntheless if it doesn&#39;t take too much time (gotta defend in the Spring se=\r\nmester, and job-work is unfortunately crazy at the same time).=A0&lt;br&gt;\n\n&lt;br&gt;=\r\nThanks again for all the help. Can&#39;t promise you won&#39;t hear from me=\r\n again before I defend, but I can promise to post up my results/paper/sourc=\r\necode on the board when I&#39;m done.=A0&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;\n\n&lt;/d=\r\niv&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;-Drew&lt;br&gt;&lt;br&gt;&lt;div class=3D&quot;gmail_quote&quot;&gt;On Mon, Nov =\r\n21, 2011 at 10:16 AM, Ken &lt;span dir=3D&quot;ltr&quot;&gt;&lt;&lt;a href=3D&quot;mailto:kstanley@=\r\ncs.utexas.edu&quot;&gt;kstanley@...&lt;/a&gt;&gt;&lt;/span&gt; wrote:&lt;br&gt;&lt;blockquote =\r\nclass=3D&quot;gmail_quote&quot; style=3D&quot;margin:0 0 0 .8ex;border-left:1px #ccc solid=\r\n;padding-left:1ex;&quot;&gt;\n\n\n\n\n&lt;u&gt;&lt;/u&gt;\n\n\n\n\n\n\n\n\n\n\n&lt;div style=3D&quot;background-color:#=\r\nfff&quot;&gt;\n&lt;span&gt;=A0&lt;/span&gt;\n\n\n&lt;div&gt;\n  &lt;div&gt;\n\n\n    &lt;div&gt;\n      \n      \n      &lt;p&gt;&lt;=\r\nbr&gt;\n&lt;br&gt;\nHi Drew, sorry for the long time in response.  I hope your experim=\r\nent is going better now, but I do have a couple suggestions:&lt;br&gt;\n&lt;br&gt;\nFirst=\r\n, you mention the &quot;8 randomly selected hall-of-famers.&quot;  I would =\r\nsuggest that for a given generation you select the same 8 hall-of-famers fo=\r\nr every individual being evaluated.  In other words, do not select a new ra=\r\nndom set for every new individual being evaluated.  That will reduce noisy =\r\nevaluation significantly.  &lt;br&gt;\n\n\n&lt;br&gt;\nSecond, at one point you note that &=\r\nquot;ties are counted as a loss, not sure if this is the same as the origin=\r\nal experiment.&quot;  I think you are talking here about how you compute do=\r\nminance, and I believe this statement is correct.  However, how are you tre=\r\nating ties during evaluation itself?  It is important that ties are also gi=\r\nven zero credit there as well.  As the original paper notes:&lt;br&gt;\n\n\n&lt;br&gt;\n&qu=\r\not;Host networks received a single fitness point for each win, and no point=\r\ns for losing. If a competition lasted 750 time steps with no winner, the ho=\r\nst received zero points.&quot;&lt;br&gt;\n&lt;br&gt;\nIt turns out that this rule for tie=\r\ns is very important because otherwise you can get a form of collusion in wh=\r\nich competing individuals effectively agree not to bother each other to avo=\r\nid the penalty of losing without having to try to win.&lt;br&gt;\n\n\n&lt;br&gt;\nFinally, =\r\nindeed the parameters could be having an important effect.  Unfortunately, =\r\nI am not an expert in the parameters in Mat Buckland&#39;s version of NEAT,=\r\n but one aspect of parameters that can be significant is how weight mutatio=\r\nns occur.  The first thing I would do is validate any parameter settings in=\r\n XOR - if that does not work then there is potentially a serious problem.  =\r\nIf XOR works, then consider two parameters:&lt;br&gt;\n\n\n&lt;br&gt;\n-Weight mutation rat=\r\ne/proportion (both words are used by different people): The probability for=\r\n a single gene that its weight will be changes.&lt;br&gt;\n&lt;br&gt;\n-Weight mutation p=\r\nower/jiggle (both words are used by different people): The amount by which =\r\na random number between -1.0 and 1.0 is multiplied before it is added to a =\r\nweight that is being mutated.&lt;br&gt;\n&lt;br&gt;\nThese can both have a big effect and=\r\n should be considered carefully.  You might try proportions between 0.2 and=\r\n 0.8, and powers between 0.25 and 1.5.&lt;br&gt;\n&lt;br&gt;\nGood luck,&lt;br&gt;\n&lt;br&gt;\nken&lt;/p&gt;=\r\n&lt;div class=3D&quot;im&quot;&gt;&lt;br&gt;\n&lt;br&gt;\n--- In &lt;a href=3D&quot;mailto:neat%40yahoogroups.com=\r\n&quot; target=3D&quot;_blank&quot;&gt;neat@yahoogroups.com&lt;/a&gt;, &quot;ze_dakster&quot; &lt;dr=\r\new.kirkpatrick@...&gt; wrote:&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; Well, I think I&#39;m onto =\r\nat least one major problem, the use of the &quot;best fitness ever&quot; co=\r\nmparisons in the Cga class. While this would work for standard NEAT, in a c=\r\nompetitive environment where fitness is relative, these comparisons don&#39=\r\n;t make sense. &lt;br&gt;\n\n\n&gt; &lt;br&gt;\n&gt; Maybe I should not be doing this, or r=\r\neset it ever generation. Perhaps use a &quot;best fitness this generation&q=\r\nuot; instead. I&#39;ll have to ponder and go back over the original paper. =\r\n&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; Any other tips are welcome :)&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; -Drew&lt;=\r\nbr&gt;\n&gt; &lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;div class=3D&quot;h5&quot;&gt;\n&gt; --- In &lt;a href=3D&quot;mailto:ne=\r\nat%40yahoogroups.com&quot; target=3D&quot;_blank&quot;&gt;neat@yahoogroups.com&lt;/a&gt;, Drew Kirk=\r\npatrick &lt;drew.kirkpatrick@&gt; wrote:&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt; &gt; I&#39;=\r\nm in the process of working on an experiment in competitive&lt;br&gt;\n&gt; &gt; c=\r\noevolution for my MS thesis work. My first step is to recreate&lt;br&gt;\n&gt; &gt=\r\n; (relatively closely) Ken Stanley&#39;s original competitive coevolution&lt;b=\r\nr&gt;\n&gt; &gt; robot duel experiment, which is where I am at now. This is my =\r\nfirst&lt;br&gt;\n&gt; &gt; real project with NEAT, so I&#39;m probably messing up =\r\nsome pretty basic&lt;br&gt;\n&gt; &gt; stuff.&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; Now tha=\r\nt I can run the experiment, I&#39;m seeing my first problems. I&#39;m&lt;br&gt;\n&=\r\ngt; &gt; not seeing nearly enough complexification compared to the original=\r\n&lt;br&gt;\n&gt; &gt; experiment. I figure a good chunk of that is my parameters n=\r\need&lt;br&gt;\n&gt; &gt; tweaking, but I could also be missing something essential=\r\n in my&lt;br&gt;\n&gt; &gt; implementation.&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; I have 10=\r\n runs, and all seemed to do rather poorly:&lt;br&gt;\n&gt; &gt; Average of 7.9 dom=\r\ninant strategies&lt;br&gt;\n&gt; &gt; Final dominant strategies have an average of=\r\n 0.3 hidden nodes&lt;br&gt;\n&gt; &gt; Final dominant strategies have an average o=\r\nf 43.6 connections&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; Similarly to Ken&#39;s orig=\r\ninal experiment, I have 500 generations, with&lt;br&gt;\n&gt; &gt; two teams (red =\r\nand blue) with 256 robots per team. Each generation&lt;br&gt;\n&gt; &gt; each robo=\r\nt competes in 24 matches (both left and right starts against&lt;br&gt;\n&gt; &gt; =\r\n4 best agents from the other team, and 8 randomly selected&lt;br&gt;\n&gt; &gt; ha=\r\nll-of-famers).&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; The team champs compete in a to=\r\nurnament against each other to figure&lt;br&gt;\n&gt; &gt; out which is the genera=\r\ntion champ. I differ slightly from the original&lt;br&gt;\n&gt; &gt; experiment as=\r\n I only have them compete in 158 matches (79 food&lt;br&gt;\n&gt; &gt; configurati=\r\nons, with both left and right starts). If they tie, I&lt;br&gt;\n&gt; &gt; randoml=\r\ny select one to be the generation champ (not sure if this is&lt;br&gt;\n&gt; &gt; =\r\nhow it wad done in the original experiment).&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; T=\r\nhe generation champ them plays all prior dominant strategies in the&lt;br&gt;\n&gt=\r\n; &gt; same style tournament, and if it defeats them all, it is the newest&lt;=\r\nbr&gt;\n&gt; &gt; dominant strategy (ties are counted as a loss, not sure if th=\r\nis is the&lt;br&gt;\n&gt; &gt; same as the original experiment).&lt;br&gt;\n&gt; &gt; &lt;br=\r\n&gt;\n&gt; &gt; My implementation is highly multi-threaded, written in C++ for =\r\nLinux&lt;br&gt;\n&gt; &gt; (I have lots of multicore linux boxes I can use at work=\r\n). The&lt;br&gt;\n&gt; &gt; underlying NEAT implementation is basically a Linux po=\r\nrt of Mat&lt;br&gt;\n&gt; &gt; Buckland&#39;s implementation from his gaming AI bo=\r\nok, extended a bit here&lt;br&gt;\n&gt; &gt; and there, particularly to support ne=\r\nural net duplication to support&lt;br&gt;\n&gt; &gt; safe multi-threading.&lt;br&gt;\n&gt=\r\n; &gt; &lt;br&gt;\n&gt; &gt; All the experimental stuff is in the&lt;br&gt;\n&gt; &gt; co=\r\nmpetitiveCoevolutionNeatMain.cpp file. There are two threads defined&lt;br&gt;\n&g=\r\nt; &gt; in there, the runJobManagerThread (of which only 1 is run), and the=\r\n&lt;br&gt;\n&gt; &gt; runExecutionThread (of which any number will run based on pa=\r\nrameters).&lt;br&gt;\n&gt; &gt; All the NEAT stuff is encapsulated in classes, wit=\r\nh most work going&lt;br&gt;\n&gt; &gt; through the higher level Cga class.&lt;br&gt;\n&gt=\r\n; &gt; &lt;br&gt;\n&gt; &gt; I&#39;m attaching a tarball of my source code (it&#39=\r\n;s a work in progress and&lt;br&gt;\n&gt; &gt; pretty rough), and my spreadsheet w=\r\nith my 10 run results (summary&lt;br&gt;\n&gt; &gt; sheet, and then a sheet for ea=\r\nch run with the name of the machine I&lt;br&gt;\n&gt; &gt; used).&lt;br&gt;\n&gt; &gt; &lt;b=\r\nr&gt;\n&gt; &gt; All the data in the spreadsheet is from the .csv files in the&lt;=\r\nbr&gt;\n&gt; &gt; dataFiles directory in the tarball.&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &=\r\ngt; &lt;br&gt;\n&gt; &gt; Parameters are found in the parameters.h file, but here =\r\nare the values&lt;br&gt;\n&gt; &gt; I&#39;m using:&lt;br&gt;\n&gt; &gt; const int    para=\r\nm_numAgents                        =3D 256;&lt;br&gt;\n&gt; &gt; const int    para=\r\nm_numTicks                           =3D 750;&lt;br&gt;\n&gt; &gt; const int    pa=\r\nram_maxNumGenerations           =3D 500;&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; const=\r\n int    param_numBestAgentsPerTeam     =3D 4;&lt;br&gt;\n&gt; &gt; const int    pa=\r\nram_numHallOfFamers                =3D 8;&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; cons=\r\nt int    param_numInputs                           =3D 13;&lt;br&gt;\n&gt; &gt; co=\r\nnst int    param_numOutputs                        =3D 3;&lt;br&gt;\n&gt; &gt; con=\r\nst int    param_maxPermittedNeurons         =3D 2000;&lt;br&gt;\n&gt; &gt; const i=\r\nnt    param_numTrysToFindOldLink        =3D 5;&lt;br&gt;\n&gt; &gt; const int    p=\r\naram_numTrysToFindLoopedLink   =3D 5;&lt;br&gt;\n&gt; &gt; const int    param_numA=\r\nddLinkAttempts          =3D 5;&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; const int    pa=\r\nram_numGensAllowedNoImprovement =3D 30;&lt;br&gt;\n&gt; &gt; const int    param_yo=\r\nungBonusAgeThreshold           =3D 10;&lt;br&gt;\n&gt; &gt; const int    param_old=\r\nAgeThreshold                         =3D 50;&lt;br&gt;\n&gt; &gt; const double par=\r\nam_youngFitnessBonus                 =3D 1.3;&lt;br&gt;\n&gt; &gt; const double pa=\r\nram_oldAgePenalty                         =3D 0.7;&lt;br&gt;\n&gt; &gt; const doub=\r\nle param_survivalRate                             =3D 0.2;&lt;br&gt;\n&gt; &gt; &lt;b=\r\nr&gt;\n&gt; &gt; // Mutation stuff&lt;br&gt;\n&gt; &gt; const double param_crossoverRa=\r\nte                          =3D 0.7;&lt;br&gt;\n&gt; &gt; const double param_chanc=\r\neAddNode                      =3D 0.01;&lt;br&gt;\n&gt; &gt; const double param_ch=\r\nanceAddLink                       =3D 0.1;&lt;br&gt;\n&gt; &gt; const double param=\r\n_chanceAddRecurrentLink          =3D 0.05;&lt;br&gt;\n&gt; &gt; const double param=\r\n_mutationRate                           =3D 0.8;&lt;br&gt;\n&gt; &gt; const double=\r\n param_probabilityWeightReplaced       =3D 0.1;&lt;br&gt;\n&gt; &gt; const double =\r\nparam_maxWeightPerturbation            =3D 0.9;&lt;br&gt;\n&gt; &gt; const double =\r\nparam_activationMutationRate             =3D 0.1;&lt;br&gt;\n&gt; &gt; const doubl=\r\ne param_maxActivationPerturbation        =3D 0.1;&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &=\r\ngt; &lt;br&gt;\n&gt; &gt; // Compatibility calculation parameters&lt;br&gt;\n&gt; &gt; co=\r\nnst double param_mExcess                      =3D 1.0; // C1&lt;br&gt;\n&gt; &gt; =\r\nconst double param_mDisjoint                      =3D 1.0; // C2&lt;br&gt;\n&gt; &=\r\ngt; const double param_mMatched                    =3D 2.0; // C3&lt;br&gt;\n&gt; =\r\n&gt; &lt;br&gt;\n&gt; &gt; // Can be overridden using Cga::SetCompatibilityThresho=\r\nld for dynamic use&lt;br&gt;\n&gt; &gt; const double param_compatibilityThreshold =\r\n     =3D 3.0;&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; // If using dynamic compatibilit=\r\ny thresholds,&lt;br&gt;\n&gt; &gt; // Cga will use these parameters as a minimum&lt;b=\r\nr&gt;\n&gt; &gt; // and maximum&lt;br&gt;\n&gt; &gt; const double param_minCompatibili=\r\ntyThreshold   =3D   0.1;&lt;br&gt;\n&gt; &gt; const double param_maxCompatibilityT=\r\nhreshold   =3D 500.0;&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; // If using dynamic comp=\r\natibility thresholds, here&#39;s&lt;br&gt;\n&gt; &gt; // a convenient place to sta=\r\nsh the target number&lt;br&gt;\n&gt; &gt; // of species. Dynamic changing of compa=\r\ntibility&lt;br&gt;\n&gt; &gt; // threshold is NOT handled by the Cga class,&lt;br&gt;\n&g=\r\nt; &gt; // you need to handle that in your own code&lt;br&gt;\n&gt; &gt; const int=\r\n    param_targetNumSpecies            =3D 10;&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; =\r\n&lt;br&gt;\n&gt; &gt; // For tournaments, this is the number of&lt;br&gt;\n&gt; &gt; // r=\r\nesults the job manager will look to&lt;br&gt;\n&gt; &gt; // indicate that all tour=\r\nnament results&lt;br&gt;\n&gt; &gt; // are in&lt;br&gt;\n&gt; &gt; // This number is half=\r\n of the number of&lt;br&gt;\n&gt; &gt; // tournament evals, since left and right&lt;b=\r\nr&gt;\n&gt; &gt; // start results are lumped together.&lt;br&gt;\n&gt; &gt; const int =\r\n   param_numTournamentResultRecords =3D 79;&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; &lt;b=\r\nr&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; // Parallell processing parameters:&lt;br&gt;\n&gt; &g=\r\nt; // Number of execution processes to&lt;br&gt;\n&gt; &gt; // use for evaluations=\r\n.&lt;br&gt;\n&gt; &gt; const int    param_numExecutionThreads         =3D 9;&lt;br&gt;\n&=\r\ngt; &gt; &lt;br&gt;\n&gt; &gt; // How many jobs the execution threads will snag&lt;br=\r\n&gt;\n&gt; &gt; // at once from global job queue&lt;br&gt;\n&gt; &gt; const int    par=\r\nam_numJobsToLoad               =3D 30;&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&g=\r\nt; &gt; // The port number the tcp network server will listen on&lt;br&gt;\n&gt; &=\r\ngt; const int    param_networkPort                 =3D 7474;&lt;br&gt;\n&gt; &gt; =\r\n&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; No doubt I need to tweak my parameters, but I=\r\n&#39;m wondering if my&lt;br&gt;\n&gt; &gt; implementation is missing something es=\r\nsential from the original one.&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; =\r\nAny tips from the NEAT gurus out there would be *most* appreciated,&lt;br&gt;\n&gt=\r\n; &gt; It&#39;s taken me far longer to get to this point than I imagined, a=\r\nnd I&#39;m&lt;br&gt;\n&gt; &gt; quickly running short of time to finish my thesis.=\r\n&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; -Drew Kirkpatrick&lt;br&gt;\n&gt; &gt=\r\n;&lt;br&gt;\n&gt;&lt;br&gt;\n&lt;br&gt;\n&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;\n\n    &lt;/div&gt;\n     \n\n    \n    &lt;div st=\r\nyle=3D&quot;color:#fff;min-height:0&quot;&gt;&lt;/div&gt;\n\n\n&lt;/div&gt;\n\n\n\n  \n\n\n\n\n\n\n&lt;/blockquote&gt;&lt;/=\r\ndiv&gt;&lt;br&gt;&lt;/div&gt;\n\r\n--20cf303dda7c71a2b104b240d2cc--\r\n\n"}}