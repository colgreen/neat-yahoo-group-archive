{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":230385553,"authorName":"Cesar G. Miguel","from":"&quot;Cesar G. Miguel&quot; &lt;cesar.gomes@...&gt;","profile":"fdital","replyTo":"LIST","senderId":"Jy4eYblM9nZvMdVqKeFN-MssA8QS6acDjjqudfP2e_Tx1JVXmn00MEDdBC6qvRgeyGZJD-HaRcyCxCidcuVTef3_5m08OrX53ZEd6_df8T4","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Re: rtNEAT: max_depth() in an endless loop","postDate":"1225740558","msgId":4411,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGRkZjEwMDc4MDgxMTAzMTEyOWgzOGNjMGI5NXNhYjYyZjNlYWRhNzI2YjkxQG1haWwuZ21haWwuY29tPg==","inReplyToHeader":"PDQ5MEY0QjgyLjYwMzA4MDZAeWFob28uY29tPg==","referencesHeader":"PGdlbmI1ZitxZ3BzQGVHcm91cHMuY29tPiA8NDkwRjRCODIuNjAzMDgwNkB5YWhvby5jb20+"},"prevInTopic":4410,"nextInTopic":4412,"prevInTime":4410,"nextInTime":4412,"topicId":4396,"numMessagesInTopic":16,"msgSnippet":"Jim, I think the problem resides in adding a link when applying the depth strategy for feedforward network activation (it s hard to see the right order of","rawEmail":"Return-Path: &lt;cesar.gomes@...&gt;\r\nX-Sender: cesar.gomes@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 32546 invoked from network); 3 Nov 2008 19:35:45 -0000\r\nX-Received: from unknown (66.218.67.95)\n  by m52.grp.scd.yahoo.com with QMQP; 3 Nov 2008 19:35:45 -0000\r\nX-Received: from unknown (HELO gv-out-0910.google.com) (216.239.58.184)\n  by mta16.grp.scd.yahoo.com with SMTP; 3 Nov 2008 19:35:44 -0000\r\nX-Received: by gv-out-0910.google.com with SMTP id l14so306393gvf.19\n        for &lt;neat@yahoogroups.com&gt;; Mon, 03 Nov 2008 11:35:43 -0800 (PST)\r\nX-Received: by 10.103.49.12 with SMTP id b12mr219963muk.112.1225740558573;\n        Mon, 03 Nov 2008 11:29:18 -0800 (PST)\r\nX-Received: by 10.103.241.10 with HTTP; Mon, 3 Nov 2008 11:29:18 -0800 (PST)\r\nMessage-ID: &lt;ddf100780811031129h38cc0b95sab62f3eada726b91@...&gt;\r\nDate: Mon, 3 Nov 2008 17:29:18 -0200\r\nTo: neat@yahoogroups.com\r\nIn-Reply-To: &lt;490F4B82.6030806@...&gt;\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\nContent-Disposition: inline\r\nReferences: &lt;genb5f+qgps@...&gt; &lt;490F4B82.6030806@...&gt;\r\nX-Google-Sender-Auth: 1a1129f89e2e2fd9\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nX-eGroups-From: &quot;Cesar G. Miguel&quot; &lt;cesargm@...&gt;\r\nFrom: &quot;Cesar G. Miguel&quot; &lt;cesar.gomes@...&gt;\r\nSubject: Re: [neat] Re: rtNEAT: max_depth() in an endless loop\r\nX-Yahoo-Group-Post: member; u=230385553; y=JOkqM68pbVJWE7obqE6BVI0WYeupoRXdNJhr7bBf5dUZ\r\nX-Yahoo-Profile: fdital\r\n\r\nJim,\n\nI think the problem resides in adding a link when applying the &quot;depth\nstrategy&quot; for feedforward network activation (it&#39;s hard to see the\nright order of activation), so you can end up adding a link between\nnode B to node A even when B&#39;s activation depends on an incoming\nconnection from A (forming a loop).\n\nThe difficult question is: How to determine if a link is recurrent or\nnot, given the &quot;depth strategy&quot;?\n\nCesar\n\nOn Mon, Nov 3, 2008 at 5:05 PM, Jim O&#39;Flaherty\n&lt;jim_oflaherty_jr@...&gt; wrote:\n&gt; Peter,\n&gt;\n&gt; That doesn&#39;t make sense to me. Cesar&#39;s comments indicate he has a similar\n&gt; implementation to mine. Basically, every node&#39;s value in a single instance\n&gt; of an ANN is calculated just once on an activation pass. When the node is\n&gt; calculated, each of the nodes attached to it as &quot;input&quot; are used (whether\n&gt; they have been activated in this pass, or hold a residual value from the\n&gt; previous pass) to calculate it&#39;s current value. And assuming the ordering of\n&gt; the activations is lined up by dependency and they by node age, the network\n&gt; ought to activate deterministically meaning that starting with an empty\n&gt; network (all node activation values are set to 0.0), providing the same\n&gt; input and making several activation passes ought to be able to return\n&gt; reliably repeatable results given the node activation values are reset to\n&gt; 0.0 and precisely the same input is submitted for the same number of\n&gt; activation passes.\n&gt;\n&gt; I get that the network graph can have cycles, as in recurrent connections.\n&gt; However, those have no relevance to activation order or cause any sort of\n&gt; &quot;loop&quot; in a straightforward ANN implementation. So, I am getting confused\n&gt; about where and how an &quot;endless loop&quot; could form. Perhaps they are talking\n&gt; about the network output never stabilizing to within some stable value\n&gt; ranges when activating it repeatedly with the same input. That&#39;s to be\n&gt; expected in a network with enough recurrent connections - non-uniformity in\n&gt; the output following activations with the same input. Each additional\n&gt; recurrent connection increases the &quot;echos from the past&quot; causing a stable\n&gt; output cycle to become less and less probable.\n&gt;\n&gt; Said another way, a single activation of an ANN, with or without recurrent\n&gt; connections, will results in exactly the same number of node activation\n&gt; calculations each time it is told to process input. There should not be any\n&gt; variability to the number of node activations AT ALL. If so, then some sort\n&gt; of different activation strategy is being employed. And if so, what is it?\n&gt; And why?\n&gt;\n&gt;\n&gt; Jim\n&gt;\n&gt;\n&gt; petar_chervenski wrote:\n&gt;\n&gt; It is about the loop in which you calculate the longest path from an\n&gt; input node to an output node. Not the activation loop in which you\n&gt; activate the network.\n&gt;\n&gt; Peter\n&gt;\n&gt; --- In neat@yahoogroups.com, Jim O&#39;Flaherty &lt;jim_oflaherty_jr@...&gt;\n&gt; wrote:\n&gt;&gt;\n&gt;&gt; Ken,\n&gt;&gt;\n&gt;&gt; I am confused how you could end up in an endless activation loop. If\n&gt; you\n&gt;&gt; are moving from the input nodes forward through the hidden nodes to\n&gt; the\n&gt;&gt; output nodes as a state calculation progression, there would be no\n&gt; need\n&gt;&gt; to worry about activation loops - you would only calculate the value\n&gt; of\n&gt;&gt; each node once in a single pass. The point of a recurrent connection\n&gt; is\n&gt;&gt; to carry state between full network activations. So, the value\n&gt; provided\n&gt;&gt; by a recurrent connection would not be used until the next\n&gt; activation\n&gt;&gt; pass (assuming all the nodes from the previous pass have not be\n&gt; &quot;zeroed\n&gt;&gt; out&quot;).\n&gt;&gt;\n&gt;&gt; How is it there is an endless loop?\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; Jim\n&gt;&gt;\n&gt;&gt;\n&gt;&gt; Kenneth Stanley wrote:\n&gt;&gt; &gt;\n&gt;&gt; &gt; Yes I have heard about this problem coming up in the XOR\n&gt; experiment.\n&gt;&gt; &gt; Most neuroevolution experiments are not classification experiments\n&gt;&gt; &gt; (i.e. they don&#39;t have a &quot;final&quot; output), or they allow recurrent\n&gt;&gt; &gt; connections, and therefore do not require depth to be computed.\n&gt;&gt; &gt; Therefore, this problem will not come up in most expeirments.\n&gt;&gt; &gt;\n&gt;&gt; &gt; However, XOR is a benchmark classification problem that is only\n&gt; meant\n&gt;&gt; &gt; to be attempted by feedforward networks so it needs to have depth\n&gt;&gt; &gt; computed. It appears that my attempts to keep the network\n&gt; feedforward\n&gt;&gt; &gt; in all cases is not perfect, so sometimes when a loop arises, it\n&gt; sends\n&gt;&gt; &gt; the depth computation into an infinite loop. I have not had time\n&gt; to\n&gt;&gt; &gt; think about the most elegant solution to this problem: Maybe it\n&gt; should\n&gt;&gt; &gt; be a stronger check on recurrence, perhaps entirely different from\n&gt; how\n&gt;&gt; &gt; it works now. Or perhaps it should be a fixed abort-iteration for\n&gt; the\n&gt;&gt; &gt; depth routine.\n&gt;&gt; &gt;\n&gt;&gt; &gt; If someone does feel they have an elegant bit of code to address\n&gt; the\n&gt;&gt; &gt; issue, I will be happy to take a look.\n&gt;&gt; &gt;\n&gt;&gt; &gt; In any case, it should not cause serious problems in general. I\n&gt;&gt; &gt; apologize for any inconvenience.\n&gt;&gt; &gt;\n&gt;&gt; &gt; ken\n&gt;&gt; &gt;\n&gt;&gt; &gt; --- In neat@yahoogroups.com &lt;mailto:neat%40yahoogroups.com&gt;,\n&gt;&gt; &gt; &quot;petar_chervenski&quot; &lt;petar_chervenski@&gt;\n&gt;&gt; &gt; wrote:\n&gt;&gt; &gt; &gt;\n&gt;&gt; &gt; &gt; Hi Cesar,\n&gt;&gt; &gt; &gt;\n&gt;&gt; &gt; &gt; I know of this problem. It is obvious that depth cannot be\n&gt; determined\n&gt;&gt; &gt; &gt; in a recurrent network, but in general it depends, what is your\n&gt; way to\n&gt;&gt; &gt; &gt; handle the situation. Try improving the add_link() code so that\n&gt; the\n&gt;&gt; &gt; &gt; right nodes are picked up when trying to add a forward or a\n&gt; recurrent\n&gt;&gt; &gt; &gt; connection. This is a good solution but in general the problem\n&gt; with\n&gt;&gt; &gt; &gt; looped networks cannot be avoided. Suppose you have 3 hidden\n&gt; nodes, A,\n&gt;&gt; &gt; &gt; B, and C. If you link these like A-&gt;B, B-&gt;C, C-&gt;A, it is a loop\n&gt; in the\n&gt;&gt; &gt; &gt; network, even though all connections are meant to be forward.\n&gt;&gt; &gt; &gt; The best solution in my opinion is to put a limit on the\n&gt; possible\n&gt;&gt; &gt; &gt; depth, say 32, if the depth exceeds 32, quit the recursion and\n&gt;&gt; &gt; &gt; activate the network 32 times. It slows things down but at least\n&gt; it\n&gt;&gt; &gt; &gt; will not hurt evolution as if you penalize looped networks.\n&gt;&gt; &gt; &gt;\n&gt;&gt; &gt; &gt; Peter\n&gt;&gt; &gt; &gt;\n&gt;&gt; &gt; &gt; --- In neat@yahoogroups.com &lt;mailto:neat%40yahoogroups.com&gt;,\n&gt; &quot;Cesar\n&gt;&gt; &gt; G. Miguel&quot; &lt;cesar.gomes@&gt;\n&gt;&gt; &gt; &gt; wrote:\n&gt;&gt; &gt; &gt; &gt;\n&gt;&gt; &gt; &gt; &gt; Hi all,\n&gt;&gt; &gt; &gt; &gt;\n&gt;&gt; &gt; &gt; &gt; I&#39;m not sure if someone else has notice this &quot;bug&quot; in rtNEAT,\n&gt; but\n&gt;&gt; &gt; &gt; the\n&gt;&gt; &gt; &gt; &gt; max_depth() method in network.cpp has the potential to be\n&gt; forever in\n&gt;&gt; &gt; &gt; &gt; loop if a recurrent link is added in a feedforward topology,\n&gt; e.g.,\n&gt;&gt; &gt; &gt; the\n&gt;&gt; &gt; &gt; &gt; XOR experiment (and that can happen even when the\n&gt; recur_only_prob\n&gt;&gt; &gt; &gt; &gt; parameter is set to zero). A real example is attached.\n&gt;&gt; &gt; &gt; &gt;\n&gt;&gt; &gt; &gt; &gt; It seems to happen in 1 out of 10 runs. The max_depth() method\n&gt; calls\n&gt;&gt; &gt; &gt; &gt; depth() in nnode.cpp, which should return the max depth of\n&gt; that\n&gt;&gt; &gt; &gt; node.\n&gt;&gt; &gt; &gt; &gt; But it can get trapped in a loop if any recurrent link is\n&gt; present\n&gt;&gt; &gt; &gt; (as\n&gt;&gt; &gt; &gt; &gt; it is commented out in the source: DEPTH NOT DETERMINED FOR\n&gt; NETWORK\n&gt;&gt; &gt; &gt; &gt; WITH LOOP).\n&gt;&gt; &gt; &gt; &gt;\n&gt;&gt; &gt; &gt; &gt; For those cases I have to force a return if an endless loop is\n&gt;&gt; &gt; &gt; &gt; detected and then set the chromosome&#39;s fitness to zero in\n&gt; order to\n&gt;&gt; &gt; &gt; &gt; continue.\n&gt;&gt; &gt; &gt; &gt;\n&gt;&gt; &gt; &gt; &gt; Has anyone dealed with that before?\n&gt;&gt; &gt; &gt; &gt;\n&gt;&gt; &gt; &gt; &gt; []&#39;s\n&gt;&gt; &gt; &gt; &gt; Cesar\n&gt;&gt; &gt; &gt; &gt;\n&gt;&gt; &gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt; &gt;\n&gt;&gt;\n&gt;\n&gt; \n\n"}}