{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":436954031,"authorName":"arman.schwarz","from":"&quot;arman.schwarz&quot; &lt;arman.schwarz@...&gt;","profile":"arman.schwarz","replyTo":"LIST","senderId":"lC4ERzzA58z6iuDa1oHpfYlvF5aGIIsdneXjUDW7coD7dxM-y9LSBcF2xSYSjblQi-oRm3CoGQLjYna-nvSpg7uz05-AgmFH4uqAwkqO3UM","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: technical question about custom number of sensors and output nodes","postDate":"1314626961","msgId":5635,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGozZzZpaCs2Z284QGVHcm91cHMuY29tPg==","inReplyToHeader":"PGozMW5yOStrcXRuQGVHcm91cHMuY29tPg=="},"prevInTopic":5633,"nextInTopic":5636,"prevInTime":5634,"nextInTime":5636,"topicId":5623,"numMessagesInTopic":7,"msgSnippet":"Thanks Ken, I tried to create a simple starting genome that simply connects the input to the output; genomestart 1 trait 1 1.0 0 0 0 0 0 0 0 node 1 1 1 1 node","rawEmail":"Return-Path: &lt;arman.schwarz@...&gt;\r\nX-Sender: arman.schwarz@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 83633 invoked from network); 29 Aug 2011 14:09:25 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m10.grp.re1.yahoo.com with QMQP; 29 Aug 2011 14:09:25 -0000\r\nX-Received: from unknown (HELO n43d.bullet.mail.sp1.yahoo.com) (66.163.169.157)\n  by mta2.grp.re1.yahoo.com with SMTP; 29 Aug 2011 14:09:24 -0000\r\nX-Received: from [69.147.65.173] by n43.bullet.mail.sp1.yahoo.com with NNFMP; 29 Aug 2011 14:09:23 -0000\r\nX-Received: from [98.137.34.155] by t15.bullet.mail.sp1.yahoo.com with NNFMP; 29 Aug 2011 14:09:23 -0000\r\nDate: Mon, 29 Aug 2011 14:09:21 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;j3g6ih+6go8@...&gt;\r\nIn-Reply-To: &lt;j31nr9+kqtn@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nFrom: &quot;arman.schwarz&quot; &lt;arman.schwarz@...&gt;\r\nSubject: Re: technical question about custom number of sensors and output nodes\r\nX-Yahoo-Group-Post: member; u=436954031; y=sT6WXX21TbzWboMA7oDALqARuI1n7cUQ3aUm7u_l5ERF9hiFJoRINQ\r\nX-Yahoo-Profile: arman.schwarz\r\n\r\nThanks Ken,\n\nI tried to create a simple starting genome that simply connect=\r\ns the input to the output;\n\ngenomestart 1\ntrait 1 1.0 0 0 0 0 0 0 0\nnode 1 =\r\n1 1 1\nnode 1 0 1 2\ngene 1 1 1 1.0 0 1 0 1\ngenomeend 1\n\nwhen I allow this to=\r\n run it does a surprisingly good job at finding a solution, but it doesn&#39;t =\r\nuse the other inputs. That is to say, I end up with very complex networks t=\r\nhat do a reasonable job of predicting the timeseries (but not as well as th=\r\ney could if they used all the inputs), but none of the nodes, other than th=\r\ne first, are ever input nodes.\n\nSupposing that I have 25 inputs, I am creat=\r\ning the following start genes file:\n\ngenomestart 1\ntrait 1 1 0 0 0 0 0 0 0\n=\r\nnode 1 0 1 1\nnode 2 0 1 1\nnode 3 0 1 1\nnode 4 0 1 1\nnode 5 0 1 1\nnode 6 0 1=\r\n 1\nnode 7 0 1 1\nnode 8 0 1 1\nnode 9 0 1 1\nnode 10 0 1 1\nnode 11 0 1 1\nnode =\r\n12 0 1 1\nnode 13 0 1 1\nnode 14 0 1 1\nnode 15 0 1 1\nnode 16 0 1 1\nnode 17 0 =\r\n1 1\nnode 18 0 1 1\nnode 19 0 1 1\nnode 20 0 1 1\nnode 21 0 1 1\nnode 22 0 1 1\nn=\r\node 23 0 1 1\nnode 24 0 1 1\nnode 25 0 1 1\nnode 26 0 0 2\nnode 27 0 0 3\nnode 2=\r\n8 0 0 0\ngene 1 1 26 1 0 1 0 1\ngenomeend 1\n\nWill this ensure that NEAT makes=\r\n use of any available inputs (assuming there are only 25)?\n\nArman\n\n--- In n=\r\neat@yahoogroups.com, &quot;Ken&quot; &lt;kstanley@...&gt; wrote:\n&gt;\n&gt; \n&gt; \n&gt; Hi Arman, nodes.=\r\nsize() is not constant because nodes is a variable-length list, so it can g=\r\nrow or shrink.  Asking for its size just gives the current number of nodes =\r\nin the list.  The &quot;inlist&quot; and &quot;outlist&quot; (lists of inputs and outputs inter=\r\nnally generated by NEAT) work the same way, so they too can change.  Theref=\r\nore, in principle, I believe that your idea should be feasible.  However, y=\r\nou need to make sure that if you ever add new inputs that those new nodes h=\r\nave the right flags marking them as input nodes and sensors.\n&gt; \n&gt; There use=\r\nd to be a tutorial that comes with NEAT that explained the file format, but=\r\n it gone out of date as NEAT was updated, so I believe unfortunately it&#39;s n=\r\no longer included.  Let me try to explain a little:\n&gt; \n&gt; Traits are reserve=\r\nd for special genetic information that nodes or connections can point to.  =\r\nThey are not used in most NEAT experiments.  I believe you just need one du=\r\nmmy trait in a genome file trait but it won&#39;t be used.\n&gt; \n&gt; node 1 0 1 1\n&gt; =\r\n\n&gt; The first number is the node ID #, the second is the trait pointer (whic=\r\nh can be left at zero), the third says whether the node is NEURON/SENSOR (0=\r\n,1), and the fourth is HIDDEN/INPUT/OUTPUT/BIAS (0,1,2,3).  It&#39;s true that =\r\nthe third and fourth numbers are a little confusing because they seem to be=\r\n about a similar issue, but that is how they are defined.\n&gt; \n&gt; gene 1 1 5 0=\r\n.0 0 1 0 1\n&gt; \n&gt; The parameters are: trait # (not usually used), in_node id,=\r\n out_node id, weight, is_recurrent flag, innovation_num, mutation_num, and =\r\nenable flag.\n&gt; \n&gt; Note that mutation_num is generally set the same as the w=\r\neight and does not have a real specific use in NEAT.\n&gt; \n&gt; As you may notice=\r\n some parameters seem unnecessary or redundant, but I initially created thi=\r\ns format before I was sure about everything that would be needed and the le=\r\ngacy parameters stuck around, which unfortunately can be confusing.\n&gt; \n&gt; ke=\r\nn\n&gt; \n&gt; --- In neat@yahoogroups.com, &quot;arman.schwarz&quot; &lt;arman.schwarz@&gt; wrote:=\r\n\n&gt; &gt;\n&gt; &gt; \n&gt; &gt; \n&gt; &gt; Thanks Ken,\n&gt; &gt; \n&gt; &gt; I think I understand what you mean.=\r\n So when a new genome is created, NEAT will search through the &quot;nodes&quot; vect=\r\nor to look for candidates. The nodes vector in turn is generated initially =\r\nby what it finds in the call to this function during the initial creation o=\r\nf the population:\n&gt; &gt; \n&gt; &gt; Genome::Genome(int id, std::ifstream &iFile)\n&gt; &gt;=\r\n \n&gt; &gt; Does this mean that nodes.size() is constant and initially constraine=\r\nd to what is given in the genome start file, or does can it adapt depending=\r\n on the size of the array passed to the &quot;load_sensors&quot; function?\n&gt; &gt; \n&gt; &gt; T=\r\nhe reason I ask is because I have about 200 inputs, and I would like to cre=\r\nate a start file which simply takes the first input as output, and tries to=\r\n improve based on that, preferably allowing me to use any number of inputs =\r\nwith a single genome start file. Can I do that without destroying NEAT&#39;s ab=\r\nility to recognise the existence of all the sensors?\n&gt; &gt; \n&gt; &gt; I&#39;m also some=\r\nwhat confused about the format of those start files, is there any documenta=\r\ntion for these files that I can learn from, or will I just need to look thr=\r\nough the source code? I understand NEAT&#39;s concept of bias nodes, but not so=\r\n much the idea of &quot;traits&quot;, so it would be nice to know if any documentatio=\r\nn does exist.\n&gt; &gt; \n&gt; &gt; Thanks again for your help.\n&gt; &gt; Arman\n&gt; &gt; \n&gt; &gt; --- I=\r\nn neat@yahoogroups.com, &quot;Ken&quot; &lt;kstanley@&gt; wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; \n&gt; &gt; &gt; \n&gt; &gt; &gt; =\r\nHi Arman, from what you wrote I think you understand how to pass in and rea=\r\nd out the input and output arrays.  I think the main question you are askin=\r\ng is how it knows how long those arrays are.\n&gt; &gt; &gt; \n&gt; &gt; &gt; The answer is tha=\r\nt rtNEAT (or plain NEAT) C++ counts the number of inputs and number of outp=\r\nuts when it creates a neural network from a genome, which happens in the me=\r\nthod \n&gt; &gt; &gt; \n&gt; &gt; &gt; Network *Genome::genesis(int id)\n&gt; &gt; &gt; \n&gt; &gt; &gt; When it cr=\r\neates the network, it creates separate lists of inputs, hidden nodes, and o=\r\nutputs, as you can see here:\n&gt; &gt; &gt; \n&gt; &gt; &gt;                 //Check for input=\r\n or output designation of node\n&gt; &gt; &gt;                 if (((*curnode)-&gt;gen_n=\r\node_label)=3D=3DINPUT)\n&gt; &gt; &gt;                         inlist.push_back(newno=\r\nde);\n&gt; &gt; &gt;                 if (((*curnode)-&gt;gen_node_label)=3D=3DBIAS)\n&gt; &gt; =\r\n&gt;                         inlist.push_back(newnode);\n&gt; &gt; &gt;                 =\r\nif (((*curnode)-&gt;gen_node_label)=3D=3DOUTPUT)\n&gt; &gt; &gt;                        =\r\n outlist.push_back(newnode);\n&gt; &gt; &gt; \n&gt; &gt; &gt; Then it knows how many inputs the=\r\nre are and how many outputs there are because it knows how long those lists=\r\n are.\n&gt; &gt; &gt; \n&gt; &gt; &gt; Going back further in the chain, usually the first place=\r\n this issue will ultimately be specified is in the starter genome file, whi=\r\nch is usually the origin of the genome data structures (which are created f=\r\nrom this file).  Here is a pole balancing starter genome:\n&gt; &gt; &gt; \n&gt; &gt; &gt; geno=\r\nmestart 1\n&gt; &gt; &gt; trait 1 0.1 0 0 0 0 0 0 0\n&gt; &gt; &gt; node 1 0 1 1\n&gt; &gt; &gt; node 2 0=\r\n 1 1\n&gt; &gt; &gt; node 3 0 1 1\n&gt; &gt; &gt; node 4 0 1 3\n&gt; &gt; &gt; node 5 0 0 2\n&gt; &gt; &gt; gene 1 =\r\n1 5 0.0 0 1 0 1\n&gt; &gt; &gt; gene 1 2 5 0.0 0 2 0 1\n&gt; &gt; &gt; gene 1 3 5 0.0 0 3 0 1\n&gt;=\r\n &gt; &gt; gene 1 4 5 0.0 0 4 0 1\n&gt; &gt; &gt; genomeend 1\n&gt; &gt; &gt; \n&gt; &gt; &gt; Here the numeric=\r\nal codes next the nodes specify what type of nodes they are.  In this case,=\r\n there are 4 inputs (one is a bias) and 1 output.  These codes are defined =\r\nin nnode.h:\n&gt; &gt; &gt; \n&gt; &gt; &gt;         enum nodetype {\n&gt; &gt; &gt;                 NEUR=\r\nON =3D 0,\n&gt; &gt; &gt;                 SENSOR =3D 1\n&gt; &gt; &gt;         };\n&gt; &gt; &gt; \n&gt; &gt; &gt; =\r\n        enum nodeplace {\n&gt; &gt; &gt;                 HIDDEN =3D 0,\n&gt; &gt; &gt;         =\r\n        INPUT =3D 1,\n&gt; &gt; &gt;                 OUTPUT =3D 2,\n&gt; &gt; &gt;             =\r\n    BIAS =3D 3\n&gt; &gt; &gt;         };\n&gt; &gt; &gt; \n&gt; &gt; &gt; So usually that is from where =\r\nNEAT ultimately ends up knowing these counts.  I hope that helps answer you=\r\nr question.\n&gt; &gt; &gt; \n&gt; &gt; &gt; ken\n&gt; &gt; &gt; \n&gt; &gt; &gt; \n&gt; &gt; &gt; --- In neat@...=\r\nm, &quot;arman.schwarz&quot; &lt;arman.schwarz@&gt; wrote:\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; hi everyone, \n&gt; =\r\n&gt; &gt; &gt; I am currently trying to apply timeseries prediction to the rtNEAT c+=\r\n+ package, to compare its search performance to a fixed-size, evolving topo=\r\nlogy recurrent neural net I wrote.\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; I have written a custom=\r\n experiments.h/cpp file to cycle through the activate() function for every =\r\ntime step, after loading an array of ~75 sensor inputs.\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; So=\r\n while I understand how to load the inputs and retrieve the outputs, I don&#39;=\r\nt quite understand how I am supposed to tell NEAT how many inputs and outpu=\r\nts there are. after all, that array I&#39;m passing to load_sensor is nothing m=\r\nore than a pointer to a value.\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; so where do I tell NEAT how=\r\n many inputs I will give each net, and how many outputs I will be expecting=\r\n? (in my RNN the outputs were simply the last x neurons, but the inputs do =\r\nneed to be defined).\n&gt; &gt; &gt; &gt; \n&gt; &gt; &gt; &gt; thanks in advance for the help!\n&gt; &gt; &gt;=\r\n &gt;\n&gt; &gt; &gt;\n&gt; &gt;\n&gt;\n\n\n\n"}}