{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":200957992,"authorName":"Jason Gauci","from":"&quot;Jason Gauci&quot; &lt;jgmath2000@...&gt;","profile":"jgmath2000","replyTo":"LIST","senderId":"LoZiu1qgUYvjppUEybfESd4lHRgAgiDW2d3byX46pH8UihAEU8NmqkPPeJhlrLgJRIMDp_k-gcH0yQW5xdAHUc22vG_pQuklnZeX","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: HyperNEAT Source Code Release","postDate":"1175097342","msgId":3059,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGV1ZTM1dStiYjhoQGVHcm91cHMuY29tPg==","inReplyToHeader":"PEEwRjM5MTYzLTBDOEItNEY5RS04OTNDLTY1RTgxMUEzRkQ4OUB3YWl0cy5uZXQ+"},"prevInTopic":3058,"nextInTopic":3060,"prevInTime":3058,"nextInTime":3060,"topicId":3057,"numMessagesInTopic":8,"msgSnippet":"... Thanks!  I can t wait to present it =) ... I think the reason why my implementation is so fast is because of memory management. I allocate a block of data","rawEmail":"Return-Path: &lt;jgmath2000@...&gt;\r\nX-Sender: jgmath2000@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 38828 invoked from network); 28 Mar 2007 15:55:47 -0000\r\nReceived: from unknown (66.218.67.33)\n  by m46.grp.scd.yahoo.com with QMQP; 28 Mar 2007 15:55:47 -0000\r\nReceived: from unknown (HELO n31.bullet.scd.yahoo.com) (66.94.237.25)\n  by mta7.grp.scd.yahoo.com with SMTP; 28 Mar 2007 15:55:46 -0000\r\nReceived: from [66.218.69.5] by n31.bullet.scd.yahoo.com with NNFMP; 28 Mar 2007 15:55:43 -0000\r\nReceived: from [66.218.66.87] by t5.bullet.scd.yahoo.com with NNFMP; 28 Mar 2007 15:55:43 -0000\r\nDate: Wed, 28 Mar 2007 15:55:42 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;eue35u+bb8h@...&gt;\r\nIn-Reply-To: &lt;A0F39163-0C8B-4F9E-893C-65E811A3FD89@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0\r\nFrom: &quot;Jason Gauci&quot; &lt;jgmath2000@...&gt;\r\nSubject: Re: HyperNEAT Source Code Release\r\nX-Yahoo-Group-Post: member; u=200957992; y=G2VdA80pNvlz284PdtDY6-t9V29t8oTOGsIXRaChIVxzD2M88w\r\nX-Yahoo-Profile: jgmath2000\r\n\r\n--- In neat@yahoogroups.com, Stephen Waits &lt;steve@...&gt; wrote:\n&gt; Hi Jason,\n&gt;=\r\n \n&gt; Congrats on the paper, it&#39;s good.\n\nThanks!  I can&#39;t wait to present it =\r\n=3D)\n\n&gt; \n&gt; I&#39;m *very* much looking forward to your code.\n&gt; \n&gt; That you can =\r\nupdate ~90M neurons/second is impressive.\n&gt; \n&gt; --Steve\n&gt;\n\nI think the reaso=\r\nn why my implementation is so fast is because of \nmemory management.\n\nI all=\r\nocate a block of data big enough to hold the entire network and \nstructure =\r\nit in this way:\n\ndouble *nodeValues;\ndouble *nodeNewValues;\nActivationFunct=\r\nion *activationFunctions;\nNetworkIndexedLink *links;\n\nint numConstantNodes;=\r\n\n\nAll of the array pointers point to consecutive positions in one \nmassive =\r\ncharacter array.  Because of this, I don&#39;t run into many \npaging issues whi=\r\nle the network is updating.  Also, because it&#39;s all \nin one array, I don&#39;t =\r\nhave to go searching through the heap while I&#39;m \nupdating.  Finally, I use =\r\ncore memory operations when possible.  For \nexample, I can update the nodes=\r\n in the network to their new values by \ndoing this:\n\nmemcpy(\nnodeValues+num=\r\nConstantNodes,\nnodeNewValues+numConstantNodes,\nsizeof(double)*(numNodes-num=\r\nConstantNodes)\n);\n\nThis updates all of the non-input nodes without having t=\r\no make a \ncontrol structure and assign each node value individually.\n\nI thi=\r\nnk the network could be sped up even more by using 32-bit \nfloating point n=\r\numbers instead of doubles, but I haven&#39;t tried it.\n\n\n"}}