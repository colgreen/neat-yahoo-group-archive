{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":54567749,"authorName":"Kenneth Stanley","from":"&quot;Kenneth Stanley&quot; &lt;kstanley@...&gt;","profile":"kenstanley01","replyTo":"LIST","senderId":"Or4hX3Qpkm4SRb_WA3hfXWCNeqxIbdYUVG-iwd8ObsxNWkfsw245aj301mjTxF1RX2KRDZmBTziik-bo-a7j_RBuzwSrKOgYd1CHmTifOPz1","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: Heap Selection","postDate":"1121833333","msgId":2132,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGRia2pobCs3ZWJkQGVHcm91cHMuY29tPg==","inReplyToHeader":"PDYuMi4wLjE0LjAuMjAwNTA1MTAxMTQ1MDIuMDNjNmQ0MzBAcG9wLm1haWwueWFob28uY28udWs+"},"prevInTopic":2108,"nextInTopic":2134,"prevInTime":2131,"nextInTime":2133,"topicId":2108,"numMessagesInTopic":5,"msgSnippet":"Hi Ian, I read your Heap Selection idea but I m still not sure how you mean to use the heap?  How are parents selected?  Is it somehow based probabalistically","rawEmail":"Return-Path: &lt;kstanley@...&gt;\r\nX-Sender: kstanley@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 88627 invoked from network); 20 Jul 2005 04:22:15 -0000\r\nReceived: from unknown (66.218.66.172)\n  by m23.grp.scd.yahoo.com with QMQP; 20 Jul 2005 04:22:15 -0000\r\nReceived: from unknown (HELO n21a.bulk.scd.yahoo.com) (66.94.237.50)\n  by mta4.grp.scd.yahoo.com with SMTP; 20 Jul 2005 04:22:15 -0000\r\nComment: DomainKeys? See http://antispam.yahoo.com/domainkeys\r\nReceived: from [66.218.69.6] by n21.bulk.scd.yahoo.com with NNFMP; 20 Jul 2005 04:22:15 -0000\r\nReceived: from [66.218.66.75] by mailer6.bulk.scd.yahoo.com with NNFMP; 20 Jul 2005 04:22:15 -0000\r\nDate: Wed, 20 Jul 2005 04:22:13 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;dbkjhl+7ebd@...&gt;\r\nIn-Reply-To: &lt;6.2.0.14.0.20050510114502.03c6d430@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 6877\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:12:0\r\nFrom: &quot;Kenneth Stanley&quot; &lt;kstanley@...&gt;\r\nSubject: Re: Heap Selection\r\nX-Yahoo-Group-Post: member; u=54567749; y=pK40p7KPm9S6fFrtm5b67Aq5q_DIxWuhdRKA87ASQO_mw9AI7zCG\r\nX-Yahoo-Profile: kenstanley01\r\n\r\nHi Ian, I read your Heap Selection idea but I&#39;m still not sure how \nyou mean to use the heap?  How are parents selected?  Is it somehow \nbased probabalistically on how high up the tree they are?  And with \nwhom are they allowed to mate?  How would this be applied in a \ngenerational system?  Or is it not meant to be generational, i.e. \nmore of a steady state idea?  Also when fitness is absolute (i.e. \nnot just a comparison between two individuals) how does that affect \nyour heap organization?  Would individuals pop up to the top e.g. if \nthey have the max fitness?  (but that would then loose the kinship-\ntracking aspect to some extent)\n\nAs I understand it presently, you have a method for organizing and \nstoring relationship based on some combination of kinship and \nfitness ranking.  It does seem possible this could be used in a \nuseful manner, but one reason I might not be a big fan of it is that \nis does away with historical markings without substituting an \nequally powerful compatibility measure.  I agree it&#39;s an interesting \nidea to keep track of kinship, but if you literally know the \nhistorical origin of every gene in the system I am not sure why you \nwould not organize based on that knowledge, which is more precise \nthan kinship?  (Also, kinship-based organization explicitly \nencourages inbreeding)  \n\nAside from any of my critique, this is perhaps a new speciation \nmethod that has not been thought of before and probably merits some \nattention in terms of how it compares with other ones out there.  \n\nA little off-topic from this proposal, I am not sure that doing away \nwith aspects of speciation is really a good thing.  To me, the fact \nthat you can control the sizes and number of clusters in your \npopulation is a good thing and not a bad thing.  It&#39;s also good that \nyou can control the extent to which they interbreed.  Obviously this \nis an open empirical question, but my instinct is not to assume that \nthere is anything arbitrary the idea of separating a population into \ncompatibility groupings.  That&#39;s not to say it&#39;s the best method; we \nneed comparisons for that.  Just that it&#39;s not clear on the face of \nit that there is something wrong with it.\n\nken\n\n--- In neat@yahoogroups.com, Ian Badcoe &lt;ian_badcoe@y...&gt; wrote:\n&gt; Hi,\n&gt; \tThis is an idea I have had for some time and I&#39;m sharing it \nnow so that I \n&gt; can refer to it in later emails without explaining the whole thing \nfrom \n&gt; scratch.\n&gt; \n&gt; \tI didn&#39;t get any chance to test it yet :) -- but I plan to.\n&gt; \n&gt; \tThis is basically an alternative to speciation.  The idea \nbeing to do away \n&gt; with the arbitrary aspects (number of species, which precise \nspecies an \n&gt; individual belongs to) whilst keeping the benefit of preserving \npopulation \n&gt; diversity.\n&gt; \n&gt; \tThe idea is to structure the population as a heap.\n&gt; \n&gt; -- explanation of heap data structure, skip if you know --&gt;\n&gt; \n&gt;    A heap is a data structure arranged as a binary tree, where \neach item \n&gt; has two children (which may be empty).  Heaps are often used to \norder data, \n&gt; by maintaining a relationship between parent and child.  They are \n&gt; efficient, because a complete ordering can be achieved making only \n&gt; comparisons between parent and child and not between siblings or \ncousins or \n&gt; more remote items, thus if we have sorted a heap into descending \norder, we \n&gt; might have:\n&gt; \n&gt; http://tinypic.com/518yz7\n&gt; \n&gt; \t[[There is a really easy representation for a heap, in the \nform of a \n&gt; linear array.  The array index simply relates parent and children, \nthus if \n&gt; a parent has an index i (zero based indexing) it&#39;s two children \nare:\n&gt; \n&gt; 2 * i, and,\n&gt; 2 * i + 1]]\n&gt; \n&gt; \tIf one wished to insert, say an 8, one would attach it as a \nchild of any \n&gt; bottom row element, say the 3.  Then one compares it with its \nparent, and \n&gt; if the sort is violated the two are swapped.  This is then \nrepeated with \n&gt; its new parent, until the sort is not violated.\n&gt; \n&gt; \tIf one wishes to remove an item, one removes it and then \nexamines its two \n&gt; children.  One will be suitable as a parent for the other and that \none is \n&gt; moved up into the empty slot.  The empty child slot is then filled \nby doing \n&gt; the same with its children.\n&gt; \n&gt; &lt;-- end of explanation of heap data structure --\n&gt; \n&gt; \tThe way I see this working as a population is to keep a heap \nof \n&gt; individuals, sorted by fitness (this will work for explicit \nfitnesses and \n&gt; also for co-evolution if the comparison can be between [only \nselected] \n&gt; pairs of individuals in one population).  Fitness comparisons only \nneed to \n&gt; be done between parent and child (note these terms here refer to \nlocation \n&gt; in the tree, not any sort of heredity).  When a child proves \nfitter than \n&gt; its parent, the two are swapped (obviously the test only need be \ndone when \n&gt; one has changed).  This leads to a structure where every sub-tree \nin the \n&gt; heap is headed by the fittest member of that sub-tree.  Each sub-\ntree forms \n&gt; a species (and the sub-trees within it form sub-species of it).  \nDiversity \n&gt; is preserved because a newly created fitter individual moves up \nthe tree, \n&gt; pushing the previous occupants down but keeping them in the same \n&gt; sub-tree.  The individual moves up until it meets a fitter \nindividual and \n&gt; them stops, thus redefining the maximum fitness of precisely the \ncorrect \n&gt; &quot;species&quot; (or fraction of the population).\n&gt; \n&gt; \tThe other issue is the generation of diversity.  It is \nnecessary to place \n&gt; new individuals into the correct species.  To achieve this I \npropose either:\n&gt; \n&gt; 1) when a new individual is created it has one or more parents (if \nit has \n&gt; zero, and is a completely newly seeded mutation, then you can \ninsert it at \n&gt; any leaf).  Insert the new individual at any leaf position in the \nsub-tree \n&gt; below one parent (thus inserting it somewhere into a \nsame &quot;species&quot; as a \n&gt; parent).  This will lead to each sub-tree being to some extent, \nrelated to \n&gt; its top member.  The down-side of this is that it will might \neliminate \n&gt; diversity in the sub-trees too rapidly, so see the next idea.\n&gt; \n&gt; 2) for every individual, store the track it followed when it was \nmoved from \n&gt; the base to its current height.  When applying idea 1, insert the \noffspring \n&gt; of each individual mostly at the same start point that the \nindividual had \n&gt; and just occasionally insert the individual elsewhere in the \nindividual&#39;s \n&gt; sub-tree.  Thus each individual is at the head of a &quot;stack&quot; that \nit is \n&gt; closely related too, but also its sub-tree contains a selection of \nless \n&gt; related species (all competing to try and push it off the top \nspot).\n&gt; \n&gt; \tIan Badcoe\n&gt; \n&gt; In fifteen minutes, everybody will be in the future.\n&gt; \n&gt; \n&gt; \n&gt; \t\n&gt; \t\n&gt; \t\t\n&gt; ___________________________________________________________ \n&gt; Yahoo! Messenger - NEW crystal clear PC to PC calling worldwide \nwith voicemail http://uk.messenger.yahoo.com\n\n\n\n"}}