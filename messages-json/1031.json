{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":183620859,"authorName":"Philip Tucker","from":"&quot;Philip Tucker&quot; &lt;ptucker@...&gt;","profile":"tucker0171","replyTo":"LIST","senderId":"K4rvEVWywreLYUWBB10uICEozWB6xn4XzWM0QOvkTHh-gR7DZblq8TyRgFruYYToYDlvNjCEnvLqxapRZ6JRL2BXWzghxdZOzOg","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: Computation Time","postDate":"1086663476","msgId":1031,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGNhMzl2ays0djFhQGVHcm91cHMuY29tPg==","inReplyToHeader":"PGM5bnI1aSs5YjE0QGVHcm91cHMuY29tPg=="},"prevInTopic":1018,"nextInTopic":1032,"prevInTime":1030,"nextInTime":1032,"topicId":845,"numMessagesInTopic":99,"msgSnippet":"... If anyone s interested, I just did an analysis of this function vs the traditional sigmoid, and the inverse absolute value function Ian posted earlier vs","rawEmail":"Return-Path: &lt;ptucker@...&gt;\r\nX-Sender: ptucker@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 11256 invoked from network); 8 Jun 2004 02:58:31 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m23.grp.scd.yahoo.com with QMQP; 8 Jun 2004 02:58:31 -0000\r\nReceived: from unknown (HELO n14.grp.scd.yahoo.com) (66.218.66.69)\n  by mta3.grp.scd.yahoo.com with SMTP; 8 Jun 2004 02:58:31 -0000\r\nReceived: from [66.218.67.249] by n14.grp.scd.yahoo.com with NNFMP; 08 Jun 2004 02:57:57 -0000\r\nDate: Tue, 08 Jun 2004 02:57:56 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;ca39vk+4v1a@...&gt;\r\nIn-Reply-To: &lt;c9nr5i+9b14@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 2076\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-eGroups-Remote-IP: 66.218.66.69\r\nFrom: &quot;Philip Tucker&quot; &lt;ptucker@...&gt;\r\nSubject: Re: Computation Time\r\nX-Yahoo-Group-Post: member; u=183620859\r\nX-Yahoo-Profile: tucker0171\r\n\r\n--- In neat@yahoogroups.com, &quot;zenguyuno&quot; &lt;zenguyuno@y...&gt; wrote:\n&gt;\n&gt; Unless it&#39;s already been done!  Here is a ready-to-use sigmoid \n&gt; approximator in C, taken from the file neursubs.c of the EvSail \n&gt; package:\n&gt; \n&gt; /* This 4 piece curve is a good sigmoid approximator. */\n&gt; float sigAprox(register float x)  {\n&gt;     register float z;             \n&gt;     \n&gt;     if(x &lt;= -4.0)\n&gt; \treturn 0.0;\n&gt;     else if(x &lt;= 0.0) {\n&gt;         z = x + 4.0;\n&gt;         return z*z/32;\n&gt;     } \n&gt;     else if(x &lt; 4.0)  {\n&gt;         z = x - 4.0;\n&gt;         return 1.0 - z*z/32;   \n&gt;     }    \n&gt;     else\n&gt; \treturn 1.0;\n&gt; }    \n\nIf anyone&#39;s interested, I just did an analysis of this function vs \nthe traditional sigmoid, and the inverse absolute value function Ian \nposted earlier vs tanh.  I added a spread sheet \n(activation_functions.xls) to the files section comparing the \nvalues.  Here are the functions ...\n\nsigmoid:  y = 1 / ( 1 + EXP( -( x * 4.924273 ) ) )\nevsail:   &lt;see above&gt;\ntanh:     y = -1 + ( 2 / ( 1 + EXP( -2 * ( x ) ) ) )\ninv-abs:  y = x / ( 1 + ABS( x ) )\n\n... where EXP is exponential function (i.e., EXP(x) is e raised to \nthe power of x) and ABS is absolute value.  We got the sigmoid and \ntanh functions from JOONE source (http://www.jooneworld.com/).\n\nI ran 2 million activations each with each one to compare \nperformance.  This is all on my laptop (PIII, 850MHz, 256MB RAM) on \nJVM 1.4.  Results:\n\n- the EvSail sigmoid approximation was about 4 times faster than the \ntraditional sigmoid; ~90ms vs ~360ms.\n- the inverse absolute value function was about 2.5 times faster \nthan the traditional tanh; ~170ms vs ~400ms.\n\nI&#39;d be interested to know if similar performance benefits can be had \nin C, or any other languages.  I&#39;m also curious to know if there are \nany other pitfalls from using such approximation functions, or even \nsimple step functions.  For example, is it crucial that the function \nbe continuous?  I assume it is since the evolutionary algorithm is a \nform of hill climbing.  But, how smooth/steep is the optimal curve?  \nOr is it domain dependant?\n\n- Philip\n\n\n"}}