{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":203001720,"authorName":"Wesley Tansey","from":"Wesley Tansey &lt;tansey@...&gt;","profile":"tansey4","replyTo":"LIST","senderId":"xEOsJu5Gw4foHIE_ElkII-AeGfzg3NvknqFX2U_H35tQYlGEbmQbCr6apOklhukeIBPA2JJWAcMr9u5fym777p8sb1M","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Re: Evolving feedforward networks","postDate":"1261004139","msgId":5022,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDU2YzJmY2UwMDkxMjE2MTQ1NWwxZjE0YThkYXRkNWZkOTg2NDQwY2YyOTEzQG1haWwuZ21haWwuY29tPg==","inReplyToHeader":"PGhnYm5yZSt1cWpzQGVHcm91cHMuY29tPg==","referencesHeader":"PGhnOTUzaStwanVzQGVHcm91cHMuY29tPiA8aGdibnJlK3VxanNAZUdyb3Vwcy5jb20+"},"prevInTopic":5021,"nextInTopic":5024,"prevInTime":5021,"nextInTime":5023,"topicId":5013,"numMessagesInTopic":14,"msgSnippet":"Hi Peter, Couldn t you just require that an edge from A- B is only valid if Level(A) ","rawEmail":"Return-Path: &lt;tansey@...&gt;\r\nX-Sender: tansey@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 16672 invoked from network); 16 Dec 2009 22:55:41 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m2.grp.sp2.yahoo.com with QMQP; 16 Dec 2009 22:55:41 -0000\r\nX-Received: from unknown (HELO lennier.cc.vt.edu) (198.82.162.213)\n  by mta2.grp.re1.yahoo.com with SMTP; 16 Dec 2009 22:55:41 -0000\r\nX-Received: from steiner.cc.vt.edu (steiner.cc.vt.edu [198.82.163.51])\n\tby lennier.cc.vt.edu (8.13.8/8.13.8) with ESMTP id nBGMteGr023744\n\tfor &lt;neat@yahoogroups.com&gt;; Wed, 16 Dec 2009 17:55:41 -0500\r\nX-Received: from mail-iw0-f190.google.com (EHLO mail-iw0-f190.google.com) ([209.85.223.190])\n\tby steiner.cc.vt.edu (MOS 4.1.8-GA FastPath queued)\n\twith ESMTP id DWH20374;\n\tWed, 16 Dec 2009 17:55:40 -0500 (EST)\r\nX-Received: by mail-iw0-f190.google.com with SMTP id 28so1065496iwn.13\n        for &lt;neat@yahoogroups.com&gt;; Wed, 16 Dec 2009 14:55:40 -0800 (PST)\r\nMIME-Version: 1.0\r\nX-Received: by 10.231.167.65 with SMTP id p1mr1570611iby.20.1261004139517; Wed, \n\t16 Dec 2009 14:55:39 -0800 (PST)\r\nIn-Reply-To: &lt;hgbnre+uqjs@...&gt;\r\nReferences: &lt;hg953i+pjus@...&gt; &lt;hgbnre+uqjs@...&gt;\r\nDate: Wed, 16 Dec 2009 14:55:39 -0800\r\nMessage-ID: &lt;56c2fce00912161455l1f14a8datd5fd986440cf2913@...&gt;\r\nTo: neat@yahoogroups.com\r\nContent-Type: multipart/alternative; boundary=001636d3448dcbd620047ae0674d\r\nX-Mirapoint-Received-SPF: 209.85.223.190 mail-iw0-f190.google.com tansey@... 4 softfail\r\nX-Mirapoint-IP-Reputation: reputation=Good-1,\n\tsource=Queried,\n\trefid=0001.0A020302.4B295F5C.008F,\n\tactions=TAG SPF\r\nX-Junkmail-Info: (0) HTML_MESSAGE\r\nX-Junkmail-Status: score=10/50, host=steiner.cc.vt.edu\r\nX-Junkmail-SD-Raw: score=unknown,\n\trefid=str=0001.0A020206.4B29656C.01E2,ss=1,fgs=0,\n\tip=0.0.0.0,\n\tso=2009-09-22 00:05:22,\n\tdmn=2009-09-10 00:05:08,\n\tmode=multiengine\r\nX-Junkmail-IWF: false\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Wesley Tansey &lt;tansey@...&gt;\r\nSubject: Re: [neat] Re: Evolving feedforward networks\r\nX-Yahoo-Group-Post: member; u=203001720; y=BFKklbghTJt-LR1BPoQD8qRDtJY44OjBM1wuqlQgL8WzrQ\r\nX-Yahoo-Profile: tansey4\r\n\r\n\r\n--001636d3448dcbd620047ae0674d\r\nContent-Type: text/plain; charset=windows-1252\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\nHi Peter,\n\nCouldn&#39;t you just require that an edge from A-&gt;B is only valid i=\r\nf Level(A) &lt;\nLevel(B), rather than Level(A) &lt;=3D Level(B)? That would seem =\r\nto prevent the\nproblem.\n\nWesley\n\nOn Wed, Dec 16, 2009 at 2:43 PM, petar_che=\r\nrvenski &lt;\npetar_chervenski@...&gt; wrote:\n\n&gt;\n&gt;\n&gt; Yes, in my NEAT impleme=\r\nntation I use this (Mat Buckland&#39;s) approach.\n&gt; However, there is one probl=\r\nem. If we have 3 hidden nodes on the same level,\n&gt; say A, B and C, and add =\r\nlinks like A-&gt;B, B-&gt;C, C-&gt;A this forms a loop which\n&gt; I believe is a form o=\r\nf recurrence. Or actually.. is that a problem at all? I\n&gt; couldn&#39;t find a g=\r\nood solution for it. How to prevent such nasty loops from\n&gt; forming in the =\r\nfeed-forward network?\n&gt;\n&gt; Peter\n&gt;\n&gt;\n&gt; --- In neat@yahoogroups.com &lt;neat%40y=\r\nahoogroups.com&gt;, &quot;Ken&quot; &lt;kstanley@...&gt;\n&gt; wrote:\n&gt; &gt;\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; Colin, one t=\r\nhing that comes to mind is the way Mat Buckland&#39;s\n&gt; implementation addresse=\r\ns the issue of detecting potential recurrent links\n&gt; efficiently. I think w=\r\ne might have discussed this approach on this group a\n&gt; long time ago? The b=\r\nasic idea is that each node has a &quot;row-level&quot; floating\n&gt; point number. The =\r\ninputs are row-level 0 and the outputs are row-level 1.\n&gt; Every time a new =\r\nnode is added that splits a feedforward link, it gets a\n&gt; row-level halfway=\r\n between the source and target nodes. For example, if it\n&gt; split a link bet=\r\nween rows 0 and 1, it would have row-level 0.5. Now to\n&gt; determine whether =\r\na potential link would be recurrent, all you need to do is\n&gt; check whether =\r\nit connected a source node to a target node at an equivalent\n&gt; or lower row=\r\n-level.\n&gt; &gt;\n&gt; &gt; I believe the only catch is what to do when splitting alrea=\r\ndy-recurrent\n&gt; connections. However, if you are just trying to create stric=\r\ntly feedforward\n&gt; networks, they won&#39;t exist, so it won&#39;t be an issue.\n&gt; &gt;\n=\r\n&gt; &gt; It&#39;s possible I got some part of the procedure slightly wrong in the\n&gt; =\r\ndescription above, but I believe that is the gist of it.\n&gt; &gt;\n&gt; &gt; ken\n&gt; &gt;\n&gt; =\r\n&gt; --- In neat@yahoogroups.com &lt;neat%40yahoogroups.com&gt;, Colin Green\n&gt; &lt;coli=\r\nn.green1@&gt; wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; Hi,\n&gt; &gt; &gt;\n&gt; &gt; &gt; Ken&#39;s response to Daniel Tuoh=\r\ny&#39;s yesterday briefly touched on\n&gt; &gt; &gt; evolution of feedforward-only networ=\r\nks and this is somethign I&#39;ve been\n&gt; &gt; &gt; meaning to think about for some ti=\r\nme. My initial thoughts on how to do\n&gt; &gt; &gt; this relatively efficiently are =\r\nas follows:\n&gt; &gt; &gt;\n&gt; &gt; &gt; 1) Start out with a feedforward only graph (e.g. th=\r\ne typical NEAT\n&gt; &gt; &gt; initial population with conenctions from inputs to out=\r\nputs).\n&gt; &gt; &gt; 2) We initialise each node with a list of all the nodes that a=\r\nre above\n&gt; &gt; &gt; it in the graph, let&#39;s call this the &#39;ancestor&#39; list (A-list=\r\n or A-node\n&gt; &gt; &gt; list for short)\n&gt; &gt; &gt; 3) With recursive networks, in order=\r\n to add a connection we typically\n&gt; &gt; &gt; randomly search pairs of source and=\r\n target node IDs until we find a\n&gt; &gt; &gt; pair that does not exist in the exis=\r\ntign connection genes. Now we can\n&gt; &gt; &gt; add the additional test that the ta=\r\nrget node ID is not in the source\n&gt; &gt; &gt; node&#39;s A-list. This eliminates the =\r\nneed to traverse the network,\n&gt; &gt; &gt; effectively recalculating each node&#39;s A=\r\n-List each time.\n&gt; &gt; &gt; 4) When we create a new node by splitting a conencti=\r\non, the new node\n&gt; &gt; &gt; creates it&#39;s own A-list by takign a copy the source =\r\nnode&#39;s A-List plus\n&gt; &gt; &gt; the source node&#39;s ID.\n&gt; &gt; &gt;\n&gt; &gt; &gt; The A-lists can =\r\nbecome part of the genome so that we never have to\n&gt; &gt; &gt; traverse networks =\r\nto rebuild A-lists, they just get copied when we\n&gt; &gt; &gt; create offspring gen=\r\nomes/networks. Ok so now you&#39;re all thinking that\n&gt; &gt; &gt; the memory requirem=\r\nents for this could get unwieldy. We can reduce\n&gt; &gt; &gt; memory requirements b=\r\ny using bitmaps where each node ID get&#39;s it&#39;s own\n&gt; &gt; &gt; location in an arra=\r\ny of bits, thus if the IDs are 32bit integers we\n&gt; &gt; &gt; get a 32x reduction =\r\nin storage space requirements. As a bonus, testing\n&gt; &gt; &gt; if a node is in a =\r\ngiven A-list should be almost intantaneous, versus\n&gt; &gt; &gt; the O(log n) time =\r\ncomplexity of a binary search against a sorted list\n&gt; &gt; &gt; of integer IDs.\n&gt;=\r\n &gt; &gt;\n&gt; &gt; &gt; The first problem I see is that the set of innovation IDs curren=\r\ntly in\n&gt; &gt; &gt; use in a given population becomes patchy, e.g. some early IDs =\r\nmay\n&gt; &gt; &gt; simply not exist any more (although I&#39;m not 100% if this happens =\r\nin\n&gt; &gt; &gt; reality). So lets say NEAT has been running a while and the innova=\r\ntion\n&gt; &gt; &gt; ID variable is up to 100,000. Each node requires its own bit in =\r\neach\n&gt; &gt; &gt; A-list regardless of whether it is set or not, therefore the A-l=\r\nists\n&gt; &gt; &gt; are 100000/8 =3D 12,500 bytes in size (I&#39;m assuming the A-lists =\r\ngrow\n&gt; &gt; &gt; over time, along with the innovation ID counter). We can however=\r\n\n&gt; &gt; &gt; reduce this memory requirement by periodically stoppign NEAT and\n&gt; &gt;=\r\n &gt; defragmenting the ID space, this allows us to reuse the low IDs that\n&gt; &gt;=\r\n &gt; are no longer in use anymore (no node anywhere in the population uses\n&gt; =\r\n&gt; &gt; it) and thus the size of the A-list only needs to refelct the number\n&gt; =\r\n&gt; &gt; of /active/ node IDs rather than the number of IDs there has ever\n&gt; &gt; &gt;=\r\n been.\n&gt; &gt; &gt;\n&gt; &gt; &gt; Thinking ahead to distributed-NEAT algorithms this poten=\r\ntially creates\n&gt; &gt; &gt; a new problem when/if we need to pass genome between c=\r\nlusteres - the\n&gt; &gt; &gt; node IDs of like nodes no longer match up. The propose=\r\nd solution there\n&gt; &gt; &gt; is to have a periodic system wide defragmentation ta=\r\nke place\n&gt; &gt; &gt; encompassing all nodes, or alternatively each distribution n=\r\node\n&gt; &gt; &gt; maintains a mapping between &#39;global&#39; innovation IDs and the local=\r\n\n&gt; &gt; &gt; defragmented IDs.\n&gt; &gt; &gt;\n&gt; &gt; &gt; I&#39;d be interested hear other&#39;s ideas o=\r\nn this topic. Perhaps there&#39;s\n&gt; &gt; &gt; some more elegant approach using clever=\r\n allocation of IDs to indicate\n&gt; &gt; &gt; where a node lies in the network of an=\r\ncestors, e.g. if node IDs are\n&gt; &gt; &gt; taken to be a height measured from top =\r\nto bottom of the network, we\n&gt; &gt; &gt; can assign and modify node IDs so that w=\r\ne can simply compare two IDs\n&gt; &gt; &gt; to see their relative position in the to=\r\np-down graph - the problem\n&gt; &gt; &gt; there being that we can no longer use the =\r\nIDs as innovation numbers;\n&gt; &gt; &gt; However we could simply use two variables =\r\n- innovation ID and a\n&gt; &gt; &gt; height/position. One downside there is that onl=\r\ny one node can occupy a\n&gt; &gt; &gt; given height and since the number of height l=\r\nevels is limits (e.g. to\n&gt; &gt; &gt; 2^32 for a 32 bit variable) the number of no=\r\ndes in a network is\n&gt; &gt; &gt; limited, on the other hand that&#39;s potentially a v=\r\nery high limit.\n&gt; &gt; &gt; Perhaps the tricky part is decidign what to do when m=\r\nating two\n&gt; &gt; &gt; networks.\n&gt; &gt; &gt;\n&gt; &gt; &gt; This post is already too long so I&#39;m =\r\ngoing to stop :)\n&gt; &gt; &gt;\n&gt; &gt; &gt; Colin\n&gt; &gt; &gt;\n&gt; &gt;\n&gt;\n&gt;  \n&gt;\n\r\n--001636d3448dcbd620047ae0674d\r\nContent-Type: text/html; charset=windows-1252\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\nHi Peter,&lt;br&gt;&lt;br&gt;Couldn&#39;t you just require that an edge from A-&gt;B is=\r\n only valid if Level(A) &lt; Level(B), rather than Level(A) &lt;=3D Level(B=\r\n)? That would seem to prevent the problem.&lt;br&gt;&lt;br&gt;Wesley&lt;br&gt;&lt;br&gt;&lt;div class=\r\n=3D&quot;gmail_quote&quot;&gt;\nOn Wed, Dec 16, 2009 at 2:43 PM, petar_chervenski &lt;span d=\r\nir=3D&quot;ltr&quot;&gt;&lt;&lt;a href=3D&quot;mailto:petar_chervenski@...&quot;&gt;petar_chervens=\r\nki@...&lt;/a&gt;&gt;&lt;/span&gt; wrote:&lt;br&gt;&lt;blockquote class=3D&quot;gmail_quote&quot; sty=\r\nle=3D&quot;border-left: 1px solid rgb(204, 204, 204); margin: 0pt 0pt 0pt 0.8ex;=\r\n padding-left: 1ex;&quot;&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;div style=3D&quot;background-color: rgb(255=\r\n, 255, 255);&quot;&gt;\n&lt;span&gt;=A0&lt;/span&gt;\n\n\n&lt;div&gt;\n  &lt;div&gt;\n\n\n    &lt;div&gt;\n      \n      \n =\r\n     &lt;p&gt;Yes, in my NEAT implementation I use this (Mat Buckland&#39;s) appr=\r\noach. However, there is one problem. If we have 3 hidden nodes on the same =\r\nlevel, say A, B and C, and add links like A-&gt;B, B-&gt;C, C-&gt;A this fo=\r\nrms a loop which I believe is a form of recurrence. Or actually.. is that a=\r\n problem at all? I couldn&#39;t find a good solution for it. How to prevent=\r\n such nasty loops from forming in the feed-forward network? &lt;br&gt;\n\n&lt;br&gt;\nPete=\r\nr&lt;/p&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=3D&quot;h5&quot;&gt;&lt;br&gt;\n&lt;br&gt;\n--- In &lt;a href=3D&quot;mailto:n=\r\neat%40yahoogroups.com&quot; target=3D&quot;_blank&quot;&gt;neat@yahoogroups.com&lt;/a&gt;, &quot;Ke=\r\nn&quot; &lt;kstanley@...&gt; wrote:&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; &lt;br&gt;\n&gt; C=\r\nolin, one thing that comes to mind is the way Mat Buckland&#39;s implementa=\r\ntion addresses the issue of detecting potential recurrent links efficiently=\r\n.  I think we might have discussed this approach on this group a long time =\r\nago?  The basic idea is that each node has a &quot;row-level&quot; floating=\r\n point number.  The inputs are row-level 0 and the outputs are row-level 1.=\r\n  Every time a new node is added that splits a feedforward link, it gets a =\r\nrow-level halfway between the source and target nodes.  For example, if it =\r\nsplit a link between rows 0 and 1, it would have row-level 0.5.  Now to det=\r\nermine whether a potential link would be recurrent, all you need to do is c=\r\nheck whether it connected a source node to a target node at an equivalent o=\r\nr lower row-level.&lt;br&gt;\n\n&gt; &lt;br&gt;\n&gt; I believe the only catch is what to =\r\ndo when splitting already-recurrent connections.  However, if you are just =\r\ntrying to create strictly feedforward networks, they won&#39;t exist, so it=\r\n won&#39;t be an issue.&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; It&#39;s possible I got some par=\r\nt of the procedure slightly wrong in the description above, but I believe t=\r\nhat is the gist of it.&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; ken&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; --- In &lt;a =\r\nhref=3D&quot;mailto:neat%40yahoogroups.com&quot; target=3D&quot;_blank&quot;&gt;neat@yahoogroups.c=\r\nom&lt;/a&gt;, Colin Green &lt;colin.green1@&gt; wrote:&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt; &gt=\r\n; Hi,&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; Ken&#39;s response to Daniel Tuohy&#39;s=\r\n yesterday briefly touched on&lt;br&gt;\n&gt; &gt; evolution of feedforward-only n=\r\networks and this is somethign I&#39;ve been&lt;br&gt;\n&gt; &gt; meaning to think =\r\nabout for some time. My initial thoughts on how to do&lt;br&gt;\n&gt; &gt; this re=\r\nlatively efficiently are as follows:&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; 1) Start =\r\nout with a feedforward only graph (e.g. the typical NEAT&lt;br&gt;\n&gt; &gt; init=\r\nial population with conenctions from inputs to outputs).&lt;br&gt;\n&gt; &gt; 2) W=\r\ne initialise each node with a list of all the nodes that are above&lt;br&gt;\n&gt;=\r\n &gt; it in the graph, let&#39;s call this the &#39;ancestor&#39; list (A-l=\r\nist or A-node&lt;br&gt;\n&gt; &gt; list for short)&lt;br&gt;\n&gt; &gt; 3) With recursive=\r\n networks, in order to add a connection we typically&lt;br&gt;\n&gt; &gt; randomly=\r\n search pairs of source and target node IDs until we find a&lt;br&gt;\n&gt; &gt; p=\r\nair that does not exist in the existign connection genes. Now we can&lt;br&gt;\n&g=\r\nt; &gt; add the additional test that the target node ID is not in the sourc=\r\ne&lt;br&gt;\n&gt; &gt; node&#39;s A-list. This eliminates the need to traverse the=\r\n network,&lt;br&gt;\n&gt; &gt; effectively recalculating each node&#39;s A-List ea=\r\nch time.&lt;br&gt;\n&gt; &gt; 4) When we create a new node by splitting a conencti=\r\non, the new node&lt;br&gt;\n&gt; &gt; creates it&#39;s own A-list by takign a copy=\r\n the source node&#39;s A-List plus&lt;br&gt;\n&gt; &gt; the source node&#39;s ID.&lt;=\r\nbr&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; The A-lists can become part of the genome so t=\r\nhat we never have to&lt;br&gt;\n&gt; &gt; traverse networks to rebuild A-lists, th=\r\ney just get copied when we&lt;br&gt;\n&gt; &gt; create offspring genomes/networks.=\r\n Ok so now you&#39;re all thinking that&lt;br&gt;\n&gt; &gt; the memory requiremen=\r\nts for this could get unwieldy. We can reduce&lt;br&gt;\n&gt; &gt; memory requirem=\r\nents by using bitmaps where each node ID get&#39;s it&#39;s own&lt;br&gt;\n&gt; &g=\r\nt; location in an array of bits, thus if the IDs are 32bit integers we&lt;br&gt;\n=\r\n&gt; &gt; get a 32x reduction in storage space requirements. As a bonus, te=\r\nsting&lt;br&gt;\n&gt; &gt; if a node is in a given A-list should be almost intanta=\r\nneous, versus&lt;br&gt;\n&gt; &gt; the O(log n) time complexity of a binary search=\r\n against a sorted list&lt;br&gt;\n&gt; &gt; of integer IDs.&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt=\r\n; &gt; The first problem I see is that the set of innovation IDs currently =\r\nin&lt;br&gt;\n&gt; &gt; use in a given population becomes patchy, e.g. some early =\r\nIDs may&lt;br&gt;\n&gt; &gt; simply not exist any more (although I&#39;m not 100% =\r\nif this happens in&lt;br&gt;\n&gt; &gt; reality). So lets say NEAT has been runnin=\r\ng a while and the innovation&lt;br&gt;\n&gt; &gt; ID variable is up to 100,000. Ea=\r\nch node requires its own bit in each&lt;br&gt;\n&gt; &gt; A-list regardless of whe=\r\nther it is set or not, therefore the A-lists&lt;br&gt;\n&gt; &gt; are 100000/8 =3D=\r\n 12,500 bytes in size (I&#39;m assuming the A-lists grow&lt;br&gt;\n&gt; &gt; over=\r\n time, along with the innovation ID counter). We can however&lt;br&gt;\n&gt; &gt; =\r\nreduce this memory requirement by periodically stoppign NEAT and&lt;br&gt;\n&gt; &=\r\ngt; defragmenting the ID space, this allows us to reuse the low IDs that&lt;br=\r\n&gt;\n&gt; &gt; are no longer in use anymore (no node anywhere in the populatio=\r\nn uses&lt;br&gt;\n&gt; &gt; it) and thus the size of the A-list only needs to refe=\r\nlct the number&lt;br&gt;\n&gt; &gt; of /active/ node IDs rather than the number of=\r\n IDs there has ever&lt;br&gt;\n&gt; &gt; been.&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; Thinki=\r\nng ahead to distributed-NEAT algorithms this potentially creates&lt;br&gt;\n&gt; &=\r\ngt; a new problem when/if we need to pass genome between clusteres - the&lt;br=\r\n&gt;\n&gt; &gt; node IDs of like nodes no longer match up. The proposed solutio=\r\nn there&lt;br&gt;\n&gt; &gt; is to have a periodic system wide defragmentation tak=\r\ne place&lt;br&gt;\n&gt; &gt; encompassing all nodes, or alternatively each distrib=\r\nution node&lt;br&gt;\n&gt; &gt; maintains a mapping between &#39;global&#39; innov=\r\nation IDs and the local&lt;br&gt;\n&gt; &gt; defragmented IDs.&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n=\r\n&gt; &gt; I&#39;d be interested hear other&#39;s ideas on this topic. Perha=\r\nps there&#39;s&lt;br&gt;\n&gt; &gt; some more elegant approach using clever alloca=\r\ntion of IDs to indicate&lt;br&gt;\n&gt; &gt; where a node lies in the network of a=\r\nncestors, e.g. if node IDs are&lt;br&gt;\n&gt; &gt; taken to be a height measured =\r\nfrom top to bottom of the network, we&lt;br&gt;\n&gt; &gt; can assign and modify n=\r\node IDs so that we can simply compare two IDs&lt;br&gt;\n&gt; &gt; to see their re=\r\nlative position in the top-down graph - the problem&lt;br&gt;\n&gt; &gt; there bei=\r\nng that we can no longer use the IDs as innovation numbers;&lt;br&gt;\n&gt; &gt; H=\r\nowever we could simply use two variables - innovation ID and a&lt;br&gt;\n&gt; &gt=\r\n; height/position. One downside there is that only one node can occupy a&lt;br=\r\n&gt;\n&gt; &gt; given height and since the number of height levels is limits (e=\r\n.g. to&lt;br&gt;\n&gt; &gt; 2^32 for a 32 bit variable) the number of nodes in a n=\r\network is&lt;br&gt;\n&gt; &gt; limited, on the other hand that&#39;s potentially a=\r\n very high limit.&lt;br&gt;\n&gt; &gt; Perhaps the tricky part is decidign what to=\r\n do when mating two&lt;br&gt;\n&gt; &gt; networks.&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; Th=\r\nis post is already too long so I&#39;m going to stop :)&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n=\r\n&gt; &gt; Colin&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt;&lt;br&gt;\n&lt;br&gt;\n&lt;/div&gt;&lt;/div&gt;\n\n    &lt;/div&gt;\n  =\r\n   \n\n    \n    &lt;div style=3D&quot;color: rgb(255, 255, 255); min-height: 0pt;&quot;&gt;&lt;/=\r\ndiv&gt;\n\n\n&lt;/div&gt;\n\n\n\n  \n\n\n\n\n\n\n&lt;/blockquote&gt;&lt;/div&gt;&lt;br&gt;\n\r\n--001636d3448dcbd620047ae0674d--\r\n\n"}}