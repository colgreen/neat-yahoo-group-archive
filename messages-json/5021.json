{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":283334584,"authorName":"petar_chervenski","from":"&quot;petar_chervenski&quot; &lt;petar_chervenski@...&gt;","profile":"petar_chervenski","replyTo":"LIST","senderId":"nVFKGqjyl_Dcyah4My1K-ZMeptsboK1PiBQHzQLn3xtLG3EF52GmmcATYXVTgZutk6se-jbV9WiK2OL7gSLOXBd_pY1U2ivlf_XmnDLL2k52guAahvA","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: Evolving feedforward networks","postDate":"1261003438","msgId":5021,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGhnYm5yZSt1cWpzQGVHcm91cHMuY29tPg==","inReplyToHeader":"PGhnOTUzaStwanVzQGVHcm91cHMuY29tPg=="},"prevInTopic":5018,"nextInTopic":5022,"prevInTime":5020,"nextInTime":5022,"topicId":5013,"numMessagesInTopic":14,"msgSnippet":"Yes, in my NEAT implementation I use this (Mat Buckland s) approach. However, there is one problem. If we have 3 hidden nodes on the same level, say A, B and","rawEmail":"Return-Path: &lt;petar_chervenski@...&gt;\r\nX-Sender: petar_chervenski@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 82872 invoked from network); 16 Dec 2009 22:43:58 -0000\r\nX-Received: from unknown (98.137.34.44)\n  by m3.grp.sp2.yahoo.com with QMQP; 16 Dec 2009 22:43:58 -0000\r\nX-Received: from unknown (HELO n45b.bullet.mail.sp1.yahoo.com) (66.163.168.159)\n  by mta1.grp.sp2.yahoo.com with SMTP; 16 Dec 2009 22:43:58 -0000\r\nX-Received: from [69.147.65.171] by n45.bullet.mail.sp1.yahoo.com with NNFMP; 16 Dec 2009 22:43:58 -0000\r\nX-Received: from [98.137.34.72] by t13.bullet.mail.sp1.yahoo.com with NNFMP; 16 Dec 2009 22:43:58 -0000\r\nDate: Wed, 16 Dec 2009 22:43:58 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;hgbnre+uqjs@...&gt;\r\nIn-Reply-To: &lt;hg953i+pjus@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;petar_chervenski&quot; &lt;petar_chervenski@...&gt;\r\nSubject: Re: Evolving feedforward networks\r\nX-Yahoo-Group-Post: member; u=283334584; y=Aqbp1L0dDlP00zglVqQNzIAjUSJv6rX8HW-URWHuOYwC5DAj_01ziMSjmw\r\nX-Yahoo-Profile: petar_chervenski\r\n\r\nYes, in my NEAT implementation I use this (Mat Buckland&#39;s) approach. Howeve=\r\nr, there is one problem. If we have 3 hidden nodes on the same level, say A=\r\n, B and C, and add links like A-&gt;B, B-&gt;C, C-&gt;A this forms a loop which I be=\r\nlieve is a form of recurrence. Or actually.. is that a problem at all? I co=\r\nuldn&#39;t find a good solution for it. How to prevent such nasty loops from fo=\r\nrming in the feed-forward network? \n\nPeter\n\n--- In neat@yahoogroups.com, &quot;K=\r\nen&quot; &lt;kstanley@...&gt; wrote:\n&gt;\n&gt; \n&gt; \n&gt; Colin, one thing that comes to mind is =\r\nthe way Mat Buckland&#39;s implementation addresses the issue of detecting pote=\r\nntial recurrent links efficiently.  I think we might have discussed this ap=\r\nproach on this group a long time ago?  The basic idea is that each node has=\r\n a &quot;row-level&quot; floating point number.  The inputs are row-level 0 and the o=\r\nutputs are row-level 1.  Every time a new node is added that splits a feedf=\r\norward link, it gets a row-level halfway between the source and target node=\r\ns.  For example, if it split a link between rows 0 and 1, it would have row=\r\n-level 0.5.  Now to determine whether a potential link would be recurrent, =\r\nall you need to do is check whether it connected a source node to a target =\r\nnode at an equivalent or lower row-level.\n&gt; \n&gt; I believe the only catch is =\r\nwhat to do when splitting already-recurrent connections.  However, if you a=\r\nre just trying to create strictly feedforward networks, they won&#39;t exist, s=\r\no it won&#39;t be an issue.\n&gt; \n&gt; It&#39;s possible I got some part of the procedure=\r\n slightly wrong in the description above, but I believe that is the gist of=\r\n it.\n&gt; \n&gt; ken\n&gt; \n&gt; --- In neat@yahoogroups.com, Colin Green &lt;colin.green1@&gt;=\r\n wrote:\n&gt; &gt;\n&gt; &gt; Hi,\n&gt; &gt; \n&gt; &gt; Ken&#39;s response to Daniel Tuohy&#39;s yesterday bri=\r\nefly touched on\n&gt; &gt; evolution of feedforward-only networks and this is some=\r\nthign I&#39;ve been\n&gt; &gt; meaning to think about for some time. My initial though=\r\nts on how to do\n&gt; &gt; this relatively efficiently are as follows:\n&gt; &gt; \n&gt; &gt; 1)=\r\n Start out with a feedforward only graph (e.g. the typical NEAT\n&gt; &gt; initial=\r\n population with conenctions from inputs to outputs).\n&gt; &gt; 2) We initialise =\r\neach node with a list of all the nodes that are above\n&gt; &gt; it in the graph, =\r\nlet&#39;s call this the &#39;ancestor&#39; list (A-list or A-node\n&gt; &gt; list for short)\n&gt;=\r\n &gt; 3) With recursive networks, in order to add a connection we typically\n&gt; =\r\n&gt; randomly search pairs of source and target node IDs until we find a\n&gt; &gt; p=\r\nair that does not exist in the existign connection genes. Now we can\n&gt; &gt; ad=\r\nd the additional test that the target node ID is not in the source\n&gt; &gt; node=\r\n&#39;s A-list. This eliminates the need to traverse the network,\n&gt; &gt; effectivel=\r\ny recalculating each node&#39;s A-List each time.\n&gt; &gt; 4) When we create a new n=\r\node by splitting a conenction, the new node\n&gt; &gt; creates it&#39;s own A-list by =\r\ntakign a copy the source node&#39;s A-List plus\n&gt; &gt; the source node&#39;s ID.\n&gt; &gt; \n=\r\n&gt; &gt; The A-lists can become part of the genome so that we never have to\n&gt; &gt; =\r\ntraverse networks to rebuild A-lists, they just get copied when we\n&gt; &gt; crea=\r\nte offspring genomes/networks. Ok so now you&#39;re all thinking that\n&gt; &gt; the m=\r\nemory requirements for this could get unwieldy. We can reduce\n&gt; &gt; memory re=\r\nquirements by using bitmaps where each node ID get&#39;s it&#39;s own\n&gt; &gt; location =\r\nin an array of bits, thus if the IDs are 32bit integers we\n&gt; &gt; get a 32x re=\r\nduction in storage space requirements. As a bonus, testing\n&gt; &gt; if a node is=\r\n in a given A-list should be almost intantaneous, versus\n&gt; &gt; the O(log n) t=\r\nime complexity of a binary search against a sorted list\n&gt; &gt; of integer IDs.=\r\n\n&gt; &gt; \n&gt; &gt; The first problem I see is that the set of innovation IDs current=\r\nly in\n&gt; &gt; use in a given population becomes patchy, e.g. some early IDs may=\r\n\n&gt; &gt; simply not exist any more (although I&#39;m not 100% if this happens in\n&gt; =\r\n&gt; reality). So lets say NEAT has been running a while and the innovation\n&gt; =\r\n&gt; ID variable is up to 100,000. Each node requires its own bit in each\n&gt; &gt; =\r\nA-list regardless of whether it is set or not, therefore the A-lists\n&gt; &gt; ar=\r\ne 100000/8 =3D 12,500 bytes in size (I&#39;m assuming the A-lists grow\n&gt; &gt; over=\r\n time, along with the innovation ID counter). We can however\n&gt; &gt; reduce thi=\r\ns memory requirement by periodically stoppign NEAT and\n&gt; &gt; defragmenting th=\r\ne ID space, this allows us to reuse the low IDs that\n&gt; &gt; are no longer in u=\r\nse anymore (no node anywhere in the population uses\n&gt; &gt; it) and thus the si=\r\nze of the A-list only needs to refelct the number\n&gt; &gt; of /active/ node IDs =\r\nrather than the number of IDs there has ever\n&gt; &gt; been.\n&gt; &gt; \n&gt; &gt; Thinking ah=\r\nead to distributed-NEAT algorithms this potentially creates\n&gt; &gt; a new probl=\r\nem when/if we need to pass genome between clusteres - the\n&gt; &gt; node IDs of l=\r\nike nodes no longer match up. The proposed solution there\n&gt; &gt; is to have a =\r\nperiodic system wide defragmentation take place\n&gt; &gt; encompassing all nodes,=\r\n or alternatively each distribution node\n&gt; &gt; maintains a mapping between &#39;g=\r\nlobal&#39; innovation IDs and the local\n&gt; &gt; defragmented IDs.\n&gt; &gt; \n&gt; &gt; I&#39;d be i=\r\nnterested hear other&#39;s ideas on this topic. Perhaps there&#39;s\n&gt; &gt; some more e=\r\nlegant approach using clever allocation of IDs to indicate\n&gt; &gt; where a node=\r\n lies in the network of ancestors, e.g. if node IDs are\n&gt; &gt; taken to be a h=\r\neight measured from top to bottom of the network, we\n&gt; &gt; can assign and mod=\r\nify node IDs so that we can simply compare two IDs\n&gt; &gt; to see their relativ=\r\ne position in the top-down graph - the problem\n&gt; &gt; there being that we can =\r\nno longer use the IDs as innovation numbers;\n&gt; &gt; However we could simply us=\r\ne two variables - innovation ID and a\n&gt; &gt; height/position. One downside the=\r\nre is that only one node can occupy a\n&gt; &gt; given height and since the number=\r\n of height levels is limits (e.g. to\n&gt; &gt; 2^32 for a 32 bit variable) the nu=\r\nmber of nodes in a network is\n&gt; &gt; limited, on the other hand that&#39;s potenti=\r\nally a very high limit.\n&gt; &gt; Perhaps the tricky part is decidign what to do =\r\nwhen mating two\n&gt; &gt; networks.\n&gt; &gt; \n&gt; &gt; This post is already too long so I&#39;m=\r\n going to stop :)\n&gt; &gt; \n&gt; &gt; Colin\n&gt; &gt;\n&gt;\n\n\n\n"}}