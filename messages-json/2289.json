{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":7192225,"authorName":"Ian Badcoe","from":"Ian Badcoe &lt;ian_badcoe@...&gt;","profile":"ian_badcoe","replyTo":"LIST","senderId":"OeyhgHIycu1k0PdOBcXD6Mii2WsBdjpBf3HKQ4RBn5HxgWX15SMMW4SL9p-f5pRefif8Xe29ki5avJsDtuHtvv9qic94NDmmbxw","spamInfo":{"isSpam":false,"reason":"12"},"subject":"SLEAT - As she is spoke","postDate":"1127850609","msgId":2289,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDYuMi4wLjE0LjAuMjAwNTA5MjcxOTU3MzkuMDJlNjdhNTBAcG9wLm1haWwueWFob28uY28udWs+"},"prevInTopic":0,"nextInTopic":2290,"prevInTime":2288,"nextInTime":2290,"topicId":2289,"numMessagesInTopic":7,"msgSnippet":"Hi, This is how I have implemented SLEAT. Each individual contains multiple chromosomes. Each chromosome is roughly equivalent to a traditional NEAT","rawEmail":"Return-Path: &lt;ian_badcoe@...&gt;\r\nX-Sender: ian_badcoe@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 23271 invoked from network); 27 Sep 2005 19:47:21 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m11.grp.scd.yahoo.com with QMQP; 27 Sep 2005 19:47:21 -0000\r\nReceived: from unknown (HELO smtp1.freeserve.com) (193.252.22.158)\n  by mta1.grp.scd.yahoo.com with SMTP; 27 Sep 2005 19:47:20 -0000\r\nReceived: from me-wanadoo.net (localhost [127.0.0.1])\n\tby mwinf3008.me.freeserve.com (SMTP Server) with ESMTP id 8A4201C00097\n\tfor &lt;neat@yahoogroups.com&gt;; Tue, 27 Sep 2005 21:47:18 +0200 (CEST)\r\nReceived: from giles.yahoo.co.uk (modem-981.lion.dialup.pol.co.uk [217.135.163.213])\n\tby mwinf3008.me.freeserve.com (SMTP Server) with ESMTP id EB2591C0009B\n\tfor &lt;neat@yahoogroups.com&gt;; Tue, 27 Sep 2005 21:47:16 +0200 (CEST)\r\nX-ME-UUID: 20050927194716963.EB2591C0009B@...\r\nMessage-Id: &lt;6.2.0.14.0.20050927195739.02e67a50@...&gt;\r\nX-Mailer: QUALCOMM Windows Eudora Version 6.2.0.14\r\nDate: Tue, 27 Sep 2005 20:50:09 +0100\r\nTo: neat@yahoogroups.com\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;us-ascii&quot;; format=flowed\r\nX-eGroups-Msg-Info: 1:12:0:0\r\nFrom: Ian Badcoe &lt;ian_badcoe@...&gt;\r\nSubject: SLEAT - As she is spoke\r\nX-Yahoo-Group-Post: member; u=7192225; y=jg0Oczvbk8NCwE2lsbUOKQT8j4jQa5px87x-fzk4vgGCHfOzTQ\r\nX-Yahoo-Profile: ian_badcoe\r\n\r\nHi,\n\tThis is how I have implemented SLEAT.\n\nEach individual contains multiple chromosomes.\n\nEach chromosome is roughly equivalent to a traditional NEAT individual.\n\nWhen the individual plays the game, a set of basic boards are created to \ndescribe the starting position:\n\tMy pieces,\n\tYour pieces,\n\tEmpty cells, and,\n\t&quot;off the board&quot; cells (all using 1.0 for the thing they represent and 0.0 \nfor anything else).\n\nThese boards are stored at certain &quot;positions&quot; where chromosomes can find them.\n\nThen each chromosome is evaluated in turn.  Each chromosome reads data from \nexisting boards and creates a new board to contain its results.  This new \nboard is then inserted into the existing set of boards at a &quot;position&quot; \nwhich is an evolving parameter of the chromosome itself.\n\nLater chromosomes can thus find the outputs from earlier ones if they look \nat the correct &quot;positions&quot; (positively the last time I&#39;ll scare-quote this, \npromise) in the set.\n\nThe final result is then determined by doing a weighted sum over all the \ngenerated boards (the weight being another evolving parameter of the \nchromosome) and playing the cell with the highest value in the result.\n\n-- details --\n\nEach chromosome contains rules and genes.\n\nRules locate cells on a board, using (x-offset, y-offset) from a reference \ncell.\n\t(e.g. if we are calculating a value for cell (1, 1) and the rule says (+1, \n-1), then we read an input from (2, 0)).\n\tRules have a position in the same way that the generated boards do, do the \ntwo types of positions are unrelated to one-another.\n\nGenes specify inputs, connections or nodes.\n\n\tInputs select a rule and a board, and read the result from the resulting cell.\n\n\tNode genes create hidden nodes in the network.  A hidden nod will not do \nanything unless some connections are attached to it.\n\n\tConnection genes connect inputs to nodes, or nodes to nodes - \nnon-recurrence is guaranteed by only connecting higher innovation numbers \nto lower ones (when the source is a node, that is, if the source is an \ninput it doesn&#39;t matter).\n\nA single node gene is always present in every chromosome from the beginning \nand forms the (single) output of the chromosome.\n\nThe chromosome then generates a whole board full of results by scanning it \nover the whole coordinate range.  e.g. if the chromosome contained:\n\n\trule#1(+1, -1)\n\trule#2(0, 0)\n\t-\n\tnode#0 -- built in output\n\tinput#1(board_X, rule#1)\n\tinput#2(board_Y, rule#2)\n\tconnect #1-&gt;#0 (0.5)\n\tconnect #2-&gt;#0 (0.5)\n\nThen when it is generating cell(0,0) in its output, it will read in cell(1, \n-1) on board_X and cell(0, 0) on board_y and feed 1/2 of each value into \nnode#0 which will then be sigmoided and fed into the output cell.  It will \nthen go on to generate cell(0, 1) and read cells (1, 0) and (0, 1) on \nboards x and y respectively.\n\n-- &quot;positions&quot; --\n\nBoth types of position (board and rule) are achieve in the same way using \nwhat I call a FID (Floating ID).  This is a single floating point value \nstored on each item (board or rule).  When an input node wishes to find an \nitem, it uses a target FID of its own (it has two, one for rules and one \nfor boards) and simply locates the closest FID in the list of items to the \none it is looking for.\n\nI believe this technique (which is a form of what I call &quot;arbitrary \nlabelling&quot;) to be very powerful, although whether 1 dimensional values are \nsufficient, I don&#39;t yet know.  But this is a different discussion.\n\n-- evolution --\n\ncurrently I have a whole slew of mutation parameters:\n\n// chromosome create/destroy\nChromosome add:\t\t\t\t0.001f;\nChromosome del:\t\t\t\t0.001f;\nChromosome duplicate\t\t\t\t0.001f;\nChromosome reorder\t\t\t\t0.01f;\n// else move on to the next block\t\t0.987f\n\n// chromosome mutate params\nGo to rule mutate system:\t\t\t0.3f;\nMutate output weight:\t\t\t\t0.05f;\nMutate output FID:\t\t\t\t0.05f;\n// else go to gene mutation\t\t\t0.6f\n\n// weight mutate params (used for all weights and fIDs)\nSmall linear nudge:\t\t\t\t0.4f;\t\nScale by close to 1.0:\t\t\t\t0.4f;\n//else completely randomise:\t\t\t0.2f\n\n// gene mutate params\nAdd hidden node:\t\t\t\t0.1f;\nAdd unput node:\t\t\t\t0.1f;\nAdd connection:\t\t\t\t0.1f;\nDel node (either type):\t\t\t\t0.1f;\nDel connection:\t\t\t\t0.1f;\nMutate input board target-FID:\t\t\t0.1f;\nMutate input rule target-FID:\t\t\t0.1f;\n//else mutate connection weight\t\t0.3f\n\n//this proportion of all input nodes are set to a constant value of 1.0f\nstatic const float s_ConstProd = 0.1f;\n\n// rule mutation params\nAdd a rule:\t\t\t\t\t0.3f;\nDel a rule:\t\t\t\t\t0.1f;\nChange the x and y offsets in a rule:\t\t0.3f;\n//else change the rule FID\t\t\t0.3f\n\nBreeding proceeds as follows:\n\n1) generate one new individual at a time\n2) 50-50 split between copy and mutate an existing individual and breed two \nindividuals\n3) breeding occurs very much as per Ken&#39;s original, except when I take \neverything present in either parent and when I merge two FIDs I average \nthem together (makes no sense for widely spaced ones but when they differ \nby a small amount you are exploring the area between the two parents).\n4) copy mutate is set up to insert exactly one mutation in the individual\n5) new individual is evaluated and inserted in ranked order in the \npopulation.  The new worst individual is erased.  Ties are resolved with \nthe new individual ranking _above_ the existing one (to encourage change).\n\n-- notes:\n\n1) I delete instead of disabling.  This is just my bias PLUS it was quicker \nto code up when I started, PLUS my genomes are already quite big, even \nwithout keeping everything.  But I&#39;m open to looking into disabling when I \nget time.\n2) No species.  I need to discuss how to approach this with you all.\n3) One mutation at a time may be limiting for large genomes.\n4) I&#39;m still &quot;cheating&quot; and using TTT-PPS(legal-nl) as the fitness \nscore.  When I get this system to create a perfect player (and run fast \nenough) I will move on to coevolution\n5) I am using a regime of alternating complexification (pedantic mode: \nthere is surely no such word!) and what I call &quot;trimming the dead wood&quot; (of \nwhich more in a later email).\n\n-- results:\n\nUsing a population of 1000 and counting 1000 births as one &quot;generation&quot;.  I \nhave reached a TTT-PPS(legal-nl) score of 0.897129 in 350 generations.  I \nam tempted to call this &quot;89.7% perfect&quot; but that would be very naive :)\n\nHow does it play?  I&#39;ll tell you when I&#39;ve written the &quot;now play against a \nhuman&quot; code.\n\n\tIan\nIn 15 minutes everybody will be in the future.\n\n\n\n\n"}}