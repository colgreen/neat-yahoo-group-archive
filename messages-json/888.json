{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":82117382,"authorName":"Jim O&#39;Flaherty, Jr.","from":"&quot;Jim O&#39;Flaherty, Jr.&quot; &lt;jim_oflaherty_jr@...&gt;","profile":"jim_oflaherty_jr","replyTo":"LIST","senderId":"Ah12o3G-YllsubYTcPfMX63DnIOHoNVIhFdvFFP3OdPAbmhFWlIEqbHSRoruZDKrDV5ZceK9whNTbad1b3gmjO-IMbdNCDHz6gKCEzum8J2L5N0GzB_SBeU","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [neat] Re: Computation Time","postDate":"1085801392","msgId":888,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDAwZWUwMWM0NDUyZCQzNGI0MWIwMCQzMjAxYThjMEBORVdBR0U+","referencesHeader":"PEJBWTItRjZwYTUwVUl4Z3pnZ2YwMDAzNWI4MkBob3RtYWlsLmNvbT4="},"prevInTopic":887,"nextInTopic":892,"prevInTime":887,"nextInTime":889,"topicId":845,"numMessagesInTopic":99,"msgSnippet":"John, Yes, I do...or did.  :^) I have currently currently constructed the first pass in Java of an ANN that serializes the calculations of a single pass of an","rawEmail":"Return-Path: &lt;jim_oflaherty_jr@...&gt;\r\nX-Sender: jim_oflaherty_jr@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 56452 invoked from network); 29 May 2004 03:29:54 -0000\r\nReceived: from unknown (66.218.66.172)\n  by m14.grp.scd.yahoo.com with QMQP; 29 May 2004 03:29:54 -0000\r\nReceived: from unknown (HELO smtp105.mail.sc5.yahoo.com) (66.163.169.225)\n  by mta4.grp.scd.yahoo.com with SMTP; 29 May 2004 03:29:54 -0000\r\nReceived: from unknown (HELO NEWAGE) (jim?oflaherty?jr@24.1.159.151 with login)\n  by smtp105.mail.sc5.yahoo.com with SMTP; 29 May 2004 03:29:53 -0000\r\nMessage-ID: &lt;00ee01c4452d$34b41b00$3201a8c0@NEWAGE&gt;\r\nTo: &lt;neat@yahoogroups.com&gt;\r\nReferences: &lt;BAY2-F6pa50UIxgzggf00035b82@...&gt;\r\nDate: Fri, 28 May 2004 22:29:52 -0500\r\nMIME-Version: 1.0\r\nContent-Type: multipart/alternative;\n\tboundary=&quot;----=_NextPart_000_00EB_01C44503.4B5AD940&quot;\r\nX-Priority: 3\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook Express 6.00.2720.3000\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2739.300\r\nX-eGroups-Remote-IP: 66.163.169.225\r\nFrom: &quot;Jim O&#39;Flaherty, Jr.&quot; &lt;jim_oflaherty_jr@...&gt;\r\nSubject: Re: [neat] Re: Computation Time\r\nX-Yahoo-Group-Post: member; u=82117382\r\nX-Yahoo-Profile: jim_oflaherty_jr\r\n\r\n\r\n------=_NextPart_000_00EB_01C44503.4B5AD940\r\nContent-Type: text/plain;\n\tcharset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\nJohn,\n\nYes, I do...or did.  :^)\n\nI have currently currently constructed the=\r\n first pass in Java of an ANN that serializes the calculations of a single =\r\npass of an ANN *including recurrancy*.  Additionally, I also created it wit=\r\nh an &quot;undo&quot; functionality - steps back the values in the recurrent nodes to=\r\n recreate previous activation state for recurrent connections.  I needed th=\r\nat for the specific type of network solution I was seeking.  It is still al=\r\nl dynamic code evaluation - i.e., there is still two array lookups per weig=\r\nht evaluation.\n\nThe name of the framework is SEMIANN (Sparsely Evaluated Ma=\r\ntrix Interface ANN).  \n\nSEMIANN is design complete, Javadoc-ed and has a nu=\r\nmber of JUnit tests implemented and it passes them all.  I am a small numbe=\r\nr of hours from releasing it (&lt; 5).  I just have not had the time to create=\r\n a site and/or jump on SourceForge to deploy it.  I would not be able to be=\r\n responsible for reliably maintaining it (which really means incorporating =\r\nothers&#39; patches, determining new release drops and the like).\n\nAnyway, I in=\r\ntentionally designed it such that the same &quot;configuration&quot; classes that are=\r\n used by the dynamic evaluator (serialized computation engine) can be submi=\r\ntted to a &quot;code generator&quot; mechanism that would produce and compile the cod=\r\ne so it implements an interface (the same one used by the dynamic implement=\r\nation) such that the code could be immediately used and optimized by the JV=\r\nM.  I have not created this code generator/code compiler/interface provider=\r\n.  Doing so is more busy work than it is hard work.  And by creating all th=\r\ne decoupling in design, I have made it such that the code from the code gen=\r\nerator can be tweaked later with no impact to the network configuration inp=\r\nut nor impact the resultant interface (only the internals of the implementa=\r\ntion would be &quot;changed&quot;).\n\nThe fact that all of this can occur at runtime a=\r\nnd will outperform many hand optimized C++ code implementations is a testam=\r\nent to how far Java has come in the last 3 years.  Please don&#39;t underestima=\r\nte how much progress Java JVM&#39;s have made, nor how productive you can be in=\r\n very short periods of time.  I have studied the hell out of Java performan=\r\nce and tweaks for the last 4 years.  Java is very capable, if one designs w=\r\nith high-performance in mind.\n\nAs to the &quot;code generator&quot; version being fas=\r\nter than the dynamic evaluator - I would predict it could be up to 10-30% f=\r\naster.  However, I cannot see how it is going to be much more than that, ev=\r\nen with the JVM optimizer attempting to move things to registers and with s=\r\nuper effective stack management.  The elimination of indirection operations=\r\n will become more obvious as the number of weights grows exponentially.  So=\r\n eventually with sufficiently large networks, the &quot;code generator&quot; version =\r\nwill just save more time.  I am looking forward to seeing how much it actua=\r\nlly turns out to be.\n\nSEMIANN&#39;s design presumes the weights are not changed=\r\n during the network activations.  To create a copy of the network and chang=\r\ne the weights requires regenerating the configuration instances and resubmi=\r\ntting them to the dynamic evaluator and/or &quot;code generator&quot;.  That&#39;s the &quot;r=\r\nead only&quot; tradeoff to ensure maximum flexibility for the JVM when it is doi=\r\nng runtime optimization.\n\nAnother project has taken me away from this frame=\r\nwork and my own AI development since the beginning of April.  I hope to ret=\r\nurn to it within the month.  I will then test the dynamic version thoroughl=\r\ny without the code generator.  Once I have ascertained it is working, I wil=\r\nl release it under the GPL.  I will then work on the &quot;code generator&quot; versi=\r\non.  That will intially be a hack to reproduce the code for the dynamic ver=\r\nsion to ensure all the operations work corrrectly.  Then the implementation=\r\n will be changed to use a very stack based/no-dereferencing instruction app=\r\nroach to eliminate all indirection lookup costs including; arrays, polymorp=\r\nhic calls, etc.  Additionally, I will look at implementing some sort of mul=\r\nti-threading configuration/execution to allow for parallel processing of in=\r\ndependent aspects of the directed graph of calculations.  That is very hard=\r\n work, though and will come much later.  I will likely want to do more AI s=\r\npecific work first and have the need come up before I go do the multi-threa=\r\nded implementation.  Plus, it would be nice to have a couple of multiproces=\r\nsor boxes with which I can actually exploit the multi-threading implementat=\r\nion!  :^)\n\nI did look at other kinds of optimization techniques, topically =\r\n- I either did not understand them or , most of the matix optimization tech=\r\nniques presume a regular matrix, not a sparsely filled multi-dimensional ma=\r\ntrix which is what almost all NEAT ANNs result in being.  From what I can s=\r\nee so far, a straight out sparse matrix evaluator in most (if not all) case=\r\ns will outperform other techniques.  And this does not include issues like =\r\nrecurrance and or undo functionality, although both can be made orthagonal =\r\nto the matrix calculation, if deemed desirable.\n\nIf anyone is interested in=\r\n this, please let me know and I will try to rearrange things in my personal=\r\n life to get this released ASAP (like as just an E-mail as opposed to a ful=\r\nl scale project on SourceForge).\n\n\nRespectfully,\n\nJim O&#39;Flaherty, Jr.\n\n\n  -=\r\n---- Original Message ----- \n  From: John Arrowwood \n  To: neat@yahoogroups=\r\n.com \n  Sent: Friday, May 28, 2004 5:07 PM\n  Subject: Re: [neat] Re: Comput=\r\nation Time\n\n\n  &gt;From: &quot;Mattias Fagerlund&quot; &lt;mattias@...&gt;\n  &gt;\n  =\r\n&gt; &gt; No, such a thing is definitely overkill for xor.  But for image\n  &gt; &gt; e=\r\nnlargement,\n  &gt; &gt; where analyzing the fitness of a single network may invol=\r\nve billions\n  &gt; &gt; (yes,\n  &gt; &gt; billions) of activations, every little bit wi=\r\nll help.\n  &gt;\n  &gt;For DelphiNEAT I wrote a &quot;Pascal decompiler&quot; that created p=\r\nascal code\n  &gt;that represented the network. That way I could use a network =\r\nthat NEAT\n  &gt;evolved outside of my NEAT framework. It&#39;s not very hard - but=\r\n I&#39;m not\n  &gt;sure how much faster it is.\n\n  I&#39;m wondering if what you did is=\r\n anything like this...\n\n  A normal evaluation of a network walks through a =\r\nlist of connections and \n  looks up the weights and the nodes that it needs=\r\n.  Time is spent calculating \n  offsets into arrays, index comparison, inde=\r\nx increments, etc.  For manually \n  generated code, that&#39;s definitely the w=\r\nay to go, because it is maintainable. \n    But that maintainability comes a=\r\nt a speed price.\n\n  Imagine instead an algorithm that evaluates a feed-forw=\r\nard (no recurrent \n  connections) topology and does simple dependancy analy=\r\nsis.  It then produces \n  code that references hard-coded variables (e.g. h=\r\nidden01..hidden0X) for \n  everything, and deliberately does every calculati=\r\non exactly once.  The \n  resulting code could be orders of magnitude faster=\r\n.\n\n  Anyone besides me have a need for something like this?\n\n\n\n        Yaho=\r\no! Groups Sponsor \n              ADVERTISEMENT\n             \n       \n      =\r\n \n\n\n-----------------------------------------------------------------------=\r\n-------\n  Yahoo! Groups Links\n\n    a.. To visit your group on the web, go t=\r\no:\n    http://groups.yahoo.com/group/neat/\n      \n    b.. To unsubscribe fr=\r\nom this group, send an email to:\n    neat-unsubscribe@yahoogroups.com\n     =\r\n \n    c.. Your use of Yahoo! Groups is subject to the Yahoo! Terms of Servi=\r\nce. \n\n\n\r\n------=_NextPart_000_00EB_01C44503.4B5AD940\r\nContent-Type: text/html;\n\tcharset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;\n&lt;HTML&gt;&lt;HEAD&gt;=\r\n\n&lt;META http-equiv=3DContent-Type content=3D&quot;text/html; charset=3Diso-8859-1=\r\n&quot;&gt;\n&lt;META content=3D&quot;MSHTML 6.00.2737.800&quot; name=3DGENERATOR&gt;\n&lt;STYLE&gt;&lt;/STYLE&gt;=\r\n\n&lt;/HEAD&gt;\n&lt;BODY bgColor=3D#ffffff&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;John,&lt;/F=\r\nONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT =\r\nface=3DArial size=3D2&gt;Yes, I do...or did.&nbsp; :^)&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT=\r\n face=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2=\r\n&gt;I have currently currently constructed the first \npass in Java of an ANN t=\r\nhat serializes the calculations of a single pass of an \nANN *including recu=\r\nrrancy*.&nbsp; Additionally, I also created it with an &quot;undo&quot; \nfunctionalit=\r\ny - steps back the values in the recurrent nodes to recreate \nprevious acti=\r\nvation state for recurrent connections.&nbsp; I needed that for the \nspecif=\r\nic type of network solution I was seeking.&nbsp; It is still all dynamic \nc=\r\node evaluation - i.e., there is still two array lookups per weight \nevaluat=\r\nion.&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV=\r\n&gt;&lt;FONT face=3DArial size=3D2&gt;The name of the framework is SEMIANN (Sparsely=\r\n \nEvaluated Matrix Interface ANN).&nbsp;&nbsp;&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=\r\n=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;SEMI=\r\nANN&nbsp;is design complete, Javadoc-ed and has \na number of JUnit tests im=\r\nplemented and it passes them all.&nbsp; I am a small \nnumber of hours from =\r\nreleasing it (&lt; 5).&nbsp; I just have not had the time \nto create a site=\r\n and/or jump on SourceForge to deploy it.&nbsp; I would not be \nable to be =\r\nresponsible for reliably maintaining it (which really means \nincorporating =\r\nothers&#39; patches, determining new release drops&nbsp;and the \nlike).&lt;/FONT&gt;&lt;=\r\n/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=\r\n=3DArial size=3D2&gt;Anyway, I intentionally designed it such that the \nsame &quot;=\r\nconfiguration&quot; classes that are used by the dynamic evaluator (serialized \n=\r\ncomputation engine) can be submitted to a &quot;code generator&quot;&nbsp;mechanism t=\r\nhat \nwould produce and compile&nbsp;the code so it implements an interface =\r\n(the same \none used by the dynamic implementation) such that the code could=\r\n be immediately \nused and optimized by the JVM.&nbsp; I have not created th=\r\nis code generator/code \ncompiler/interface provider.&nbsp;&nbsp;Doing so is=\r\n more busy work than it is \nhard work.&nbsp; And by creating all the decoup=\r\nling in design, I have made it \nsuch that the code from the code generator =\r\ncan be tweaked later with no impact \nto the network configuration input nor=\r\n impact the resultant interface (only the \ninternals of the implementation =\r\nwould be &quot;changed&quot;).&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&=\r\nnbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;The fact that all of this can =\r\noccur at runtime and \nwill outperform many hand optimized C++ code implemen=\r\ntations is a testament to \nhow far Java has come in the last 3 years.&nbsp;=\r\n Please don&#39;t underestimate how \nmuch progress Java JVM&#39;s have made, nor ho=\r\nw productive you can be in very short \nperiods of time.&nbsp; I have studie=\r\nd the hell out of Java performance and \ntweaks for the last 4 years.&nbsp; =\r\nJava is very capable, if one designs with \nhigh-performance in mind.&lt;/FONT&gt;=\r\n&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=\r\n=3DArial size=3D2&gt;As to the &quot;code generator&quot; version being faster \nthan the=\r\n dynamic evaluator - I would predict it could be up to 10-30% \nfaster.&nbsp=\r\n; However, I cannot see how it is going to be much more than that, \neven wi=\r\nth the JVM optimizer attempting to move things to registers and with \nsuper=\r\n effective stack management.&nbsp; The elimination of indirection \noperatio=\r\nns will become more obvious as the number of weights grows \nexponentially.&=\r\nnbsp; So eventually with sufficiently large networks, the &quot;code \ngenerator&quot;=\r\n version will just save more time.&nbsp; I am looking forward to \nseeing ho=\r\nw much it actually turns out to be.&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial si=\r\nze=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;SEMIANN&#39;s&nbsp;=\r\ndesign presumes the weights are not \nchanged during the network activations=\r\n.&nbsp; To create a copy of the network \nand change the weights requires re=\r\ngenerating the configuration instances and \nresubmitting them to the dynami=\r\nc evaluator&nbsp;and/or &quot;code generator&quot;.&nbsp; \nThat&#39;s the &quot;read only&quot; tra=\r\ndeoff to ensure maximum flexibility for the JVM when \nit is doing runtime o=\r\nptimization.&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/D=\r\nIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;Another project&nbsp;has taken me away=\r\n from this \nframework and my own AI development since the beginning of Apri=\r\nl.&nbsp; I hope \nto return to it within the month.&nbsp; I will then test&n=\r\nbsp;the dynamic \nversion&nbsp;thoroughly without the code generator.&nbsp; =\r\nOnce I have \nascertained it is working, I will release it under the GPL.&nb=\r\nsp; I will then \nwork on the &quot;code generator&quot; version.&nbsp; That will inti=\r\nally be a hack to \nreproduce the code for the dynamic version to ensure all=\r\n the operations work \ncorrrectly.&nbsp; Then the implementation will be cha=\r\nnged to use a very stack \nbased/no-dereferencing instruction approach to el=\r\niminate all indirection lookup \ncosts including; arrays, polymorphic calls,=\r\n etc.&nbsp; Additionally, I will look \nat implementing some sort of multi-t=\r\nhreading configuration/execution to allow \nfor parallel processing of indep=\r\nendent aspects of the directed graph of \ncalculations.&nbsp; That is very h=\r\nard work, though and will come much \nlater.&nbsp; I will likely want to do =\r\nmore AI specific work first and have the \nneed come up before I go do the m=\r\nulti-threaded implementation.&nbsp; Plus, it \nwould be nice to have a coupl=\r\ne of multiprocessor boxes with which I can actually \nexploit the multi-thre=\r\nading implementation!&nbsp; :^)&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=\r\n=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;I did look at oth=\r\ner kinds of optimization \ntechniques, topically - I either did not understa=\r\nnd them or , most of the matix \noptimization techniques presume a regular m=\r\natrix, not a sparsely filled \nmulti-dimensional matrix which is what almost=\r\n all NEAT ANNs result in \nbeing.&nbsp; From what I can see so far, a straig=\r\nht out sparse matrix evaluator \nin most (if not all) cases will outperform =\r\nother techniques.&nbsp; And this does \nnot include issues like recurrance a=\r\nnd or undo functionality, although both can \nbe made orthagonal to the matr=\r\nix calculation, if deemed desirable.&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial s=\r\nize=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;If anyone is i=\r\nnterested in this, please let me know \nand I will try to rearrange things i=\r\nn my personal life to get this released ASAP \n(like as just an E-mail as op=\r\nposed to a full scale project on \nSourceForge).&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT fac=\r\ne=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/F=\r\nONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;Respectfully,&lt;/FONT&gt;&lt;/DIV=\r\n&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DAr=\r\nial size=3D2&gt;Jim O&#39;Flaherty, Jr.&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=\r\n=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DI=\r\nV&gt;\n&lt;BLOCKQUOTE \nstyle=3D&quot;PADDING-RIGHT: 0px; PADDING-LEFT: 5px; MARGIN-LEFT=\r\n: 5px; BORDER-LEFT: #000000 2px solid; MARGIN-RIGHT: 0px&quot;&gt;\n  &lt;DIV style=3D&quot;=\r\nFONT: 10pt arial&quot;&gt;----- Original Message ----- &lt;/DIV&gt;\n  &lt;DIV \n  style=3D&quot;BA=\r\nCKGROUND: #e4e4e4; FONT: 10pt arial; font-color: black&quot;&gt;&lt;B&gt;From:&lt;/B&gt; \n  &lt;A =\r\ntitle=3Djarrowwx@... href=3D&quot;mailto:jarrowwx@...&quot;&gt;John \n  A=\r\nrrowwood&lt;/A&gt; &lt;/DIV&gt;\n  &lt;DIV style=3D&quot;FONT: 10pt arial&quot;&gt;&lt;B&gt;To:&lt;/B&gt; &lt;A title=\r\n=3Dneat@yahoogroups.com \n  href=3D&quot;mailto:neat@yahoogroups.com&quot;&gt;neat@yahoog=\r\nroups.com&lt;/A&gt; &lt;/DIV&gt;\n  &lt;DIV style=3D&quot;FONT: 10pt arial&quot;&gt;&lt;B&gt;Sent:&lt;/B&gt; Friday,=\r\n May 28, 2004 5:07 PM&lt;/DIV&gt;\n  &lt;DIV style=3D&quot;FONT: 10pt arial&quot;&gt;&lt;B&gt;Subject:&lt;/=\r\nB&gt; Re: [neat] Re: Computation \n  Time&lt;/DIV&gt;\n  &lt;DIV&gt;&lt;FONT face=3DArial size=\r\n=3D2&gt;&lt;/FONT&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&lt;FONT \n  face=3DArial size=\r\n=3D2&gt;&lt;/FONT&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&lt;FONT face=3DArial \n  size=\r\n=3D2&gt;&lt;/FONT&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&lt;BR&gt;&lt;/DIV&gt;&lt;TT&gt;&gt;From: &quot;Mat=\r\ntias \n  Fagerlund&quot; &lt;&lt;A \n  href=3D&quot;mailto:mattias@...&quot;&gt;matti=\r\nas@...&lt;/A&gt;&gt;&lt;BR&gt;&gt;&lt;BR&gt;&gt; \n  &gt; No, such a thing is def=\r\ninitely overkill for xor.&nbsp; But for \n  image&lt;BR&gt;&gt; &gt; enlargement,&lt;=\r\nBR&gt;&gt; &gt; where analyzing the fitness of a \n  single network may involve=\r\n billions&lt;BR&gt;&gt; &gt; (yes,&lt;BR&gt;&gt; &gt; billions) \n  of activations, ever=\r\ny little bit will help.&lt;BR&gt;&gt;&lt;BR&gt;&gt;For DelphiNEAT I \n  wrote a &quot;Pascal =\r\ndecompiler&quot; that created pascal code&lt;BR&gt;&gt;that represented \n  the network=\r\n. That way I could use a network that NEAT&lt;BR&gt;&gt;evolved outside \n  of my =\r\nNEAT framework. It&#39;s not very hard - but I&#39;m not&lt;BR&gt;&gt;sure how much \n  fa=\r\nster it is.&lt;BR&gt;&lt;BR&gt;I&#39;m wondering if what you did is anything like \n  this..=\r\n.&lt;BR&gt;&lt;BR&gt;A normal evaluation of a network walks through a list of \n  connec=\r\ntions and &lt;BR&gt;looks up the weights and the nodes that it needs.&nbsp; \n  Ti=\r\nme is spent calculating &lt;BR&gt;offsets into arrays, index comparison, index \n =\r\n increments, etc.&nbsp; For manually &lt;BR&gt;generated code, that&#39;s definitely =\r\nthe \n  way to go, because it is maintainable. &lt;BR&gt;&nbsp; But that maintaina=\r\nbility \n  comes at a speed price.&lt;BR&gt;&lt;BR&gt;Imagine instead an algorithm that =\r\nevaluates a \n  feed-forward (no recurrent &lt;BR&gt;connections) topology and doe=\r\ns simple \n  dependancy analysis.&nbsp; It then produces &lt;BR&gt;code that refer=\r\nences \n  hard-coded variables (e.g. hidden01..hidden0X) for &lt;BR&gt;everything,=\r\n and \n  deliberately does every calculation exactly once.&nbsp; The &lt;BR&gt;res=\r\nulting code \n  could be orders of magnitude faster.&lt;BR&gt;&lt;BR&gt;Anyone besides m=\r\ne have a need for \n  something like this?&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;/TT&gt;&lt;BR&gt;&lt;/BODY&gt;&lt;/HTML=\r\n&gt;\n\r\n------=_NextPart_000_00EB_01C44503.4B5AD940--\r\n\n"}}