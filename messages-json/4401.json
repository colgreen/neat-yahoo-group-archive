{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":82117382,"authorName":"Jim O&#39;Flaherty","from":"Jim O&#39;Flaherty &lt;jim_oflaherty_jr@...&gt;","profile":"jim_oflaherty_jr","replyTo":"LIST","senderId":"AOQCtlC3k1T0rc0cdjC5z51N6nqAhlO-WkJacU1RcerogThnEVQwDNXzpsFnGd8wK8M0-kGGUuulcXYHDw8OEsPQnTGR_qRK0wIR3Ne3ARPe_w","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Re: rtNEAT: max_depth() in an endless loop","postDate":"1225724731","msgId":4401,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQ5MEYxMzNCLjgwNDA5MDNAeWFob28uY29tPg==","inReplyToHeader":"PGdlbTJlZSsybjhuQGVHcm91cHMuY29tPg==","referencesHeader":"PGdlbTJlZSsybjhuQGVHcm91cHMuY29tPg=="},"prevInTopic":4400,"nextInTopic":4402,"prevInTime":4400,"nextInTime":4402,"topicId":4396,"numMessagesInTopic":16,"msgSnippet":"Ken, I am confused how you could end up in an endless activation loop. If you are moving from the input nodes forward through the hidden nodes to the output","rawEmail":"Return-Path: &lt;jim_oflaherty_jr@...&gt;\r\nX-Sender: jim_oflaherty_jr@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 61152 invoked from network); 3 Nov 2008 15:05:36 -0000\r\nX-Received: from unknown (66.218.67.97)\n  by m47.grp.scd.yahoo.com with QMQP; 3 Nov 2008 15:05:36 -0000\r\nX-Received: from unknown (HELO smtp104.prem.mail.sp1.yahoo.com) (98.136.44.59)\n  by mta18.grp.scd.yahoo.com with SMTP; 3 Nov 2008 15:05:36 -0000\r\nX-Received: (qmail 25364 invoked from network); 3 Nov 2008 15:05:35 -0000\r\nX-Received: from unknown (HELO ?192.168.1.2?) (jim_oflaherty_jr@24.175.76.77 with plain)\n  by smtp104.prem.mail.sp1.yahoo.com with SMTP; 3 Nov 2008 15:05:34 -0000\r\nX-Yahoo-Newman-Property: ymail-3\r\nMessage-ID: &lt;490F133B.8040903@...&gt;\r\nDate: Mon, 03 Nov 2008 09:05:31 -0600\r\nUser-Agent: Thunderbird 2.0.0.17 (Windows/20080914)\r\nMIME-Version: 1.0\r\nTo: neat@yahoogroups.com\r\nReferences: &lt;gem2ee+2n8n@...&gt;\r\nIn-Reply-To: &lt;gem2ee+2n8n@...&gt;\r\nContent-Type: multipart/alternative;\n boundary=&quot;------------060909040004040202020705&quot;\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Jim O&#39;Flaherty &lt;jim_oflaherty_jr@...&gt;\r\nSubject: Re: [neat] Re: rtNEAT: max_depth() in an endless loop\r\nX-Yahoo-Group-Post: member; u=82117382; y=pi2BXeoKmN5Vf3ckKenPg3bL8pt14FfQi8zzOGVDx47iWV_AxKLknRXScg\r\nX-Yahoo-Profile: jim_oflaherty_jr\r\n\r\n\r\n--------------060909040004040202020705\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\n\r\nKen,\n\nI am confused how you could end up in an endless activation loop. If you \nare moving from the input nodes forward through the hidden nodes to the \noutput nodes as a state calculation progression, there would be no need \nto worry about activation loops - you would only calculate the value of \neach node once in a single pass. The point of a recurrent connection is \nto carry state between full network activations. So, the value provided \nby a recurrent connection would not be used until the next activation \npass (assuming all the nodes from the previous pass have not be &quot;zeroed \nout&quot;).\n\nHow is it there is an endless loop?\n\n\nJim\n\n\nKenneth Stanley wrote:\n&gt;\n&gt; Yes I have heard about this problem coming up in the XOR experiment.\n&gt; Most neuroevolution experiments are not classification experiments\n&gt; (i.e. they don&#39;t have a &quot;final&quot; output), or they allow recurrent\n&gt; connections, and therefore do not require depth to be computed.\n&gt; Therefore, this problem will not come up in most expeirments.\n&gt;\n&gt; However, XOR is a benchmark classification problem that is only meant\n&gt; to be attempted by feedforward networks so it needs to have depth\n&gt; computed. It appears that my attempts to keep the network feedforward\n&gt; in all cases is not perfect, so sometimes when a loop arises, it sends\n&gt; the depth computation into an infinite loop. I have not had time to\n&gt; think about the most elegant solution to this problem: Maybe it should\n&gt; be a stronger check on recurrence, perhaps entirely different from how\n&gt; it works now. Or perhaps it should be a fixed abort-iteration for the\n&gt; depth routine.\n&gt;\n&gt; If someone does feel they have an elegant bit of code to address the\n&gt; issue, I will be happy to take a look.\n&gt;\n&gt; In any case, it should not cause serious problems in general. I\n&gt; apologize for any inconvenience.\n&gt;\n&gt; ken\n&gt;\n&gt; --- In neat@yahoogroups.com &lt;mailto:neat%40yahoogroups.com&gt;, \n&gt; &quot;petar_chervenski&quot; &lt;petar_chervenski@...&gt;\n&gt; wrote:\n&gt; &gt;\n&gt; &gt; Hi Cesar,\n&gt; &gt;\n&gt; &gt; I know of this problem. It is obvious that depth cannot be determined\n&gt; &gt; in a recurrent network, but in general it depends, what is your way to\n&gt; &gt; handle the situation. Try improving the add_link() code so that the\n&gt; &gt; right nodes are picked up when trying to add a forward or a recurrent\n&gt; &gt; connection. This is a good solution but in general the problem with\n&gt; &gt; looped networks cannot be avoided. Suppose you have 3 hidden nodes, A,\n&gt; &gt; B, and C. If you link these like A-&gt;B, B-&gt;C, C-&gt;A, it is a loop in the\n&gt; &gt; network, even though all connections are meant to be forward.\n&gt; &gt; The best solution in my opinion is to put a limit on the possible\n&gt; &gt; depth, say 32, if the depth exceeds 32, quit the recursion and\n&gt; &gt; activate the network 32 times. It slows things down but at least it\n&gt; &gt; will not hurt evolution as if you penalize looped networks.\n&gt; &gt;\n&gt; &gt; Peter\n&gt; &gt;\n&gt; &gt; --- In neat@yahoogroups.com &lt;mailto:neat%40yahoogroups.com&gt;, &quot;Cesar \n&gt; G. Miguel&quot; &lt;cesar.gomes@&gt;\n&gt; &gt; wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; Hi all,\n&gt; &gt; &gt;\n&gt; &gt; &gt; I&#39;m not sure if someone else has notice this &quot;bug&quot; in rtNEAT, but\n&gt; &gt; the\n&gt; &gt; &gt; max_depth() method in network.cpp has the potential to be forever in\n&gt; &gt; &gt; loop if a recurrent link is added in a feedforward topology, e.g.,\n&gt; &gt; the\n&gt; &gt; &gt; XOR experiment (and that can happen even when the recur_only_prob\n&gt; &gt; &gt; parameter is set to zero). A real example is attached.\n&gt; &gt; &gt;\n&gt; &gt; &gt; It seems to happen in 1 out of 10 runs. The max_depth() method calls\n&gt; &gt; &gt; depth() in nnode.cpp, which should return the max depth of that\n&gt; &gt; node.\n&gt; &gt; &gt; But it can get trapped in a loop if any recurrent link is present\n&gt; &gt; (as\n&gt; &gt; &gt; it is commented out in the source: DEPTH NOT DETERMINED FOR NETWORK\n&gt; &gt; &gt; WITH LOOP).\n&gt; &gt; &gt;\n&gt; &gt; &gt; For those cases I have to force a return if an endless loop is\n&gt; &gt; &gt; detected and then set the chromosome&#39;s fitness to zero in order to\n&gt; &gt; &gt; continue.\n&gt; &gt; &gt;\n&gt; &gt; &gt; Has anyone dealed with that before?\n&gt; &gt; &gt;\n&gt; &gt; &gt; []&#39;s\n&gt; &gt; &gt; Cesar\n&gt; &gt; &gt;\n&gt; &gt;\n&gt;\n&gt;  \n\r\n--------------060909040004040202020705\r\nContent-Type: text/html; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\n\r\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta content=&quot;text/html;charset=ISO-8859-1&quot; http-equiv=&quot;Content-Type&quot;&gt;\n  &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body bgcolor=&quot;#ffffff&quot; text=&quot;#000000&quot;&gt;\nKen,&lt;br&gt;\n&lt;br&gt;\nI am confused how you could end up in an endless activation loop. If\nyou are moving from the input nodes forward through the hidden nodes to\nthe output nodes as a state calculation progression, there would be no\nneed to worry about activation loops - you would only calculate the\nvalue of each node once in a single pass. The point of a recurrent\nconnection is to carry state between full network activations. So, the\nvalue provided by a recurrent connection would not be used until the\nnext activation pass (assuming all the nodes from the previous pass\nhave not be &quot;zeroed out&quot;).&lt;br&gt;\n&lt;br&gt;\nHow is it there is an endless loop?&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\nJim&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\nKenneth Stanley wrote:\n&lt;blockquote cite=&quot;mid:gem2ee+2n8n@...&quot; type=&quot;cite&quot;&gt;\n  &lt;div id=&quot;ygrp-text&quot;&gt;\n  &lt;p&gt;Yes I have heard about this problem coming up in the XOR\nexperiment. &lt;br&gt;\nMost neuroevolution experiments are not classification experiments&lt;br&gt;\n(i.e. they don&#39;t have a &quot;final&quot; output), or they allow recurrent&lt;br&gt;\nconnections, and therefore do not require depth to be computed. &lt;br&gt;\nTherefore, this problem will not come up in most expeirments. &lt;br&gt;\n  &lt;br&gt;\nHowever, XOR is a benchmark classification problem that is only meant&lt;br&gt;\nto be attempted by feedforward networks so it needs to have depth&lt;br&gt;\ncomputed. It appears that my attempts to keep the network feedforward&lt;br&gt;\nin all cases is not perfect, so sometimes when a loop arises, it sends&lt;br&gt;\nthe depth computation into an infinite loop. I have not had time to&lt;br&gt;\nthink about the most elegant solution to this problem: Maybe it should&lt;br&gt;\nbe a stronger check on recurrence, perhaps entirely different from how&lt;br&gt;\nit works now. Or perhaps it should be a fixed abort-iteration for the&lt;br&gt;\ndepth routine. &lt;br&gt;\n  &lt;br&gt;\nIf someone does feel they have an elegant bit of code to address the&lt;br&gt;\nissue, I will be happy to take a look. &lt;br&gt;\n  &lt;br&gt;\nIn any case, it should not cause serious problems in general. I&lt;br&gt;\napologize for any inconvenience.&lt;br&gt;\n  &lt;br&gt;\nken&lt;br&gt;\n  &lt;br&gt;\n--- In &lt;a moz-do-not-send=&quot;true&quot; href=&quot;mailto:neat%40yahoogroups.com&quot;&gt;neat@yahoogroups.&lt;wbr&gt;com&lt;/a&gt;,\n&quot;petar_chervenski&quot; &lt;petar_chervenski@&lt;wbr&gt;...&gt;&lt;br&gt;\nwrote:&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; Hi Cesar,&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; I know of this problem. It is obvious that depth cannot be\ndetermined &lt;br&gt;\n&gt; in a recurrent network, but in general it depends, what is your\nway to &lt;br&gt;\n&gt; handle the situation. Try improving the add_link() code so that\nthe &lt;br&gt;\n&gt; right nodes are picked up when trying to add a forward or a\nrecurrent &lt;br&gt;\n&gt; connection. This is a good solution but in general the problem\nwith &lt;br&gt;\n&gt; looped networks cannot be avoided. Suppose you have 3 hidden\nnodes, A, &lt;br&gt;\n&gt; B, and C. If you link these like A-&gt;B, B-&gt;C, C-&gt;A, it is\na loop in the &lt;br&gt;\n&gt; network, even though all connections are meant to be forward. &lt;br&gt;\n&gt; The best solution in my opinion is to put a limit on the possible &lt;br&gt;\n&gt; depth, say 32, if the depth exceeds 32, quit the recursion and &lt;br&gt;\n&gt; activate the network 32 times. It slows things down but at least\nit &lt;br&gt;\n&gt; will not hurt evolution as if you penalize looped networks. &lt;br&gt;\n&gt; &lt;br&gt;\n&gt; Peter &lt;br&gt;\n&gt; &lt;br&gt;\n&gt; --- In &lt;a moz-do-not-send=&quot;true&quot;\n href=&quot;mailto:neat%40yahoogroups.com&quot;&gt;neat@yahoogroups.&lt;wbr&gt;com&lt;/a&gt;,\n&quot;Cesar G. Miguel&quot; &lt;cesar.gomes@&lt;wbr&gt;&gt; &lt;br&gt;\n&gt; wrote:&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt; &gt; Hi all,&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; I&#39;m not sure if someone else has notice this &quot;bug&quot; in rtNEAT,\nbut &lt;br&gt;\n&gt; the&lt;br&gt;\n&gt; &gt; max_depth() method in network.cpp has the potential to be\nforever in&lt;br&gt;\n&gt; &gt; loop if a recurrent link is added in a feedforward topology,\ne.g., &lt;br&gt;\n&gt; the&lt;br&gt;\n&gt; &gt; XOR experiment (and that can happen even when the\nrecur_only_prob&lt;br&gt;\n&gt; &gt; parameter is set to zero). A real example is attached.&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; It seems to happen in 1 out of 10 runs. The max_depth()\nmethod calls&lt;br&gt;\n&gt; &gt; depth() in nnode.cpp, which should return the max depth of\nthat &lt;br&gt;\n&gt; node.&lt;br&gt;\n&gt; &gt; But it can get trapped in a loop if any recurrent link is\npresent &lt;br&gt;\n&gt; (as&lt;br&gt;\n&gt; &gt; it is commented out in the source: DEPTH NOT DETERMINED FOR\nNETWORK&lt;br&gt;\n&gt; &gt; WITH LOOP).&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; For those cases I have to force a return if an endless loop is&lt;br&gt;\n&gt; &gt; detected and then set the chromosome&#39;s fitness to zero in\norder to&lt;br&gt;\n&gt; &gt; continue.&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; Has anyone dealed with that before?&lt;br&gt;\n&gt; &gt; &lt;br&gt;\n&gt; &gt; []&#39;s&lt;br&gt;\n&gt; &gt; Cesar&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt;&lt;br&gt;\n  &lt;br&gt;\n  &lt;/p&gt;\n  &lt;/div&gt;\n&lt;!--End group email --&gt; &lt;/blockquote&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\r\n--------------060909040004040202020705--\r\n\n"}}