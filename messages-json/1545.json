{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":197999825,"authorName":"John Arrowwood","from":"John Arrowwood &lt;jarrowwx@...&gt;","profile":"jarrowwx","replyTo":"LIST","senderId":"G0auHExdlAm1Yu8pCubrfCkHlWdtGDzKZoVqFbrov1sHj2viTUTXOfbDts0201gSy6b4w9z-KjqUhBfpVLA5sykCRIEoFiEsb2w","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Genetic Programming","postDate":"1095455946","msgId":1545,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDUxN2ZhNmYxMDQwOTE3MTQxOTI5Nzk4MTM2QG1haWwuZ21haWwuY29tPg==","inReplyToHeader":"PGNpZmhnOSt1cDhuQGVHcm91cHMuY29tPg==","referencesHeader":"PDUxN2ZhNmYxMDQwOTE3MTI0NjEyZDYyMzZlQG1haWwuZ21haWwuY29tPgkgPGNpZmhnOSt1cDhuQGVHcm91cHMuY29tPg=="},"prevInTopic":1544,"nextInTopic":1553,"prevInTime":1544,"nextInTime":1546,"topicId":1542,"numMessagesInTopic":14,"msgSnippet":"Well, let s ponder on the idea a bit. There are two kinds of nodes.  Values, and Operators.  There are two kinds of operators, binary, and unary.  Some","rawEmail":"Return-Path: &lt;jarrowwx@...&gt;\r\nX-Sender: jarrowwx@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 47173 invoked from network); 17 Sep 2004 21:19:07 -0000\r\nReceived: from unknown (66.218.66.167)\n  by m23.grp.scd.yahoo.com with QMQP; 17 Sep 2004 21:19:07 -0000\r\nReceived: from unknown (HELO mproxy.gmail.com) (64.233.170.201)\n  by mta6.grp.scd.yahoo.com with SMTP; 17 Sep 2004 21:19:07 -0000\r\nReceived: by mproxy.gmail.com with SMTP id 73so84689rnk\n        for &lt;neat@yahoogroups.com&gt;; Fri, 17 Sep 2004 14:19:07 -0700 (PDT)\r\nReceived: by 10.38.181.75 with SMTP id d75mr245244rnf;\n        Fri, 17 Sep 2004 14:19:06 -0700 (PDT)\r\nReceived: by 10.38.81.72 with HTTP; Fri, 17 Sep 2004 14:19:06 -0700 (PDT)\r\nMessage-ID: &lt;517fa6f1040917141929798136@...&gt;\r\nDate: Fri, 17 Sep 2004 14:19:06 -0700\r\nTo: neat@yahoogroups.com\r\nIn-Reply-To: &lt;cifhg9+up8n@...&gt;\r\nMime-Version: 1.0\r\nContent-Type: text/plain; charset=US-ASCII\r\nContent-Transfer-Encoding: 7bit\r\nReferences: &lt;517fa6f1040917124612d6236e@...&gt;\n\t &lt;cifhg9+up8n@...&gt;\r\nX-eGroups-Remote-IP: 64.233.170.201\r\nFrom: John Arrowwood &lt;jarrowwx@...&gt;\r\nReply-To: John@...\r\nSubject: Genetic Programming\r\nX-Yahoo-Group-Post: member; u=197999825\r\nX-Yahoo-Profile: jarrowwx\r\n\r\nWell, let&#39;s ponder on the idea a bit.\n\nThere are two kinds of nodes.  Values, and Operators.  There are two\nkinds of operators, binary, and unary.  Some operators, like Plus, can\nbe either/or, because of how they work.  But a unary operator like\n&#39;Exponent&#39; (or raise to the power of...) don&#39;t make sense when\nconnected to more than one other node.  If you raise 2 and 5 to the\npower of 3, are you raising 10 or 7 to the 3rd power?  Or something\nelse?  It&#39;s ambiguous.  So there are rules...\n\nSome node types can only have one downstream connection.  Others can\nhave two.  Others can have more than two.  For example, you can have\n10 downstream nodes of the &#39;Add&#39; operator, and there is no ambiguity\nof what the result is.  Same thing with multiply.  But division and\nsubtraction won&#39;t let you do that.  The order in which you process the\nparameters makes a difference as to what the result is.  Subtracting a\nwhole series of values, while doable, is a little weird.  But you can\naccomplish the same thing with a series of subtractions, so why make\nit ambiguous or weird if you don&#39;t have to?\n\nYou could make Add and Multiply likewise limited.  Or not, it doesn&#39;t\nmuch matter.\n\nAll leaf nodes are constants (or variables).  All branch nodes are\noperators.  No exceptions.\n\nWhen you add a new unary operator, you insert it between a node and\nits upstream connection.\n\nWhen you add a binary operator, you likewise insert it between the\nfirst term and its upstream operator.  But you also create a\nplaceholder for the second term.  The second term would probably be a\nconstant node with a weight of 0 if it is addition or subtraction, or\n1 if it is multiplication or division, so that it doesn&#39;t influence\nanything.\n\nYou could do mutations that change one type of node to another type of\nnode.  That would give it a new innovation ID.\n\nA single sub-tree CAN be connected and referenced in multiple places\nwithin the equation, too.  Which technically makes it a graph, not a\ntree.  But you would have to protect against loops.  Either that, or\nbe willing to do iterative calculation.  That could be powerful, but\nit could be killer, too...\n\nNow, suppose you create an operator node.  That node is then the root\nof a sub-tree.  But it is not safe to assume that everything under\nthat node is the same between two genomes.  So you would need to do a\ncompatability evaluation.  Each node is the root of a sub-tree, and\nits compatibility factor depends on the existence of the same nodes\nunder it in the other genome.  The presence of other nodes with other\ninnovation id&#39;s changes the compatibility for that sub-tree.  The\nwhole network is just the top-most tree, so the same thing applies at\nall levels.  When crossing over, you can look at the compatibility of\nindividual structures to determine what can be crossed and what can\nnot.\n\nIt all sounds perfectly doable!  \n\nI&#39;m not going to be able to get to it for a while, I&#39;ve got to get my\nenlargement experiment re-coded.  Anybody else want to try it?\n\n\nOn Fri, 17 Sep 2004 20:30:01 -0000, Kenneth Stanley\n&lt;kstanley@...&gt; wrote:\n&gt; \n&gt; John, I have long thought  that it would be really cool to apply the\n&gt; NEAT methodology to Genetic Programming (GP), and your suggestion\n&gt; below sounds very similar to this idea.  In GP,they evolve program\n&gt; trees, but they cross them over in ad-hoc ways that don&#39;t use\n&gt; historical marking, and they do not speciate.  I have a feeling that\n&gt; adding things like historical markings, speciation, and starting\n&gt; minimally to genetic programming could majorly boost its performance.\n&gt;  The right way to do this would take a little thought, and it might be\n&gt; similar to what you are suggesting here or it could be a bit different\n&gt; (For example, should &quot;weights&quot; be on connections...in normal GP the\n&gt; connections don&#39;t contain values).  In any case, I think the general\n&gt; idea is a great thing to look into and definitely promising.\n&gt; \n&gt; ken\n&gt; \n&gt; \n&gt; \n&gt; --- In neat@yahoogroups.com, John Arrowwood &lt;jarrowwx@g...&gt; wrote:\n&gt; &gt; Okay, so after I finish making a fixed-enlargement neural network, I\n&gt; &gt; have another thought...\n&gt; &gt;\n&gt; &gt; The way I had originally envisioned the solution to the problem of\n&gt; &gt; image enlargement was a complex 2-dimensional formula that uses the\n&gt; &gt; original pixel inputs as &#39;constants&#39; in the formula.  The formula\n&gt; &gt; creates a &#39;curve surface&#39; that roughly approximates the original\n&gt; &gt; surface of which the pixel inputs are a representation of.  The\n&gt; &gt; outputs then are calculated by taking the average height of the\n&gt; &gt; surface within an area.\n&gt; &gt;\n&gt; &gt; A neural network is a classifier more than a calculator.  But what\n&gt; &gt; about using the NEAT methodology to build a formula?  Use it to\n&gt; evolve\n&gt; &gt; what in compiler terminology (if I&#39;m not mistaken) is a &#39;parse tree&#39;\n&gt; &gt; of the formula in a manner that is similar to a network.  Each node\n&gt; is\n&gt; &gt; either a value or an operator.  Values have no connections, they are\n&gt; &gt; always the leaf nodes.  Operator nodes have connections to either\n&gt; &gt; value nodes or other operator nodes.  The connection has a weight\n&gt; &gt; which is a multiplier.  So if &#39;+&#39; is connected to &#39;a&#39; with a weight\n&gt; of\n&gt; &gt; 0.5 and to &#39;b&#39; with a weight of 0.75, then it is the same thing as\n&gt; &gt; 0.5a + 0.75b.  A constant input of 1 serves like a bias, so you can\n&gt; &gt; (by means of the weight) build any constant value you need.  And\n&gt; &gt; operators can be any mathematical function.\n&gt; &gt;\n&gt; &gt; So, you start with a minimal function.  It just adds all the inputs\n&gt; &gt; together or something.  Then you evolve the parse tree for the\n&gt; &gt; function.  To evaluate the function, you simply take the average of\n&gt; &gt; the values within an (x1,y1,x2,y2) region and see if it corresponds\n&gt; to\n&gt; &gt; the expected pixel value.\n&gt; &gt;\n&gt; &gt; Admittedly, the search space for such a thing would be enormous.\n&gt; And\n&gt; &gt; I doubt that there is a smooth ramp-up that it could follow to help\n&gt; it\n&gt; &gt; evolve.  But I don&#39;t know...has anybody read anything useful\n&gt; regarding\n&gt; &gt; evolution of formulas?\n&gt; \n&gt; \n&gt; \n&gt; \n&gt; Yahoo! Groups Links\n&gt; \n&gt; \n&gt; \n&gt; \n&gt;\n\n"}}