{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":82117382,"authorName":"Jim O&#39;Flaherty, Jr.","from":"&quot;Jim O&#39;Flaherty, Jr.&quot; &lt;jim_oflaherty_jr@...&gt;","profile":"jim_oflaherty_jr","replyTo":"LIST","senderId":"vxRwXYuOazxtI_70I7wE68zRr1k3oJ4GIAgY7yvzVwYs_la7LYdRp58lGzOCkNdnK_non86J-Mq1bIKAbv8KUt3doxdvPI4BlimaxuttajTNzhVmtXX8ioE","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [neat] Re: Computation Time","postDate":"1085835061","msgId":893,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDAwMjkwMWM0NDU3YiQ5OTAyMTE0MCQzMjAxYThjMEBORVdBR0U+","referencesHeader":"PEJBWTItRjZwYTUwVUl4Z3pnZ2YwMDAzNWI4MkBob3RtYWlsLmNvbT4gPDAwZWUwMWM0NDUyZCQzNGI0MWIwMCQzMjAxYThjMEBORVdBR0U+IDxXb3JsZENsaWVudC1GMjAwNDA1MjkxMTQyLkFBNDIwNDAxMzJAb2N0YWdhdGUuY29tPg=="},"prevInTopic":892,"nextInTopic":894,"prevInTime":892,"nextInTime":894,"topicId":845,"numMessagesInTopic":99,"msgSnippet":"Mattias, I agree with KISS.  I think it is useful in a number of areas.  However, when one is trying to abstract a domain, complexity almost necessarily goes","rawEmail":"Return-Path: &lt;jim_oflaherty_jr@...&gt;\r\nX-Sender: jim_oflaherty_jr@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 46106 invoked from network); 29 May 2004 12:51:19 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m22.grp.scd.yahoo.com with QMQP; 29 May 2004 12:51:19 -0000\r\nReceived: from unknown (HELO smtp105.mail.sc5.yahoo.com) (66.163.169.225)\n  by mta1.grp.scd.yahoo.com with SMTP; 29 May 2004 12:51:19 -0000\r\nReceived: from unknown (HELO NEWAGE) (jim?oflaherty?jr@24.1.159.151 with login)\n  by smtp105.mail.sc5.yahoo.com with SMTP; 29 May 2004 12:51:02 -0000\r\nMessage-ID: &lt;002901c4457b$99021140$3201a8c0@NEWAGE&gt;\r\nTo: &lt;neat@yahoogroups.com&gt;\r\nReferences: &lt;BAY2-F6pa50UIxgzggf00035b82@...&gt; &lt;00ee01c4452d$34b41b00$3201a8c0@NEWAGE&gt; &lt;WorldClient-F200405291142.AA42040132@...&gt;\r\nDate: Sat, 29 May 2004 07:51:01 -0500\r\nMIME-Version: 1.0\r\nContent-Type: multipart/alternative;\n\tboundary=&quot;----=_NextPart_000_0026_01C44551.AFADB180&quot;\r\nX-Priority: 3\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook Express 6.00.2720.3000\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2739.300\r\nX-eGroups-Remote-IP: 66.163.169.225\r\nFrom: &quot;Jim O&#39;Flaherty, Jr.&quot; &lt;jim_oflaherty_jr@...&gt;\r\nSubject: Re: [neat] Re: Computation Time\r\nX-Yahoo-Group-Post: member; u=82117382\r\nX-Yahoo-Profile: jim_oflaherty_jr\r\n\r\n\r\n------=_NextPart_000_0026_01C44551.AFADB180\r\nContent-Type: text/plain;\n\tcharset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\nMattias,\n\nI agree with KISS.  I think it is useful in a number of areas.  H=\r\nowever, when one is trying to abstract a domain, complexity almost necessar=\r\nily goes up if the domain is intended to remain useful.  At least that has =\r\nbeen my experience of it.  And then, I try to keep KISS (a corollary to thi=\r\ns is Occam&#39;s razor) in mind as I design the solution.\n\nYour output below is=\r\n essentially the goal output of my code generator for Java, except the code=\r\n generation occurs in the same JVM that is doing actual run.  And there are=\r\n a few Java specific tweaks that can be exploited.\n\nAt present, if the phen=\r\notype is code generated, it is not as efficient if the runtime must be &quot;sto=\r\npped&quot;, the phenotype set &quot;compiled&quot; and then the runtime environment &quot;resta=\r\nrted&quot; incorporating the new compiled phenotype code.  All the overhead of s=\r\ntartup/shutdown is now present for every generation.  Perhaps on lower gene=\r\nration counts that is not that big of a deal.  Maybe you have an environmen=\r\nt that allows your generated code to be compiled and then loaded in without=\r\n stopping your runtime environment.  Is that the case?  If so, what environ=\r\nment are you using?\n\nAnother option the Java method enables is code mobilit=\r\ny - the code that is generated at the NEAT node is automatically moved out =\r\nto the other processing nodes (nodes that do the fitness evaluation(s) for =\r\nsets of phenotypes).  This significantly simplifies using NEAT in a distrib=\r\nuted environment as the newly runtime compiled code just &quot;drifts&quot; to wherev=\r\ner it is needed.  There is no external file copying headaches or &quot;persisten=\r\nce format&quot; definition/loaders required to flow it out to other nodes.  It i=\r\ns all handled by Java&#39;s JVM architecture.  Thanks to JINI, it gets even sim=\r\npler.  Now *this* is my idea of KISS!  :^)\n\nAnd my idea is that every *phen=\r\notype* is expressed in this manner in a single method, similar to yours.  T=\r\nhis allows the JVM to engage in out of order execution of non-dependent sta=\r\ntements, another JVM optimization.  Granted this will make a very large met=\r\nhod on much larger phenotypes.  However, it will still be very execution ef=\r\nficient which is the goal.  There is a &quot;stack limit&quot; that can be hit at som=\r\ne point - i.e. the number of method local variables that can be defined bef=\r\nore it blows the execution stack size.  That can be managed at code generat=\r\nion time as well as at the JVM startup.  Just something that will reduce th=\r\ne simplicity of this approach if not handled by design.\n\nAnd from what I am=\r\n able to tell, *the* constraint (or bottleneck) for handling NEAT generatio=\r\nns lies almost exclusively in the fitness evaluations.  As Ken pointed out,=\r\n that can be the network activations.  It can also be the external &quot;functio=\r\nn&quot; performing the evaluation (GnuGo in his example case).  The point is, an=\r\ny and all optimizations pay the *most* if they are on the constraint and pa=\r\ny the least elsewhere.  Hence my hyperfocus on reduction of execution time =\r\non the network evaluation mechanism.\n\n\nJim O&#39;Flaherty, Jr.\n\n\n  ----- Origin=\r\nal Message ----- \n  From: Mattias Fagerlund \n  To: neat@yahoogroups.com \n  =\r\nSent: Saturday, May 29, 2004 4:42 AM\n  Subject: Re: [neat] Re: Computation =\r\nTime\n\n\n  Hi,\n\n  you all suggest very advanced and interesting methods of ev=\r\naluating the \n  networks, but mine was extremely simple and worked quite we=\r\nll. I&#39;m a \n  strong beleiver of KISS (keep it simple stupid). This is code =\r\ngenereted \n  by my code generator to solve XOR;\n\n  procedure GenotypeAsCode=\r\n(const Input1 : double; const Input2 : double; \n  const Input3 : double; va=\r\nr Output1 : double);\n  var\n    i : integer;\n    Node1Value, Node1OldValue :=\r\n double;\n    Node2Value, Node2OldValue : double;\n    Node3Value, Node3OldVa=\r\nlue : double;\n    Node4Value, Node4OldValue, Activate4Sum : double;\n    Nod=\r\ne12Value, Node12OldValue, Activate12Sum : double;\n  begin\n    // Set inputs=\r\n\n    Node1Value :=3D Input1; Node1OldValue :=3D Input1;\n    Node2Value :=3D=\r\n Input2; Node2OldValue :=3D Input2;\n    Node3Value :=3D Input3; Node3OldVal=\r\nue :=3D Input3;\n    Node4Value :=3D 0; Node4OldValue :=3D 0;\n    Node12Valu=\r\ne :=3D 0; Node12OldValue :=3D 0;\n\n    // Activate the network\n    for i :=\r\n=3D 0 to 2 do\n    begin\n      Activate4Sum :=3D \n        Node1OldValue * -4=\r\n.2249 + \n        Node2OldValue * -0.7118 + \n        Node3OldValue * -2.4810=\r\n + \n        Node12OldValue * 7.1382;\n      Node4Value :=3D fSigmoid(Activat=\r\ne4Sum);\n\n      Activate12Sum :=3D \n        Node2OldValue * 2.2435 + \n      =\r\n  Node3OldValue * 3.8710;\n      Node12Value :=3D fSigmoid(Activate12Sum);\n\n=\r\n      Node4OldValue :=3D Node4Value;\n      Node12OldValue :=3D Node12Value;=\r\n\n    end;\n\n    // Set outputs\n    Output1 :=3D Node4Value;\n  end;\n\n  If you=\r\n&#39;re interested, I&#39;ll post the code that generates the above \n  procedure. \n=\r\n\n  with regards,\n  mattias\n\n\n\n        Yahoo! Groups Sponsor \n              =\r\nADVERTISEMENT\n             \n       \n       \n\n\n-----------------------------=\r\n-------------------------------------------------\n  Yahoo! Groups Links\n\n  =\r\n  a.. To visit your group on the web, go to:\n    http://groups.yahoo.com/gr=\r\noup/neat/\n      \n    b.. To unsubscribe from this group, send an email to:\n=\r\n    neat-unsubscribe@yahoogroups.com\n      \n    c.. Your use of Yahoo! Grou=\r\nps is subject to the Yahoo! Terms of Service. \n\n\n\r\n------=_NextPart_000_0026_01C44551.AFADB180\r\nContent-Type: text/html;\n\tcharset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\n\r\n&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;\n&lt;HTML&gt;&lt;HEAD&gt;=\r\n\n&lt;META http-equiv=3DContent-Type content=3D&quot;text/html; charset=3Diso-8859-1=\r\n&quot;&gt;\n&lt;META content=3D&quot;MSHTML 6.00.2737.800&quot; name=3DGENERATOR&gt;\n&lt;STYLE&gt;&lt;/STYLE&gt;=\r\n\n&lt;/HEAD&gt;\n&lt;BODY bgColor=3D#ffffff&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;Mattias,=\r\n&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;&lt;FONT fac=\r\ne=3DArial size=3D2&gt;\n&lt;DIV&gt;I agree with KISS.&nbsp; I think it is useful in a=\r\n number of areas.&nbsp; \nHowever, when one is trying to abstract a domain, =\r\ncomplexity almost necessarily \ngoes up if the domain is intended to remain =\r\nuseful.&nbsp; At least that has been \nmy experience of it.&nbsp; And then, =\r\nI try to keep KISS (a corollary to this is \nOccam&#39;s razor) in mind as I des=\r\nign the solution.&lt;/DIV&gt;\n&lt;DIV&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;Your output below is essenti=\r\nally the goal output of my code generator for \nJava, except the code genera=\r\ntion occurs in the same JVM that is doing actual \nrun.&nbsp; And there are =\r\na few Java specific tweaks that can be exploited.&lt;/DIV&gt;\n&lt;DIV&gt;&nbsp;&lt;/DIV&gt;\n&lt;=\r\nDIV&gt;At present, if the phenotype is code generated, it is not as&nbsp;effic=\r\nient \nif the runtime must be &quot;stopped&quot;, the phenotype set &quot;compiled&quot; and th=\r\nen the \nruntime environment &quot;restarted&quot; incorporating the new compiled phen=\r\notype \ncode.&nbsp; All the overhead of startup/shutdown is now present for =\r\nevery \ngeneration.&nbsp; Perhaps on lower generation counts that is not tha=\r\nt big of a \ndeal.&nbsp; Maybe you have an environment that allows your gene=\r\nrated code to be \ncompiled and then loaded in without stopping your runtime=\r\n environment.&nbsp; Is \nthat the case?&nbsp; If so, what environment are yo=\r\nu using?&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;BR&gt;Another option t=\r\nhe Java method enables is code \nmobility - the code that is generated at th=\r\ne NEAT node is automatically moved \nout to the other processing nodes (node=\r\ns that do the fitness evaluation(s) for \nsets of phenotypes).&nbsp; This si=\r\ngnificantly simplifies using NEAT in a \ndistributed environment as the newl=\r\ny runtime compiled code just &quot;drifts&quot; to \nwherever it is needed.&nbsp; Ther=\r\ne is no external file copying headaches or \n&quot;persistence format&quot; definition=\r\n/loaders required to flow it out to other \nnodes.&nbsp; It is all handled b=\r\ny Java&#39;s JVM architecture.&nbsp; Thanks to JINI, \nit gets even simpler.&nbs=\r\np; Now *this* is my idea of KISS!&nbsp; \n:^)&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=\r\n=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;And&=\r\nnbsp;my idea is that every *phenotype* is \nexpressed in this manner in a si=\r\nngle method, similar to yours.&nbsp; This allows \nthe JVM to engage in out =\r\nof order execution of non-dependent statements, another \nJVM optimization.&=\r\nnbsp; Granted this will make a very large method on much \nlarger phenotypes=\r\n.&nbsp; However, it will still be very execution efficient \nwhich is the go=\r\nal.&nbsp; There is a &quot;stack limit&quot; that can be hit at some point \n- i.e. th=\r\ne number of method local variables that can be defined before it blows \nthe=\r\n execution stack size.&nbsp; That can be managed at code generation time as=\r\n \nwell as at the JVM startup.&nbsp; Just something that will reduce the sim=\r\nplicity \nof this approach if not handled by design.&lt;/FONT&gt;&lt;/DIV&gt;&lt;FONT face=\r\n=3DArial size=3D2&gt;\n&lt;DIV&gt;&lt;BR&gt;And from what I am able to tell, *the* constrai=\r\nnt (or bottleneck) for \nhandling NEAT generations lies almost exclusively i=\r\nn the fitness \nevaluations.&nbsp; As Ken pointed out, that can be the netwo=\r\nrk \nactivations.&nbsp; It can also be the external &quot;function&quot; performing th=\r\ne \nevaluation (GnuGo in his example case).&nbsp; The point is, any and all =\r\n\noptimizations pay the *most* if they are on the constraint and pay the lea=\r\nst \nelsewhere.&nbsp; Hence my hyperfocus on reduction of execution time on =\r\nthe \nnetwork evaluation mechanism.&lt;/DIV&gt;\n&lt;DIV&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&nbsp;&lt;/DIV=\r\n&gt;\n&lt;DIV&gt;Jim O&#39;Flaherty, Jr.&lt;/FONT&gt;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/=\r\nFONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;DIV&gt;&lt;FONT face=3DArial size=3D2&gt;&lt;/FONT&gt;&nbsp;&lt;/DIV&gt;\n&lt;BLO=\r\nCKQUOTE \nstyle=3D&quot;PADDING-RIGHT: 0px; PADDING-LEFT: 5px; MARGIN-LEFT: 5px; =\r\nBORDER-LEFT: #000000 2px solid; MARGIN-RIGHT: 0px&quot;&gt;\n  &lt;DIV style=3D&quot;FONT: 1=\r\n0pt arial&quot;&gt;----- Original Message ----- &lt;/DIV&gt;\n  &lt;DIV \n  style=3D&quot;BACKGROUN=\r\nD: #e4e4e4; FONT: 10pt arial; font-color: black&quot;&gt;&lt;B&gt;From:&lt;/B&gt; \n  &lt;A title=\r\n=3Dmattias@... \n  href=3D&quot;mailto:mattias@...&quot;&gt;Mat=\r\ntias Fagerlund&lt;/A&gt; &lt;/DIV&gt;\n  &lt;DIV style=3D&quot;FONT: 10pt arial&quot;&gt;&lt;B&gt;To:&lt;/B&gt; &lt;A t=\r\nitle=3Dneat@yahoogroups.com \n  href=3D&quot;mailto:neat@yahoogroups.com&quot;&gt;neat@ya=\r\nhoogroups.com&lt;/A&gt; &lt;/DIV&gt;\n  &lt;DIV style=3D&quot;FONT: 10pt arial&quot;&gt;&lt;B&gt;Sent:&lt;/B&gt; Sat=\r\nurday, May 29, 2004 4:42 \nAM&lt;/DIV&gt;\n  &lt;DIV style=3D&quot;FONT: 10pt arial&quot;&gt;&lt;B&gt;Sub=\r\nject:&lt;/B&gt; Re: [neat] Re: Computation \n  Time&lt;/DIV&gt;\n  &lt;DIV&gt;&lt;FONT face=3DAria=\r\nl size=3D2&gt;&lt;/FONT&gt;&lt;FONT face=3DArial \n  size=3D2&gt;&lt;/FONT&gt;&lt;BR&gt;&lt;/DIV&gt;&lt;TT&gt;Hi,&lt;B=\r\nR&gt;&lt;BR&gt;you all suggest very advanced and \n  interesting methods of evaluatin=\r\ng the &lt;BR&gt;networks, but mine was extremely \n  simple and worked quite well.=\r\n I&#39;m a &lt;BR&gt;strong beleiver of KISS (keep it \n  simple stupid). This is code=\r\n genereted &lt;BR&gt;by my code generator to solve \n  XOR;&lt;BR&gt;&lt;BR&gt;procedure Genot=\r\nypeAsCode(const Input1 : double; const Input2 : \n  double; &lt;BR&gt;const Input3=\r\n : double; var Output1 : double);&lt;BR&gt;var&lt;BR&gt;&nbsp; i : \n  integer;&lt;BR&gt;&nbsp=\r\n; Node1Value, Node1OldValue : double;&lt;BR&gt;&nbsp; Node2Value, \n  Node2OldValu=\r\ne : double;&lt;BR&gt;&nbsp; Node3Value, Node3OldValue : \n  double;&lt;BR&gt;&nbsp; Node=\r\n4Value, Node4OldValue, Activate4Sum : double;&lt;BR&gt;&nbsp; \n  Node12Value, Nod=\r\ne12OldValue, Activate12Sum : double;&lt;BR&gt;begin&lt;BR&gt;&nbsp; // Set \n  inputs&lt;BR=\r\n&gt;&nbsp; Node1Value :=3D Input1; Node1OldValue :=3D Input1;&lt;BR&gt;&nbsp; \n  Nod=\r\ne2Value :=3D Input2; Node2OldValue :=3D Input2;&lt;BR&gt;&nbsp; Node3Value :=3D I=\r\nnput3; \n  Node3OldValue :=3D Input3;&lt;BR&gt;&nbsp; Node4Value :=3D 0; Node4OldV=\r\nalue :=3D \n  0;&lt;BR&gt;&nbsp; Node12Value :=3D 0; Node12OldValue :=3D 0;&lt;BR&gt;&lt;BR=\r\n&gt;&nbsp; // Activate \n  the network&lt;BR&gt;&nbsp; for i :=3D 0 to 2 do&lt;BR&gt;&nbsp;=\r\n begin&lt;BR&gt;&nbsp;&nbsp;&nbsp; \n  Activate4Sum :=3D &lt;BR&gt;&nbsp;&nbsp;&nbsp;&nb=\r\nsp;&nbsp; Node1OldValue * -4.2249 + \n  &lt;BR&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; N=\r\node2OldValue * -0.7118 + \n  &lt;BR&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node3OldValu=\r\ne * -2.4810 + \n  &lt;BR&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node12OldValue * \n  7.1=\r\n382;&lt;BR&gt;&nbsp;&nbsp;&nbsp; Node4Value :=3D \n  fSigmoid(Activate4Sum);&lt;BR&gt;&lt;B=\r\nR&gt;&nbsp;&nbsp;&nbsp; Activate12Sum :=3D \n  &lt;BR&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbs=\r\np; Node2OldValue * 2.2435 + \n  &lt;BR&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node3OldV=\r\nalue * \n  3.8710;&lt;BR&gt;&nbsp;&nbsp;&nbsp; Node12Value :=3D \n  fSigmoid(Activa=\r\nte12Sum);&lt;BR&gt;&lt;BR&gt;&nbsp;&nbsp;&nbsp; Node4OldValue :=3D \n  Node4Value;&lt;BR&gt;&n=\r\nbsp;&nbsp;&nbsp; Node12OldValue :=3D Node12Value;&lt;BR&gt;&nbsp; \n  end;&lt;BR&gt;&lt;BR&gt;=\r\n&nbsp; // Set outputs&lt;BR&gt;&nbsp; Output1 :=3D \n  Node4Value;&lt;BR&gt;end;&lt;BR&gt;&lt;BR&gt;=\r\nIf you&#39;re interested, I&#39;ll post the code that \n  generates the above &lt;BR&gt;pr=\r\nocedure. &lt;BR&gt;&lt;BR&gt;with \n  regards,&lt;BR&gt;mattias&lt;BR&gt;&lt;BR&gt;&lt;BR&gt;&lt;/TT&gt;&lt;BR&gt;&lt;/BODY&gt;&lt;/H=\r\nTML&gt;\n\r\n------=_NextPart_000_0026_01C44551.AFADB180--\r\n\n"}}