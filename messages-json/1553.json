{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":54567749,"authorName":"Kenneth Stanley","from":"&quot;Kenneth Stanley&quot; &lt;kstanley@...&gt;","profile":"kenstanley01","replyTo":"LIST","senderId":"-24dt4TegXHHJHi2-MxMyokUAEBLPftZZ4ssxLrqP0lCHHusupTk7kpo6VUr_aeCNlHfU9D5Ut40YxLDxAnxYSd4_BA5ccZnam1-4lqdDPxH","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: Genetic Programming","postDate":"1095541928","msgId":1553,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGNpaThiOStsYnN0QGVHcm91cHMuY29tPg==","inReplyToHeader":"PDUxN2ZhNmYxMDQwOTE3MTQxOTI5Nzk4MTM2QG1haWwuZ21haWwuY29tPg=="},"prevInTopic":1545,"nextInTopic":1560,"prevInTime":1552,"nextInTime":1554,"topicId":1542,"numMessagesInTopic":14,"msgSnippet":"I think this is an exciting direction.  Consider that Genetic Programming is a popular method that has been around for years in more or less the same form, and","rawEmail":"Return-Path: &lt;kstanley@...&gt;\r\nX-Sender: kstanley@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 8641 invoked from network); 18 Sep 2004 21:12:20 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m22.grp.scd.yahoo.com with QMQP; 18 Sep 2004 21:12:20 -0000\r\nReceived: from unknown (HELO n4.grp.scd.yahoo.com) (66.218.66.88)\n  by mta1.grp.scd.yahoo.com with SMTP; 18 Sep 2004 21:12:20 -0000\r\nReceived: from [66.218.67.160] by n4.grp.scd.yahoo.com with NNFMP; 18 Sep 2004 21:12:09 -0000\r\nDate: Sat, 18 Sep 2004 21:12:08 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;cii8b9+lbst@...&gt;\r\nIn-Reply-To: &lt;517fa6f1040917141929798136@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=ISO-8859-1\r\nContent-Length: 7738\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Remote-IP: 66.218.66.88\r\nFrom: &quot;Kenneth Stanley&quot; &lt;kstanley@...&gt;\r\nSubject: Re: Genetic Programming\r\nX-Yahoo-Group-Post: member; u=54567749\r\nX-Yahoo-Profile: kenstanley01\r\n\r\nI think this is an exciting direction.  Consider that Genetic \nProgramming is a popular method that has been around for years in \nmore or less the same form, and this could significantly impact the \nfield.  What would be really cool is to run a NEAT-like GP system on \na set of sample problems and compare to standard GP.  If the \ndifference is signficant, people would change the way they do GP, \nand the field of neuroevolution would become more unified with GP.\n\nJohn, I think the methodology you describe below makes sense and \nsounds feasible.  Of course, GP already has well established \nconventions for adding operators, rules for what can be done, etc... \nand some of those may inform a NEAT-like GP system.  On the other \nhand, some of current GP methodology is probably meant to compensate \nfor the ad hoc way in which crossover occurs, and those aspects \ncould be thrown out.\n\nI am not an expert in GP, although I know the main principles.  \nMattias Fagerlund, who wrote DelphiNEAT, also wrote his own GP \nsystem, so he may have some insight on whether the way John suggests \nthings could go would need any modification.  There may be other GP \npeople on this list with ideas as well.  But my sense right now is \nthis could probably be coded up right away and might make a real \nimpact on the GP field.\n\nken\n\n--- In neat@yahoogroups.com, John Arrowwood &lt;jarrowwx@g...&gt; wrote:\n&gt; Well, let&#39;s ponder on the idea a bit.\n&gt; \n&gt; There are two kinds of nodes.  Values, and Operators.  There are \ntwo\n&gt; kinds of operators, binary, and unary.  Some operators, like Plus, \ncan\n&gt; be either/or, because of how they work.  But a unary operator like\n&gt; &#39;Exponent&#39; (or raise to the power of...) don&#39;t make sense when\n&gt; connected to more than one other node.  If you raise 2 and 5 to the\n&gt; power of 3, are you raising 10 or 7 to the 3rd power?  Or something\n&gt; else?  It&#39;s ambiguous.  So there are rules...\n&gt; \n&gt; Some node types can only have one downstream connection.  Others \ncan\n&gt; have two.  Others can have more than two.  For example, you can \nhave\n&gt; 10 downstream nodes of the &#39;Add&#39; operator, and there is no \nambiguity\n&gt; of what the result is.  Same thing with multiply.  But division and\n&gt; subtraction won&#39;t let you do that.  The order in which you process \nthe\n&gt; parameters makes a difference as to what the result is.  \nSubtracting a\n&gt; whole series of values, while doable, is a little weird.  But you \ncan\n&gt; accomplish the same thing with a series of subtractions, so why \nmake\n&gt; it ambiguous or weird if you don&#39;t have to?\n&gt; \n&gt; You could make Add and Multiply likewise limited.  Or not, it \ndoesn&#39;t\n&gt; much matter.\n&gt; \n&gt; All leaf nodes are constants (or variables).  All branch nodes are\n&gt; operators.  No exceptions.\n&gt; \n&gt; When you add a new unary operator, you insert it between a node and\n&gt; its upstream connection.\n&gt; \n&gt; When you add a binary operator, you likewise insert it between the\n&gt; first term and its upstream operator.  But you also create a\n&gt; placeholder for the second term.  The second term would probably \nbe a\n&gt; constant node with a weight of 0 if it is addition or subtraction, \nor\n&gt; 1 if it is multiplication or division, so that it doesn&#39;t influence\n&gt; anything.\n&gt; \n&gt; You could do mutations that change one type of node to another \ntype of\n&gt; node.  That would give it a new innovation ID.\n&gt; \n&gt; A single sub-tree CAN be connected and referenced in multiple \nplaces\n&gt; within the equation, too.  Which technically makes it a graph, not \na\n&gt; tree.  But you would have to protect against loops.  Either that, \nor\n&gt; be willing to do iterative calculation.  That could be powerful, \nbut\n&gt; it could be killer, too...\n&gt; \n&gt; Now, suppose you create an operator node.  That node is then the \nroot\n&gt; of a sub-tree.  But it is not safe to assume that everything under\n&gt; that node is the same between two genomes.  So you would need to \ndo a\n&gt; compatability evaluation.  Each node is the root of a sub-tree, and\n&gt; its compatibility factor depends on the existence of the same nodes\n&gt; under it in the other genome.  The presence of other nodes with \nother\n&gt; innovation id&#39;s changes the compatibility for that sub-tree.  The\n&gt; whole network is just the top-most tree, so the same thing applies \nat\n&gt; all levels.  When crossing over, you can look at the compatibility \nof\n&gt; individual structures to determine what can be crossed and what can\n&gt; not.\n&gt; \n&gt; It all sounds perfectly doable!  \n&gt; \n&gt; I&#39;m not going to be able to get to it for a while, I&#39;ve got to get \nmy\n&gt; enlargement experiment re-coded.  Anybody else want to try it?\n&gt; \n&gt; \n&gt; On Fri, 17 Sep 2004 20:30:01 -0000, Kenneth Stanley\n&gt; &lt;kstanley@c...&gt; wrote:\n&gt; &gt; \n&gt; &gt; John, I have long thought  that it would be really cool to apply \nthe\n&gt; &gt; NEAT methodology to Genetic Programming (GP), and your suggestion\n&gt; &gt; below sounds very similar to this idea.  In GP,they evolve \nprogram\n&gt; &gt; trees, but they cross them over in ad-hoc ways that don&#39;t use\n&gt; &gt; historical marking, and they do not speciate.  I have a feeling \nthat\n&gt; &gt; adding things like historical markings, speciation, and starting\n&gt; &gt; minimally to genetic programming could majorly boost its \nperformance.\n&gt; &gt;  The right way to do this would take a little thought, and it \nmight be\n&gt; &gt; similar to what you are suggesting here or it could be a bit \ndifferent\n&gt; &gt; (For example, should &quot;weights&quot; be on connections...in normal GP \nthe\n&gt; &gt; connections don&#39;t contain values).  In any case, I think the \ngeneral\n&gt; &gt; idea is a great thing to look into and definitely promising.\n&gt; &gt; \n&gt; &gt; ken\n&gt; &gt; \n&gt; &gt; \n&gt; &gt; \n&gt; &gt; --- In neat@yahoogroups.com, John Arrowwood &lt;jarrowwx@g...&gt; \nwrote:\n&gt; &gt; &gt; Okay, so after I finish making a fixed-enlargement neural \nnetwork, I\n&gt; &gt; &gt; have another thought...\n&gt; &gt; &gt;\n&gt; &gt; &gt; The way I had originally envisioned the solution to the \nproblem of\n&gt; &gt; &gt; image enlargement was a complex 2-dimensional formula that \nuses the\n&gt; &gt; &gt; original pixel inputs as &#39;constants&#39; in the formula.  The \nformula\n&gt; &gt; &gt; creates a &#39;curve surface&#39; that roughly approximates the \noriginal\n&gt; &gt; &gt; surface of which the pixel inputs are a representation of.  The\n&gt; &gt; &gt; outputs then are calculated by taking the average height of the\n&gt; &gt; &gt; surface within an area.\n&gt; &gt; &gt;\n&gt; &gt; &gt; A neural network is a classifier more than a calculator.  But \nwhat\n&gt; &gt; &gt; about using the NEAT methodology to build a formula?  Use it to\n&gt; &gt; evolve\n&gt; &gt; &gt; what in compiler terminology (if I&#39;m not mistaken) is a &#39;parse \ntree&#39;\n&gt; &gt; &gt; of the formula in a manner that is similar to a network.  Each \nnode\n&gt; &gt; is\n&gt; &gt; &gt; either a value or an operator.  Values have no connections, \nthey are\n&gt; &gt; &gt; always the leaf nodes.  Operator nodes have connections to \neither\n&gt; &gt; &gt; value nodes or other operator nodes.  The connection has a \nweight\n&gt; &gt; &gt; which is a multiplier.  So if &#39;+&#39; is connected to &#39;a&#39; with a \nweight\n&gt; &gt; of\n&gt; &gt; &gt; 0.5 and to &#39;b&#39; with a weight of 0.75, then it is the same \nthing as\n&gt; &gt; &gt; 0.5a + 0.75b.  A constant input of 1 serves like a bias, so \nyou can\n&gt; &gt; &gt; (by means of the weight) build any constant value you need.  \nAnd\n&gt; &gt; &gt; operators can be any mathematical function.\n&gt; &gt; &gt;\n&gt; &gt; &gt; So, you start with a minimal function.  It just adds all the \ninputs\n&gt; &gt; &gt; together or something.  Then you evolve the parse tree for the\n&gt; &gt; &gt; function.  To evaluate the function, you simply take the \naverage of\n&gt; &gt; &gt; the values within an (x1,y1,x2,y2) region and see if it \ncorresponds\n&gt; &gt; to\n&gt; &gt; &gt; the expected pixel value.\n&gt; &gt; &gt;\n&gt; &gt; &gt; Admittedly, the search space for such a thing would be \nenormous.\n&gt; &gt; And\n&gt; &gt; &gt; I doubt that there is a smooth ramp-up that it could follow to \nhelp\n&gt; &gt; it\n&gt; &gt; &gt; evolve.  But I don&#39;t know...has anybody read anything useful\n&gt; &gt; regarding\n&gt; &gt; &gt; evolution of formulas?\n&gt; &gt; \n&gt; &gt; \n&gt; &gt; \n&gt; &gt; \n&gt; &gt; Yahoo! Groups Links\n&gt; &gt; \n&gt; &gt; \n&gt; &gt; \n&gt; &gt; \n&gt; &gt;\n\n\n"}}