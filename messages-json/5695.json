{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":54567749,"authorName":"Ken","from":"&quot;Ken&quot; &lt;kstanley@...&gt;","profile":"kenstanley01","replyTo":"LIST","senderId":"5o2rEsxfM85o06cYV4XsJ6HNTwLdSVOubJXz3yw4qOIwLryG37AG1qNzOBiIAq_xeoi98V0vlQ7pdD8v3qb91dDa5pl1","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: Problems with competitive coevolution implementation","postDate":"1321888574","msgId":5695,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGphZHB2dStibWc0QGVHcm91cHMuY29tPg==","inReplyToHeader":"PGo4MXNzcSszYmc2QGVHcm91cHMuY29tPg=="},"prevInTopic":5661,"nextInTopic":5696,"prevInTime":5694,"nextInTime":5696,"topicId":5660,"numMessagesInTopic":4,"msgSnippet":"Hi Drew, sorry for the long time in response.  I hope your experiment is going better now, but I do have a couple suggestions: First, you mention the 8","rawEmail":"Return-Path: &lt;kstanley@...&gt;\r\nX-Sender: kstanley@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 34695 invoked from network); 21 Nov 2011 15:16:18 -0000\r\nX-Received: from unknown (98.137.34.46)\n  by m10.grp.sp2.yahoo.com with QMQP; 21 Nov 2011 15:16:18 -0000\r\nX-Received: from unknown (HELO ng10-ip2.bullet.mail.bf1.yahoo.com) (98.139.165.78)\n  by mta3.grp.sp2.yahoo.com with SMTP; 21 Nov 2011 15:16:17 -0000\r\nX-Received: from [98.139.164.124] by ng10.bullet.mail.bf1.yahoo.com with NNFMP; 21 Nov 2011 15:16:16 -0000\r\nX-Received: from [69.147.65.149] by tg5.bullet.mail.bf1.yahoo.com with NNFMP; 21 Nov 2011 15:16:16 -0000\r\nX-Received: from [98.137.35.12] by t9.bullet.mail.sp1.yahoo.com with NNFMP; 21 Nov 2011 15:16:16 -0000\r\nDate: Mon, 21 Nov 2011 15:16:14 -0000\r\nTo: neat@yahoogroups.com\r\nMessage-ID: &lt;jadpvu+bmg4@...&gt;\r\nIn-Reply-To: &lt;j81ssq+3bg6@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;Ken&quot; &lt;kstanley@...&gt;\r\nSubject: Re: Problems with competitive coevolution implementation\r\nX-Yahoo-Group-Post: member; u=54567749; y=FIxCHnhJM-SKK8wWGSdi6fQZPxN5rkDY7fKloGewN1N3QM3RgTTm\r\nX-Yahoo-Profile: kenstanley01\r\n\r\n\n\nHi Drew, sorry for the long time in response.  I hope your experiment is =\r\ngoing better now, but I do have a couple suggestions:\n\nFirst, you mention t=\r\nhe &quot;8 randomly selected hall-of-famers.&quot;  I would suggest that for a given =\r\ngeneration you select the same 8 hall-of-famers for every individual being =\r\nevaluated.  In other words, do not select a new random set for every new in=\r\ndividual being evaluated.  That will reduce noisy evaluation significantly.=\r\n  \n\nSecond, at one point you note that &quot;ties are counted as a loss, not sur=\r\ne if this is the same as the original experiment.&quot;  I think you are talking=\r\n here about how you compute dominance, and I believe this statement is corr=\r\nect.  However, how are you treating ties during evaluation itself?  It is i=\r\nmportant that ties are also given zero credit there as well.  As the origin=\r\nal paper notes:\n\n&quot;Host networks received a single fitness point for each wi=\r\nn, and no points for losing. If a competition lasted 750 time steps with no=\r\n winner, the host received zero points.&quot;\n\nIt turns out that this rule for t=\r\nies is very important because otherwise you can get a form of collusion in =\r\nwhich competing individuals effectively agree not to bother each other to a=\r\nvoid the penalty of losing without having to try to win.\n\nFinally, indeed t=\r\nhe parameters could be having an important effect.  Unfortunately, I am not=\r\n an expert in the parameters in Mat Buckland&#39;s version of NEAT, but one asp=\r\nect of parameters that can be significant is how weight mutations occur.  T=\r\nhe first thing I would do is validate any parameter settings in XOR - if th=\r\nat does not work then there is potentially a serious problem.  If XOR works=\r\n, then consider two parameters:\n\n-Weight mutation rate/proportion (both wor=\r\nds are used by different people): The probability for a single gene that it=\r\ns weight will be changes.\n\n-Weight mutation power/jiggle (both words are us=\r\ned by different people): The amount by which a random number between -1.0 a=\r\nnd 1.0 is multiplied before it is added to a weight that is being mutated.\n=\r\n\nThese can both have a big effect and should be considered carefully.  You =\r\nmight try proportions between 0.2 and 0.8, and powers between 0.25 and 1.5.=\r\n\n\nGood luck,\n\nken\n\n--- In neat@yahoogroups.com, &quot;ze_dakster&quot; &lt;drew.kirkpatr=\r\nick@...&gt; wrote:\n&gt;\n&gt; Well, I think I&#39;m onto at least one major problem, the =\r\nuse of the &quot;best fitness ever&quot; comparisons in the Cga class. While this wou=\r\nld work for standard NEAT, in a competitive environment where fitness is re=\r\nlative, these comparisons don&#39;t make sense. \n&gt; \n&gt; Maybe I should not be doi=\r\nng this, or reset it ever generation. Perhaps use a &quot;best fitness this gene=\r\nration&quot; instead. I&#39;ll have to ponder and go back over the original paper. \n=\r\n&gt; \n&gt; Any other tips are welcome :)\n&gt; \n&gt; -Drew\n&gt; \n&gt; --- In neat@yahoogroups.=\r\ncom, Drew Kirkpatrick &lt;drew.kirkpatrick@&gt; wrote:\n&gt; &gt;\n&gt; &gt; I&#39;m in the process=\r\n of working on an experiment in competitive\n&gt; &gt; coevolution for my MS thesi=\r\ns work. My first step is to recreate\n&gt; &gt; (relatively closely) Ken Stanley&#39;s=\r\n original competitive coevolution\n&gt; &gt; robot duel experiment, which is where=\r\n I am at now. This is my first\n&gt; &gt; real project with NEAT, so I&#39;m probably =\r\nmessing up some pretty basic\n&gt; &gt; stuff.\n&gt; &gt; \n&gt; &gt; Now that I can run the exp=\r\neriment, I&#39;m seeing my first problems. I&#39;m\n&gt; &gt; not seeing nearly enough com=\r\nplexification compared to the original\n&gt; &gt; experiment. I figure a good chun=\r\nk of that is my parameters need\n&gt; &gt; tweaking, but I could also be missing s=\r\nomething essential in my\n&gt; &gt; implementation.\n&gt; &gt; \n&gt; &gt; I have 10 runs, and a=\r\nll seemed to do rather poorly:\n&gt; &gt; Average of 7.9 dominant strategies\n&gt; &gt; F=\r\ninal dominant strategies have an average of 0.3 hidden nodes\n&gt; &gt; Final domi=\r\nnant strategies have an average of 43.6 connections\n&gt; &gt; \n&gt; &gt; Similarly to K=\r\nen&#39;s original experiment, I have 500 generations, with\n&gt; &gt; two teams (red a=\r\nnd blue) with 256 robots per team. Each generation\n&gt; &gt; each robot competes =\r\nin 24 matches (both left and right starts against\n&gt; &gt; 4 best agents from th=\r\ne other team, and 8 randomly selected\n&gt; &gt; hall-of-famers).\n&gt; &gt; \n&gt; &gt; The tea=\r\nm champs compete in a tournament against each other to figure\n&gt; &gt; out which=\r\n is the generation champ. I differ slightly from the original\n&gt; &gt; experimen=\r\nt as I only have them compete in 158 matches (79 food\n&gt; &gt; configurations, w=\r\nith both left and right starts). If they tie, I\n&gt; &gt; randomly select one to =\r\nbe the generation champ (not sure if this is\n&gt; &gt; how it wad done in the ori=\r\nginal experiment).\n&gt; &gt; \n&gt; &gt; The generation champ them plays all prior domin=\r\nant strategies in the\n&gt; &gt; same style tournament, and if it defeats them all=\r\n, it is the newest\n&gt; &gt; dominant strategy (ties are counted as a loss, not s=\r\nure if this is the\n&gt; &gt; same as the original experiment).\n&gt; &gt; \n&gt; &gt; My implem=\r\nentation is highly multi-threaded, written in C++ for Linux\n&gt; &gt; (I have lot=\r\ns of multicore linux boxes I can use at work). The\n&gt; &gt; underlying NEAT impl=\r\nementation is basically a Linux port of Mat\n&gt; &gt; Buckland&#39;s implementation f=\r\nrom his gaming AI book, extended a bit here\n&gt; &gt; and there, particularly to =\r\nsupport neural net duplication to support\n&gt; &gt; safe multi-threading.\n&gt; &gt; \n&gt; =\r\n&gt; All the experimental stuff is in the\n&gt; &gt; competitiveCoevolutionNeatMain.c=\r\npp file. There are two threads defined\n&gt; &gt; in there, the runJobManagerThrea=\r\nd (of which only 1 is run), and the\n&gt; &gt; runExecutionThread (of which any nu=\r\nmber will run based on parameters).\n&gt; &gt; All the NEAT stuff is encapsulated =\r\nin classes, with most work going\n&gt; &gt; through the higher level Cga class.\n&gt; =\r\n&gt; \n&gt; &gt; I&#39;m attaching a tarball of my source code (it&#39;s a work in progress a=\r\nnd\n&gt; &gt; pretty rough), and my spreadsheet with my 10 run results (summary\n&gt; =\r\n&gt; sheet, and then a sheet for each run with the name of the machine I\n&gt; &gt; u=\r\nsed).\n&gt; &gt; \n&gt; &gt; All the data in the spreadsheet is from the .csv files in th=\r\ne\n&gt; &gt; dataFiles directory in the tarball.\n&gt; &gt; \n&gt; &gt; \n&gt; &gt; Parameters are foun=\r\nd in the parameters.h file, but here are the values\n&gt; &gt; I&#39;m using:\n&gt; &gt; cons=\r\nt int    param_numAgents                        =3D 256;\n&gt; &gt; const int    p=\r\naram_numTicks                           =3D 750;\n&gt; &gt; const int    param_max=\r\nNumGenerations           =3D 500;\n&gt; &gt; \n&gt; &gt; const int    param_numBestAgents=\r\nPerTeam     =3D 4;\n&gt; &gt; const int    param_numHallOfFamers                =\r\n=3D 8;\n&gt; &gt; \n&gt; &gt; const int    param_numInputs                           =3D =\r\n13;\n&gt; &gt; const int    param_numOutputs                        =3D 3;\n&gt; &gt; con=\r\nst int    param_maxPermittedNeurons         =3D 2000;\n&gt; &gt; const int    para=\r\nm_numTrysToFindOldLink        =3D 5;\n&gt; &gt; const int    param_numTrysToFindLo=\r\nopedLink   =3D 5;\n&gt; &gt; const int    param_numAddLinkAttempts          =3D 5;=\r\n\n&gt; &gt; \n&gt; &gt; const int    param_numGensAllowedNoImprovement =3D 30;\n&gt; &gt; const =\r\nint    param_youngBonusAgeThreshold           =3D 10;\n&gt; &gt; const int    para=\r\nm_oldAgeThreshold                         =3D 50;\n&gt; &gt; const double param_yo=\r\nungFitnessBonus                 =3D 1.3;\n&gt; &gt; const double param_oldAgePenal=\r\nty                         =3D 0.7;\n&gt; &gt; const double param_survivalRate    =\r\n                         =3D 0.2;\n&gt; &gt; \n&gt; &gt; // Mutation stuff\n&gt; &gt; const doub=\r\nle param_crossoverRate                          =3D 0.7;\n&gt; &gt; const double p=\r\naram_chanceAddNode                      =3D 0.01;\n&gt; &gt; const double param_ch=\r\nanceAddLink                       =3D 0.1;\n&gt; &gt; const double param_chanceAdd=\r\nRecurrentLink          =3D 0.05;\n&gt; &gt; const double param_mutationRate       =\r\n                    =3D 0.8;\n&gt; &gt; const double param_probabilityWeightReplac=\r\ned       =3D 0.1;\n&gt; &gt; const double param_maxWeightPerturbation            =\r\n=3D 0.9;\n&gt; &gt; const double param_activationMutationRate             =3D 0.1;=\r\n\n&gt; &gt; const double param_maxActivationPerturbation        =3D 0.1;\n&gt; &gt; \n&gt; &gt; =\r\n\n&gt; &gt; // Compatibility calculation parameters\n&gt; &gt; const double param_mExcess=\r\n                      =3D 1.0; // C1\n&gt; &gt; const double param_mDisjoint      =\r\n                =3D 1.0; // C2\n&gt; &gt; const double param_mMatched             =\r\n       =3D 2.0; // C3\n&gt; &gt; \n&gt; &gt; // Can be overridden using Cga::SetCompatibi=\r\nlityThreshold for dynamic use\n&gt; &gt; const double param_compatibilityThreshold=\r\n      =3D 3.0;\n&gt; &gt; \n&gt; &gt; // If using dynamic compatibility thresholds,\n&gt; &gt; /=\r\n/ Cga will use these parameters as a minimum\n&gt; &gt; // and maximum\n&gt; &gt; const d=\r\nouble param_minCompatibilityThreshold   =3D   0.1;\n&gt; &gt; const double param_m=\r\naxCompatibilityThreshold   =3D 500.0;\n&gt; &gt; \n&gt; &gt; // If using dynamic compatib=\r\nility thresholds, here&#39;s\n&gt; &gt; // a convenient place to stash the target numb=\r\ner\n&gt; &gt; // of species. Dynamic changing of compatibility\n&gt; &gt; // threshold is=\r\n NOT handled by the Cga class,\n&gt; &gt; // you need to handle that in your own c=\r\node\n&gt; &gt; const int    param_targetNumSpecies            =3D 10;\n&gt; &gt; \n&gt; &gt; \n&gt; =\r\n&gt; // For tournaments, this is the number of\n&gt; &gt; // results the job manager =\r\nwill look to\n&gt; &gt; // indicate that all tournament results\n&gt; &gt; // are in\n&gt; &gt; =\r\n// This number is half of the number of\n&gt; &gt; // tournament evals, since left=\r\n and right\n&gt; &gt; // start results are lumped together.\n&gt; &gt; const int    param=\r\n_numTournamentResultRecords =3D 79;\n&gt; &gt; \n&gt; &gt; \n&gt; &gt; \n&gt; &gt; // Parallell process=\r\ning parameters:\n&gt; &gt; // Number of execution processes to\n&gt; &gt; // use for eval=\r\nuations.\n&gt; &gt; const int    param_numExecutionThreads         =3D 9;\n&gt; &gt; \n&gt; &gt;=\r\n // How many jobs the execution threads will snag\n&gt; &gt; // at once from globa=\r\nl job queue\n&gt; &gt; const int    param_numJobsToLoad               =3D 30;\n&gt; &gt; =\r\n\n&gt; &gt; \n&gt; &gt; // The port number the tcp network server will listen on\n&gt; &gt; cons=\r\nt int    param_networkPort                 =3D 7474;\n&gt; &gt; \n&gt; &gt; \n&gt; &gt; No doubt=\r\n I need to tweak my parameters, but I&#39;m wondering if my\n&gt; &gt; implementation =\r\nis missing something essential from the original one.\n&gt; &gt; \n&gt; &gt; \n&gt; &gt; Any tip=\r\ns from the NEAT gurus out there would be *most* appreciated,\n&gt; &gt; It&#39;s taken=\r\n me far longer to get to this point than I imagined, and I&#39;m\n&gt; &gt; quickly ru=\r\nnning short of time to finish my thesis.\n&gt; &gt; \n&gt; &gt; \n&gt; &gt; -Drew Kirkpatrick\n&gt; =\r\n&gt;\n&gt;\n\n\n\n"}}