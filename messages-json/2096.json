{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":170210925,"authorName":"Ashot Petrosian","from":"&quot;Ashot Petrosian&quot; &lt;ashot@...&gt;","profile":"Ashot_Petrosian","replyTo":"LIST","senderId":"A_eUrAi3FpU3EqXx-m3GxzI4mdqp0jQFacGAC700b5GXV6MB5K4EjAQdN8gsRXqDcaCt9uwyEPFXeALBVF7PkZGcSi5b5sOL_3AUvBOEexE","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Introduction/Some Questions","postDate":"1121512482","msgId":2096,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PG9wc3R6NnVzczN4NHAzM21AbWFpbC51dGV4YXMuZWR1Pg==","inReplyToHeader":"PFBpbmUuTE5YLjQuNjMuMDUwNzE1MDkzMjA2MC40MzAzQG9yYW5nZS1wZWtvZS5jcy51dGV4YXMuZWR1Pg==","referencesHeader":"PGRiN240ZStqOXNmQGVHcm91cHMuY29tPiA8UGluZS5MTlguNC42My4wNTA3MTUwOTMyMDYwLjQzMDNAb3JhbmdlLXBla29lLmNzLnV0ZXhhcy5lZHU+"},"prevInTopic":2090,"nextInTopic":2105,"prevInTime":2095,"nextInTime":2097,"topicId":2088,"numMessagesInTopic":13,"msgSnippet":"... Yea, this was the first thing that hit me when I read about NEAT.. Is there an anti-modular contingency? If there is, we ll show em ;) ... If the parent","rawEmail":"Return-Path: &lt;ashot@...&gt;\r\nX-Sender: ashot@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 72333 invoked from network); 16 Jul 2005 11:14:43 -0000\r\nReceived: from unknown (66.218.66.172)\n  by m23.grp.scd.yahoo.com with QMQP; 16 Jul 2005 11:14:43 -0000\r\nReceived: from unknown (HELO wb2-a.mail.utexas.edu) (128.83.126.136)\n  by mta4.grp.scd.yahoo.com with SMTP; 16 Jul 2005 11:14:43 -0000\r\nReceived: (qmail 68750 invoked from network); 16 Jul 2005 11:14:42 -0000\r\nReceived: from pcp07743086pcs.nrockv01.md.comcast.net (HELO mail.utexas.edu) (ashot@69.138.172.137)\n  by wb2.mail.utexas.edu with RC4-SHA encrypted SMTP; 16 Jul 2005 11:14:42 -0000\r\nDate: Sat, 16 Jul 2005 06:14:42 -0500\r\nTo: neat@yahoogroups.com\r\nReferences: &lt;db7n4e+j9sf@...&gt; &lt;Pine.LNX.4.63.0507150932060.4303@...&gt;\r\nContent-Type: text/plain; format=flowed; delsp=yes; charset=iso-8859-15\r\nMIME-Version: 1.0\r\nContent-Transfer-Encoding: 8bit\r\nMessage-ID: &lt;opstz6uss3x4p33m@...&gt;\r\nIn-Reply-To: &lt;Pine.LNX.4.63.0507150932060.4303@...&gt;\r\nUser-Agent: Opera M2/7.50 (Win32, build 3778)\r\nX-eGroups-Msg-Info: 1:12:0\r\nX-eGroups-From: &quot;Ashot Petrosian&quot; &lt;ashot@...&gt;\r\nFrom: &quot;Ashot Petrosian&quot; &lt;ashot@...&gt;\r\nSubject: Re: [neat] Introduction/Some Questions\r\nX-Yahoo-Group-Post: member; u=170210925; y=TXiS3OqASQbzgy4NitLgDJpzu_x511Cd6F85OjZhtIl6FP7UPlG0aCYZ\r\nX-Yahoo-Profile: Ashot_Petrosian\r\n\r\nOn Fri, 15 Jul 2005 10:24:07 -0500 (CDT), Joseph Reisinger &lt;joeraii@...&gt; wrote:\n\n&gt; Hi Ashot,\n&gt;\n&gt; Its great to see another face in the modular NEAT camp, at the moment\n&gt; we&#39;re greatly outnumbered :) But anyway in general its nice to see more\n&gt; people tacking the &quot;NN representation problem,&quot; particularly since the\n&gt; limitations of direct NN encodings are so painful.\n\nYea, this was the first thing that hit me when I read about NEAT.. Is there an anti-modular contingency? If there is, we&#39;ll show &#39;em ;)\n\n&gt;\n&gt;&gt; \tMy initial idea was a type of modular NEAT. Essentially the way it\n&gt;&gt; works is that each new innovation actually creates a coevolving NEAT\n&gt;&gt; population which starts as simple but can complexify (which then have\n&gt;&gt; nodes which can complexify).  Every network that uses this innovation\n&gt;&gt; would actually share the same &#39;module&#39; which would be the module with\n&gt;&gt; the best average fitness across all networks.  Modules would be\n&gt;&gt; evolved for several generations before the &#39;top&#39; NEAT population was\n&gt;&gt; given one generation.  The benefits here are that this would allow\n&gt;&gt; evolution to choose the level of modularity that was fitting for the\n&gt;&gt; problem, would be a continuous &#39;evolution&#39;(pardon) on NEAT rather than\n&gt;&gt; a radical change (in other words it reduces to NEAT), and would solve\n&gt;&gt; the problem of adding on new modules while maintaining smooth mutation\n&gt;&gt; (by starting them small).  Sort of an ESP meets NEAT idea perhaps.\n&gt;&gt; I&#39;ve looked over some of Joe&#39;s stuff, but I think this is different in\n&gt;&gt; that modularity is optional rather than forced.\n&gt;\n&gt; This is definitely an interesting direction, I particular appreciate that\n&gt; you&#39;ve found a way to circumvent &quot;forcing&quot; modularity, as this would\n&gt; probably improve your performance in cases where a lot of modularity is\n&gt; not strictly necessary to solve the problem. I have a few questions\n&gt; though:\n&gt;\n&gt; 1) What is the fitness function of the co-evolved module populations? Just\n&gt; maximizing the average fitness of the &#39;top&#39; population? One of the things\n&gt; we found out running modular NEAT was that promoting &quot;generalist&quot; module\n&gt; strategies over &quot;specialist&quot; module strategies didn&#39;t really make sense.\n&gt; Shouldn&#39;t you want to keep any module that creates an innovative\n&gt; breakthrough, even if it only does so in one member of the &#39;top&#39;\n&gt; population (i.e. has a low average fitness, but generates a fitness spike\n&gt; in one parent).\n\nIf the parent has a mechanism for adding this mutation itself, then it seems like this is exactly what you would not want to do.  In fact, I was going to go further than that.  Rather than use the average I wanted to multiply the fitnesses together specifically so this wouldn&#39;t happen.  I&#39;m not sure I understand why this doesn&#39;t make sense, isn&#39;t it exactly the selective pressure that we are looking for?  Maybe I need to read your paper again, its been a while =]\n\nAs a side note actually, I&#39;ve found that this method (multiplying fitness together rather than averaging them) was helpful when evaluating a network on multiple random runs.  If I used the average networks would fall into the local minimum of solving the problem really well some of the time rather than trying to solve the problem all the time.  This worked really well, so I&#39;m sure its not a new idea I just don&#39;t know what its called.  To control the intensity of the effect I actually divide by n and 1 before multiplying.\n\n\n&gt; 2) How will you generate the initial seeding of a module population?\nRandomly?  I don&#39;t think I understand your question.\n\n&gt; 3) How will you allocate input/outputs and module connectivity? This was\n&gt; one of the trickiest problems in writing modular NEAT (you discuss this at\n&gt; length below, see my reply).\n\nYea this is important.  It seems that the most natural solution is to start each module simple, but allow it to grow its inputs/outputs (fs neat).\n\n&gt;\n&gt; 4) How will you deal with the stochastic evaluation situation created by\n&gt; module-module co-evolution. Consider this case: two modules (A and B)\n&gt; compose network X. Under your algorithm (if I understand correctly) A gets\n&gt; an evolution phase, B gets an evolution phase, and then X evolves one\n&gt; generation. So now when we come back to A&#39;s evolution phase, the\n&gt; population fitness rankings may have completely changed, because fitness\n&gt; is dependent on B&#39;s evolution is well. In modular NEAT this proved to be\n&gt; the biggest weak point in the algorithm, since it yielded no real module\n&gt; evolution (if you read the paper: modules evolved to be /highly/\n&gt; generalist, and then it turned out that only bindings really mattered for\n&gt; fitness).\n\nsee below\n\n&gt;\n&gt; One approach Ken and I discussed akin to this is &quot;hierarchical\n&gt; modularizing NEAT&quot; where subpopulations could have their own\n&gt; subpopulations of modules, ad infinitum. This allows evolution to choose the\n&gt; right granularity for each module more effectively, at the cost of having\n&gt; to evaluate many, many more subpopulations. Initially, you don&#39;t really\n&gt; know how complex a module needs to be, so you start by making naive module\n&gt; partitions. Later, however, it may turn out that some modules you\n&gt; partitioned off can stay simple, but others may need to become very\n&gt; complex (i.e. should be constructed out of sub-modules). Anyway, it seems\n&gt; your approach is a good first step towards this. I&#39;m very interested in to\n&gt; see your results.\n\nYea, I&#39;ve thought about the recursive idea as well, although I&#39;m not clear how that solves any of the above problems (maybe you didn&#39;t mean to imply that it did?).  This would be particularly nice if it was in an environment were evolution was able to decide how much modularity was needed etc.  It certainly would not be difficult to make the algorithm heirchical as in essence it already is.\n\n&gt;\n&gt;&gt; \tThe main questions with this approach is what the base building block\n&gt;&gt; should be and how to produce the initial selection pressure for\n&gt;&gt; modularity (since the &#39;module&#39; would be used in the same network).\n&gt;&gt; The building block can be just a node, just a link, or more.  By more\n&gt;&gt; perhaps the new module should have the option of connecting from a\n&gt;&gt; random set of up to n to another random set of up to n nodes.  By\n&gt;&gt; changing the n we can have different binding specificity for the\n&gt;&gt; modules.\n&gt;\n&gt; Did Risto show you the (unpublished) paper by Steetskamp? He did some\n&gt; tests on doing SANE/ESP with things other than fully connected nodes (for\n&gt; example individual links, half-nodes, etc). And the main thing he found\n&gt; was that once you introduce hard-dependencies between two modules (i.e. if\n&gt; module A&#39;s output feeds only into module B), then correctly evaluating\n&gt; module performance becomes very difficult (i.e. module A&#39;s fitness is now\n&gt; completely at the whim of module B, and vice-versa).\n\nRight well this makes sense, in this case there really aren&#39;t two seperate modules.  This doesn&#39;t seem deadly though, essentially you would just have one module but you&#39;d be treating it like two, so its not a big deal, right?   You could even do a check every x generations and if combine modules together if they always appear together. Feels like a hack though.\n\nThe only way I see of addressing this issue under my scenario is too let the parent population evolve substantially first, before starting the sub-module evolutions.  This way each innov would be in a somewhat different environment and we get some selective pressure towards modularity.  Maybe this would provide the right balance between no bindings and all bindings? (did that make sense?)\n\n\n&gt; Anyway,  if the building block is just a link, how would you then do\n&gt; complexification? You&#39;d need some mechanism to pull in more inputs\n&gt; and maybe more outputs later (similar perhaps to Shimon&#39;s work on fsNEAT).\n\nI don&#39;t think this is necessarily true, can&#39;t we run neat on a one input/one output problem? It should work the same way.  This could actually be an interesting restriction because it requires the module to &#39;compute&#39; something and pass it on, rather than operate the way a NN normally would.  But it was really just a random thought..\n\n&gt;&gt; Think along these lines brought up some other questions.  When NEAT\n&gt;&gt; adds a node it actually is functionally no different then a weight\n&gt;&gt; mutation (with the exception of the non-linearity of the sigmoid).\n&gt;&gt; For a node to really add functionality above what direct link can\n&gt;&gt; accomplish it must at least have two inputs or two outputs.  So for\n&gt;&gt; NEAT to take advantage of a new node mutation it actually has to get\n&gt;&gt; lucky twice, once to add node in the right place, and another two add\n&gt;&gt; a link to/from it.  I think in general this problem is sidestepped by\n&gt;&gt; having a much higher add-connection rate.  If I&#39;m right on this (am I?\n&gt;&gt; ) then perhaps the mutation should  be changed to add a node which\n&gt;&gt; connects two inputs/outputs simultaneously, or n inputs/outputs?\n&gt;\n&gt; This is probably worth exploring. I&#39;ll defer to Ken on discussing it,\n&gt; though.\n\nKen?\n\n&gt;&gt; \tAlong the same lines of thinking, has anyone tried using more\n&gt;&gt; powerful functions at the nodes rather than just a threshold? For\n&gt;&gt; example an average, or maximum, or minimum, or a switch, or so on?\n&gt;\n&gt; I was just discussing adding gating/competition to NEAT with Risto a few\n&gt; weeks ago. He seems to think it might be worthwhile. For example,\n&gt; competition between nodes could be implemented simply using a &quot;compete&quot;\n&gt; type link, which would then compare the activation of the two competing\n&gt; nodes, and only allow the node with the higher activation to fire.\n\nYea, something like this would be nice, although I think that the decider should be seperate from the output of the switch itself.  For example a node with 3 (or n) inputs, one of which chooses between the other two.  But it seems if we are augmenting the network by allowing it to do something that its not good at doing, why stop there? Why not just go all the way and give it all sorts of fun things to play with?\n\n&gt;&gt; mutations incremental by being clever.  The only drawback I see here\n&gt;&gt; is that this is less biologically &#39;accurate&#39;, but this is irrelevant\n&gt;&gt; for us right?  I can think of several functions that would be\n&gt;&gt; particularly useful in combining modules together, or reusing modules\n&gt;&gt; in new places.\n&gt;\n&gt; Yes, Ken gave a great talk at GECCO this year on fully exploring where we\n&gt; should be shackled to biology, and where we should cast off our slimy\n&gt; organic fetters.\nfetters, I like that.\n\n&gt;&gt; \tMore along the same lines, and with some inspiration from this paper:\n&gt;&gt; http://nn.cs.utexas.edu/lookup?whiteson:gecco03, what I am leaning\n&gt;&gt; towards now is writing a switch network on top of the regular NEAT\n&gt;&gt; population.  The algorithm would start with just one NEAT population\n&gt;&gt; which attempts to solve the entire problem, then after n generations,\n&gt;&gt; or after stagnation, a switch network would complexify on top of this\n&gt;&gt; population. At each &#39;switch&#39; an NN also evolves which makes the\n&gt;&gt; decision on which network to choose to perform the task.  I think the\n&gt;&gt; difficulty here is the chicken and egg problem in getting the system\n&gt;&gt; off the ground.  What I&#39;m aiming for is to solve the 3v1 keepaway task\n&gt;&gt; (from the paper) without using hand coded sub-tasks.  I&#39;m not sure\n&gt;&gt; I&#39;ve atriculated this very well, but hopefully the gist comes across.\n&gt;&gt; Thanks for any thoughts.\n&gt;\n&gt; This is definitely a more tractable architecture, but its more rigid, and\n&gt; limited a-priori. What if you find you need 4 behaviors, instead of 3?\n&gt; Also, how would you handle the switching in networks with recurrent\n&gt; connections (i.e. memory)? Would each network &quot;observe&quot; and keep track of\n&gt; memory individually, or would a switch start running from a &quot;newly\n&gt; awakened&quot; sub-network?\n\nWell, the decision tree would complexify, so it would be one, then two, then three, and then each of those could turn into 2 sub-behaviours etc.  The mutations being add a behavior at this switch, or subdivide this behaviour into sub-tasks.  I had thought about the recursive links before, it seems that the best solution (although more compuationaly heavy) is to keep them all evaluating all the time (or at least all recurrent nets).\n\nYou are right though in that this is more rigid, however I think I&#39;ve settled on this for now for several reasons.  One of the most important being that I can make sure that this type of modularity exists easily by using a problem which requires distinct behaviours.  Perhaps actually we (or I?) should expand the vocabularity a bit as I can think of three distinct types of modularity which probably shouldn&#39;t be lumped up.  One type is the sequential: do this, then using the result do something else.  Second type is to do two things both at the same time, but in parallel, and the third is to do one thing sometimes, and do something else another time.  So ideally I think there should be a system which is easily capable of doing all of these recursively and arbitrarily intermixed.  So this becomes sort of a GP on top of NEAT modules as building blocks sort of thing (a smooth GP.. at least in my head).\n\nAnyway, so the most perplexing thing for me right now (you touched on this above) seems to be how to combine the evolution of the different levels, especially since the selection pressures will be changing.  In my mind the best solution that I&#39;ve come to is to just wipe the slate clean everytime.  This is how this would work for the switch network idea (although this could be applied elsewhere too):\n\n1. Regular NEAT tries to solve the problem.\n2. A switching network evolves using the resulting species as sub-behaviours\n3. The old NEAT population is wiped clean and now n NEAT populations co-evolve as the sub-behaviours using the winning switch network.\n4. The switch evolves from scratch using the new NEAT populations as the sub-behaviours.\netc..\n\nObviously this is computationally pretty expensive, but it seems like this sort of &#39;forgetting&#39; is necessary here since the task (for all the pieces) changes.  I see no other way of solving the chicken and egg problem.  I have some more ideas on this, but I&#39;m not sure if this is the question you were addressing?\n\n\n&gt; Anyway, this looks like a great start, and I hope you will be continuing\n&gt; this work in the Fall as well.\n&gt;\n\nThanks for the insightful questions, I&#39;ve actually really been missing someone to bounce ideas off of.  Actually, I&#39;m not used to talking about this stuff, the vocab seems a bit awkward, so I&#39;m not sure I&#39;m doing my thoughts justice.. ultimately I&#39;ll just have to code them I think =P\n\n-Ashot\n\n"}}