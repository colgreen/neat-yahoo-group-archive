{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":127853030,"authorName":"Colin Green","from":"Colin Green &lt;cgreen@...&gt;","profile":"alienseedpod","replyTo":"LIST","senderId":"dKofus0hHFpo8_gp8xXe8L1VIPjvTsV_3J6qLEZgFFb7zFB5qq2kpIIC5w6-EmHtZjaooJxJ0iJSmAnvekEP7rmW6CHfST61FQ","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Adding only feed-forward connections","postDate":"1131310594","msgId":2390,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQzNkU2RTAyLjcwMTAzMDRAZHNsLnBpcGV4LmNvbT4=","inReplyToHeader":"PDYuMi4zLjQuMC4yMDA1MTEwMzEyMTEwNS4wMzNhNGRjMEBwb3AubWFpbC55YWhvby5jby51az4=","referencesHeader":"PDYuMi4zLjQuMC4yMDA1MTEwMjEwNTMzOC4wMzMzYzczMEBwb3AubWFpbC55YWhvby5jby51az4gPDIwMDUxMTAyMTQ1MDA3LjgyNjI2LnFtYWlsQHdlYjUyODEzLm1haWwueWFob28uY29tPiA8Ni4yLjMuNC4wLjIwMDUxMTAyMTUxOTU2LjAzMzg1NzYwQHBvcC5tYWlsLnlhaG9vLmNvLnVrPiA8NDM2OTM4MjcuMjAyMDhAZHNsLnBpcGV4LmNvbT4gPDYuMi4zLjQuMC4yMDA1MTEwMzEyMTEwNS4wMzNhNGRjMEBwb3AubWFpbC55YWhvby5jby51az4="},"prevInTopic":2385,"nextInTopic":2394,"prevInTime":2389,"nextInTime":2391,"topicId":2372,"numMessagesInTopic":22,"msgSnippet":"... Ok yeh I ve got it. Each node has a bit array that indicates which nodes (through however long a pathway) connect into it. I suppose you could do it the","rawEmail":"Return-Path: &lt;cgreen@...&gt;\r\nX-Sender: cgreen@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nReceived: (qmail 50463 invoked from network); 6 Nov 2005 20:56:36 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m21.grp.scd.yahoo.com with QMQP; 6 Nov 2005 20:56:36 -0000\r\nReceived: from unknown (HELO blaster.systems.pipex.net) (62.241.163.7)\n  by mta2.grp.scd.yahoo.com with SMTP; 6 Nov 2005 20:56:35 -0000\r\nReceived: from [10.0.0.10] (81-86-161-87.dsl.pipex.com [81.86.161.87])\n\tby blaster.systems.pipex.net (Postfix) with ESMTP id A56B9E0001D8\n\tfor &lt;neat@yahoogroups.com&gt;; Sun,  6 Nov 2005 20:56:34 +0000 (GMT)\r\nMessage-ID: &lt;436E6E02.7010304@...&gt;\r\nDate: Sun, 06 Nov 2005 20:56:34 +0000\r\nUser-Agent: Mozilla Thunderbird 1.0.2 (Windows/20050317)\r\nX-Accept-Language: en-us, en\r\nMIME-Version: 1.0\r\nTo: neat@yahoogroups.com\r\nReferences: &lt;6.2.3.4.0.20051102105338.0333c730@...&gt; &lt;20051102145007.82626.qmail@...&gt; &lt;6.2.3.4.0.20051102151956.03385760@...&gt; &lt;43693827.20208@...&gt; &lt;6.2.3.4.0.20051103121105.033a4dc0@...&gt;\r\nIn-Reply-To: &lt;6.2.3.4.0.20051103121105.033a4dc0@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-eGroups-Msg-Info: 1:12:0:0\r\nFrom: Colin Green &lt;cgreen@...&gt;\r\nSubject: Re: [neat] Adding only feed-forward connections\r\nX-Yahoo-Group-Post: member; u=127853030; y=rQRqaYlReweewREPn98WSSSAzziPTpFmVc52Fldo-W6PaYsZjARN\r\nX-Yahoo-Profile: alienseedpod\r\n\r\nIan Badcoe wrote:\n\n&gt;One cheap way to handle this might be to keep a bit-array on each \n&gt;node.  Each node owns a unique bit in that array (2 ^ innovation, if \n&gt;you like).  Now you can proceed as with the counting, only you are \n&gt;ORing in the bits.  So, nodes adjoining the input layer (I&#39;m skipping \n&gt;the inputs themselves as I assume you already avoid recurrent \n&gt;connections to them) have just their own bit set.  Other nodes have \n&gt;all the bits that are set in their children, plus their own bit set.\n&gt;  \n&gt;\n&gt;This is quite efficient because:\n&gt;\n&gt;1) you detect recurrence when, if you are adding a connection, the \n&gt;source has the destination&#39;s bit set.  This means that the \n&gt;destination already exists upstream of the source.\n&gt;  \n&gt;\nOk yeh I&#39;ve got it. Each node has a bit array that indicates which nodes \n(through however long a pathway) connect into it. I suppose you could do \nit the other way around also - keep a bit array of all nodes that are \nconnected to. Not sure if there&#39;s any gain in doing it that way.\n\n&gt;2) when you add a connection you just have to merge the source&#39;s bits \n&gt;into the destination.  Only when that leads to a change in the \n&gt;destination&#39;s bits do you need to recursively propagate those changes \n&gt;through its downstream connections.  And merging is just an OR \n&gt;operation, and ORing on an unsigned long will do 32 at once....\n&gt;  \n&gt;\nSo consider a network with say 2000 nodes, we&#39;re talking about \n(2000/32)*4bytes = 252 bytes of storage per node. 2000 * 252 = 504,000 \nbytes in all. In a population of 1000 this comes to about 504 MBytes. It \nseems a little excessive but it&#39;s within reason these days.\n\n&gt;3) it gets a little more expensive if you delete a connection, you \n&gt;have to tear-down the destination&#39;s current bit array and rebuilt if \n&gt;from all children, but even that&#39;s not so expensive and 66.66% of all \n&gt;NEAT implementations don&#39;t delete connections anyway.\n&gt;  \n&gt;\nIn SharpNEAT you /can/ do what Derek & Philip called blended searches, \nbut by default I switch between complexifying and pruning/simplifying. \nIn which case I could just not update the bit arrays while I&#39;m pruning, \nand rebuild them all in one go when I switch back into complexifying \nmode. But if the user chooses to do both types of mutation then which \ntechnique is faster overall comes down to the relative rates of the two \ntypes of mutation. Probably there aren&#39;t many CPU cycles to be saved in \nsuch an approach, and probably not enough to warrant the extra \ncomplexity - I do like to optimise code but I also like to keep it as \nsimple as possible.\n\n&gt;--\n&gt;\n&gt;All that said, to go back to my failed example:\n&gt;\n&gt;  \n&gt;\n&gt;&gt;&gt;A -&gt; B -&gt; C -&gt;D\n&gt;&gt;&gt;\n&gt;&gt;&gt;A-&gt; B&#39; -&gt;C&#39; -&gt;D\n&gt;&gt;&gt;      \n&gt;&gt;&gt;\n&gt;\n&gt;Where the original scheme couldn&#39;t connect C to B&#39;.\n&gt;\n&gt;What happens now when individual 1 has just connected C to B&#39; and \n&gt;individual 2 has just connected C&#39; to B and they try to breed?\n&gt;  \n&gt;\nThis feels like something that has come up before. Anyone have a quick \nresponse to hand? I guess it&#39;s back to loop detection again.\n\nMy instinct tells me this is getting a bit complex. It&#39;s been a useful \nexercise but right now the simple approach of ensuring connections are \nalways to a higher ID seems favourable to my mind.\n\nCheers,\n\nColin.\n\n\n\n"}}