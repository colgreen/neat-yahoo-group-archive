{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":82117382,"authorName":"Jim O&#39;Flaherty","from":"Jim O&#39;Flaherty &lt;jim_oflaherty_jr@...&gt;","profile":"jim_oflaherty_jr","replyTo":"LIST","senderId":"PoEhGQMrvKk_ThhnqW9vYr1AgZQ2vN5tImchQIaHQwH0Ue3K4ryayCP74rOo9BDYcxClbJ2si-QmPwxTl9XCc6CgIb5xNaZCNnHtd7RIcWRxOQ","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [neat] Re: rtNEAT: max_depth() in an endless loop","postDate":"1225741227","msgId":4412,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQ5MEY1M0FCLjUwNjAwMDJAeWFob28uY29tPg==","inReplyToHeader":"PGdlbmo4ZitmbjFrQGVHcm91cHMuY29tPg==","referencesHeader":"PGdlbmo4ZitmbjFrQGVHcm91cHMuY29tPg=="},"prevInTopic":4411,"nextInTopic":4413,"prevInTime":4411,"nextInTime":4413,"topicId":4396,"numMessagesInTopic":16,"msgSnippet":"Joel, Ah. Okay. That s interesting. Well, I have not looked at the C++ code, so I don t know how it is implemented. I am confused what it means by activating","rawEmail":"Return-Path: &lt;jim_oflaherty_jr@...&gt;\r\nX-Sender: jim_oflaherty_jr@...\r\nX-Apparently-To: neat@yahoogroups.com\r\nX-Received: (qmail 95677 invoked from network); 3 Nov 2008 19:40:35 -0000\r\nX-Received: from unknown (66.218.67.96)\n  by m50.grp.scd.yahoo.com with QMQP; 3 Nov 2008 19:40:35 -0000\r\nX-Received: from unknown (HELO smtp110.prem.mail.sp1.yahoo.com) (98.136.44.55)\n  by mta17.grp.scd.yahoo.com with SMTP; 3 Nov 2008 19:40:34 -0000\r\nX-Received: (qmail 36559 invoked from network); 3 Nov 2008 19:40:31 -0000\r\nX-Received: from unknown (HELO ?192.168.1.2?) (jim_oflaherty_jr@24.175.76.77 with plain)\n  by smtp110.prem.mail.sp1.yahoo.com with SMTP; 3 Nov 2008 19:40:30 -0000\r\nX-Yahoo-Newman-Property: ymail-3\r\nMessage-ID: &lt;490F53AB.5060002@...&gt;\r\nDate: Mon, 03 Nov 2008 13:40:27 -0600\r\nUser-Agent: Thunderbird 2.0.0.17 (Windows/20080914)\r\nMIME-Version: 1.0\r\nTo: neat@yahoogroups.com\r\nReferences: &lt;genj8f+fn1k@...&gt;\r\nIn-Reply-To: &lt;genj8f+fn1k@...&gt;\r\nContent-Type: multipart/alternative;\n boundary=&quot;------------020908010804060705050406&quot;\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: Jim O&#39;Flaherty &lt;jim_oflaherty_jr@...&gt;\r\nSubject: Re: [neat] Re: rtNEAT: max_depth() in an endless loop\r\nX-Yahoo-Group-Post: member; u=82117382; y=MAqb3ND2maNsuNAUGd2pbcBGWFcYE1GXbmVfvuweAiSnGN5oxi6sVT5lEg\r\nX-Yahoo-Profile: jim_oflaherty_jr\r\n\r\n\r\n--------------020908010804060705050406\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\n\r\nJoel,\n\nAh. Okay. That&#39;s interesting.\n\nWell, I have not looked at the C++ code, so I don&#39;t know how it is \nimplemented. I am confused what it means by activating enough times so \nthe input makes it to the output layer. In my implementation, the input \nalways makes it to the output layer in a single pass. What does it mean \nto activate a network where the signals are not propagated all the way \nfrom the input nodes to the output nodes? I&#39;m confused, how do you \npartially activate the network? And why would you want to do that? It \nseems the output wouldn&#39;t make any sense unless all of the signals had \nall been propagated completely throughout the network.\n\nAs to determining depth - does that mean the longest sequence of \nfeed-forward connections between an input node and an output node? If \nso, that is a pretty simple graph traversal formula. And if recurrent \nconnections are marked (I have them marked in my implementation), then \nwhen exploring the graph to calculate depth, just ignore traversing \nnodes marked as recurrent, and that ought to kill any cycles and/or \nendless loops. If recurrent nodes are not marked, is there an aging \nvalue on the nodes such that you know that a node with an earlier age \nwill for sure be activated before one with an later age? If so, then you \ncan do the graph traversal including forward nodes as only those &quot;older&quot; \nthan the current one being traversed. If there is no means to indicate \ndependency direction separate from the weights linking the nodes, then \nyou can generate your own dependency array on the fly, and then use that \nto do your pathing calculations.\n\n\nJim\n\n\njoel278 wrote:\n&gt;\n&gt; Hey Jim,\n&gt;\n&gt; I think there is some confusion here because the issue in question\n&gt; is specific to the rtNEAT implementation (the bug may be present in\n&gt; the original C++ version as well, although I haven&#39;t checked).\n&gt;\n&gt; In rtNEAT, there is a function that calculates the maximum depth of\n&gt; a network, and is meant only to be applied to non-recurrent networks.\n&gt; This is useful if you are trying to query a net efficiently, so you\n&gt; only have to activate it enough times for the input signals to\n&gt; propagate all the way to the output.\n&gt;\n&gt; However, there is a bug in the rtNEAT implementation such that\n&gt; even with recurrent connections disabled, somehow they can still seep\n&gt; into a network occasionally.\n&gt;\n&gt; If this happens, and the maximum depth function is called on a net\n&gt; with recurrent connections, an endless loop can result. This is\n&gt; because the function was designed only to work with non-recurrent\n&gt; networks.\n&gt;\n&gt; Tom, you are right in that this method cannot easily be extended to\n&gt; dealing with recurrent networks.\n&gt;\n&gt; Often the strategy that you mention is applied, arbitrarily activating\n&gt; the net a reasonable number of times. It is an\n&gt; easy way to avoid this bug until it is fixed.\n&gt;\n&gt; Joel\n&gt;\n&gt; --- In neat@yahoogroups.com &lt;mailto:neat%40yahoogroups.com&gt;, Jim \n&gt; O&#39;Flaherty &lt;jim_oflaherty_jr@...&gt; wrote:\n&gt; &gt;\n&gt; &gt; Peter,\n&gt; &gt;\n&gt; &gt; That doesn&#39;t make sense to me. Cesar&#39;s comments indicate he has a\n&gt; &gt; similar implementation to mine. Basically, every node&#39;s value in a\n&gt; &gt; single instance of an ANN is calculated just once on an activation\n&gt; pass.\n&gt; &gt; When the node is calculated, each of the nodes attached to it as\n&gt; &quot;input&quot;\n&gt; &gt; are used (whether they have been activated in this pass, or hold a\n&gt; &gt; residual value from the previous pass) to calculate it&#39;s current value.\n&gt; &gt; And assuming the ordering of the activations is lined up by dependency\n&gt; &gt; and they by node age, the network ought to activate deterministically\n&gt; &gt; meaning that starting with an empty network (all node activation values\n&gt; &gt; are set to 0.0), providing the same input and making several activation\n&gt; &gt; passes ought to be able to return reliably repeatable results given the\n&gt; &gt; node activation values are reset to 0.0 and precisely the same input is\n&gt; &gt; submitted for the same number of activation passes.\n&gt; &gt;\n&gt; &gt; I get that the network graph can have cycles, as in recurrent\n&gt; &gt; connections. However, those have no relevance to activation order or\n&gt; &gt; cause any sort of &quot;loop&quot; in a straightforward ANN implementation. So, I\n&gt; &gt; am getting confused about where and how an &quot;endless loop&quot; could form.\n&gt; &gt; Perhaps they are talking about the network output never stabilizing to\n&gt; &gt; within some stable value ranges when activating it repeatedly with the\n&gt; &gt; same input. That&#39;s to be expected in a network with enough recurrent\n&gt; &gt; connections - non-uniformity in the output following activations with\n&gt; &gt; the same input. Each additional recurrent connection increases the\n&gt; &gt; &quot;echos from the past&quot; causing a stable output cycle to become less and\n&gt; &gt; less probable.\n&gt; &gt;\n&gt; &gt; Said another way, a single activation of an ANN, with or without\n&gt; &gt; recurrent connections, will results in exactly the same number of node\n&gt; &gt; activation calculations each time it is told to process input. There\n&gt; &gt; should not be any variability to the number of node activations AT ALL.\n&gt; &gt; If so, then some sort of different activation strategy is being\n&gt; &gt; employed. And if so, what is it? And why?\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; Jim\n&gt; &gt;\n&gt; &gt;\n&gt; &gt; petar_chervenski wrote:\n&gt; &gt; &gt;\n&gt; &gt; &gt; It is about the loop in which you calculate the longest path from an\n&gt; &gt; &gt; input node to an output node. Not the activation loop in which you\n&gt; &gt; &gt; activate the network.\n&gt; &gt; &gt;\n&gt; &gt; &gt; Peter\n&gt; &gt; &gt;\n&gt; &gt; &gt; --- In neat@yahoogroups.com &lt;mailto:neat%40yahoogroups.com&gt; \n&gt; &lt;mailto:neat%40yahoogroups.com&gt;, Jim\n&gt; &gt; &gt; O&#39;Flaherty &lt;jim_oflaherty_jr@&gt;\n&gt; &gt; &gt; wrote:\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; Ken,\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; I am confused how you could end up in an endless activation loop. If\n&gt; &gt; &gt; you\n&gt; &gt; &gt; &gt; are moving from the input nodes forward through the hidden nodes to\n&gt; &gt; &gt; the\n&gt; &gt; &gt; &gt; output nodes as a state calculation progression, there would be no\n&gt; &gt; &gt; need\n&gt; &gt; &gt; &gt; to worry about activation loops - you would only calculate the value\n&gt; &gt; &gt; of\n&gt; &gt; &gt; &gt; each node once in a single pass. The point of a recurrent connection\n&gt; &gt; &gt; is\n&gt; &gt; &gt; &gt; to carry state between full network activations. So, the value\n&gt; &gt; &gt; provided\n&gt; &gt; &gt; &gt; by a recurrent connection would not be used until the next\n&gt; &gt; &gt; activation\n&gt; &gt; &gt; &gt; pass (assuming all the nodes from the previous pass have not be\n&gt; &gt; &gt; &quot;zeroed\n&gt; &gt; &gt; &gt; out&quot;).\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; How is it there is an endless loop?\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; Jim\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; Kenneth Stanley wrote:\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; Yes I have heard about this problem coming up in the XOR\n&gt; &gt; &gt; experiment.\n&gt; &gt; &gt; &gt; &gt; Most neuroevolution experiments are not classification experiments\n&gt; &gt; &gt; &gt; &gt; (i.e. they don&#39;t have a &quot;final&quot; output), or they allow recurrent\n&gt; &gt; &gt; &gt; &gt; connections, and therefore do not require depth to be computed.\n&gt; &gt; &gt; &gt; &gt; Therefore, this problem will not come up in most expeirments.\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; However, XOR is a benchmark classification problem that is only\n&gt; &gt; &gt; meant\n&gt; &gt; &gt; &gt; &gt; to be attempted by feedforward networks so it needs to have depth\n&gt; &gt; &gt; &gt; &gt; computed. It appears that my attempts to keep the network\n&gt; &gt; &gt; feedforward\n&gt; &gt; &gt; &gt; &gt; in all cases is not perfect, so sometimes when a loop arises, it\n&gt; &gt; &gt; sends\n&gt; &gt; &gt; &gt; &gt; the depth computation into an infinite loop. I have not had time\n&gt; &gt; &gt; to\n&gt; &gt; &gt; &gt; &gt; think about the most elegant solution to this problem: Maybe it\n&gt; &gt; &gt; should\n&gt; &gt; &gt; &gt; &gt; be a stronger check on recurrence, perhaps entirely different from\n&gt; &gt; &gt; how\n&gt; &gt; &gt; &gt; &gt; it works now. Or perhaps it should be a fixed abort-iteration for\n&gt; &gt; &gt; the\n&gt; &gt; &gt; &gt; &gt; depth routine.\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; If someone does feel they have an elegant bit of code to address\n&gt; &gt; &gt; the\n&gt; &gt; &gt; &gt; &gt; issue, I will be happy to take a look.\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; In any case, it should not cause serious problems in general. I\n&gt; &gt; &gt; &gt; &gt; apologize for any inconvenience.\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; ken\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; --- In neat@yahoogroups.com &lt;mailto:neat%40yahoogroups.com&gt; \n&gt; &lt;mailto:neat%40yahoogroups.com&gt;\n&gt; &gt; &gt; &lt;mailto:neat%40yahoogroups.com&gt;,\n&gt; &gt; &gt; &gt; &gt; &quot;petar_chervenski&quot; &lt;petar_chervenski@&gt;\n&gt; &gt; &gt; &gt; &gt; wrote:\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; Hi Cesar,\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; I know of this problem. It is obvious that depth cannot be\n&gt; &gt; &gt; determined\n&gt; &gt; &gt; &gt; &gt; &gt; in a recurrent network, but in general it depends, what is your\n&gt; &gt; &gt; way to\n&gt; &gt; &gt; &gt; &gt; &gt; handle the situation. Try improving the add_link() code so that\n&gt; &gt; &gt; the\n&gt; &gt; &gt; &gt; &gt; &gt; right nodes are picked up when trying to add a forward or a\n&gt; &gt; &gt; recurrent\n&gt; &gt; &gt; &gt; &gt; &gt; connection. This is a good solution but in general the problem\n&gt; &gt; &gt; with\n&gt; &gt; &gt; &gt; &gt; &gt; looped networks cannot be avoided. Suppose you have 3 hidden\n&gt; &gt; &gt; nodes, A,\n&gt; &gt; &gt; &gt; &gt; &gt; B, and C. If you link these like A-&gt;B, B-&gt;C, C-&gt;A, it is a loop\n&gt; &gt; &gt; in the\n&gt; &gt; &gt; &gt; &gt; &gt; network, even though all connections are meant to be forward.\n&gt; &gt; &gt; &gt; &gt; &gt; The best solution in my opinion is to put a limit on the\n&gt; &gt; &gt; possible\n&gt; &gt; &gt; &gt; &gt; &gt; depth, say 32, if the depth exceeds 32, quit the recursion and\n&gt; &gt; &gt; &gt; &gt; &gt; activate the network 32 times. It slows things down but at least\n&gt; &gt; &gt; it\n&gt; &gt; &gt; &gt; &gt; &gt; will not hurt evolution as if you penalize looped networks.\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; Peter\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; --- In neat@yahoogroups.com &lt;mailto:neat%40yahoogroups.com&gt; \n&gt; &lt;mailto:neat%40yahoogroups.com&gt;\n&gt; &gt; &gt; &lt;mailto:neat%40yahoogroups.com&gt;,\n&gt; &gt; &gt; &quot;Cesar\n&gt; &gt; &gt; &gt; &gt; G. Miguel&quot; &lt;cesar.gomes@&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; wrote:\n&gt; &gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; Hi all,\n&gt; &gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; I&#39;m not sure if someone else has notice this &quot;bug&quot; in rtNEAT,\n&gt; &gt; &gt; but\n&gt; &gt; &gt; &gt; &gt; &gt; the\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; max_depth() method in network.cpp has the potential to be\n&gt; &gt; &gt; forever in\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; loop if a recurrent link is added in a feedforward topology,\n&gt; &gt; &gt; e.g.,\n&gt; &gt; &gt; &gt; &gt; &gt; the\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; XOR experiment (and that can happen even when the\n&gt; &gt; &gt; recur_only_prob\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; parameter is set to zero). A real example is attached.\n&gt; &gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; It seems to happen in 1 out of 10 runs. The max_depth() method\n&gt; &gt; &gt; calls\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; depth() in nnode.cpp, which should return the max depth of\n&gt; &gt; &gt; that\n&gt; &gt; &gt; &gt; &gt; &gt; node.\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; But it can get trapped in a loop if any recurrent link is\n&gt; &gt; &gt; present\n&gt; &gt; &gt; &gt; &gt; &gt; (as\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; it is commented out in the source: DEPTH NOT DETERMINED FOR\n&gt; &gt; &gt; NETWORK\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; WITH LOOP).\n&gt; &gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; For those cases I have to force a return if an endless loop is\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; detected and then set the chromosome&#39;s fitness to zero in\n&gt; &gt; &gt; order to\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; continue.\n&gt; &gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; Has anyone dealed with that before?\n&gt; &gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; []&#39;s\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; Cesar\n&gt; &gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt; &gt;\n&gt; &gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt; &gt;\n&gt; &gt;\n&gt;\n&gt;  \n\r\n--------------020908010804060705050406\r\nContent-Type: text/html; charset=ISO-8859-1\r\nContent-Transfer-Encoding: 7bit\r\n\r\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta content=&quot;text/html;charset=ISO-8859-1&quot; http-equiv=&quot;Content-Type&quot;&gt;\n&lt;/head&gt;\n&lt;body bgcolor=&quot;#ffffff&quot; text=&quot;#000000&quot;&gt;\nJoel,&lt;br&gt;\n&lt;br&gt;\nAh. Okay. That&#39;s interesting.&lt;br&gt;\n&lt;br&gt;\nWell, I have not looked at the C++ code, so I don&#39;t know how it is\nimplemented. I am confused what it means by activating enough times so\nthe input makes it to the output layer. In my implementation, the input\nalways makes it to the output layer in a single pass. What does it mean\nto activate a network where the signals are not propagated all the way\nfrom the input nodes to the output nodes? I&#39;m confused, how do you\npartially activate the network? And why would you want to do that? It\nseems the output wouldn&#39;t make any sense unless all of the signals had\nall been propagated completely throughout the network.&lt;br&gt;\n&lt;br&gt;\nAs to determining depth - does that mean the longest sequence of\nfeed-forward connections between an input node and an output node? If\nso, that is a pretty simple graph traversal formula. And if recurrent\nconnections are marked (I have them marked in my implementation), then\nwhen exploring the graph to calculate depth, just ignore traversing\nnodes marked as recurrent, and that ought to kill any cycles and/or\nendless loops. If recurrent nodes are not marked, is there an aging\nvalue on the nodes such that you know that a node with an earlier age\nwill for sure be activated before one with an later age? If so, then\nyou can do the graph traversal including forward nodes as only those\n&quot;older&quot; than the current one being traversed. If there is no means to\nindicate dependency direction separate from the weights linking the\nnodes, then you can generate your own dependency array on the fly, and\nthen use that to do your pathing calculations.&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\nJim&lt;br&gt;\n&lt;br&gt;\n&lt;br&gt;\njoel278 wrote:\n&lt;blockquote cite=&quot;mid:genj8f+fn1k@...&quot; type=&quot;cite&quot;&gt;\n  &lt;div id=&quot;ygrp-text&quot;&gt;\n  &lt;p&gt;Hey Jim,&lt;br&gt;\n  &lt;br&gt;\nI think there is some confusion here because the issue in question&lt;br&gt;\nis specific to the rtNEAT implementation (the bug may be present in &lt;br&gt;\nthe original C++ version as well, although I haven&#39;t checked).&lt;br&gt;\n  &lt;br&gt;\nIn rtNEAT, there is a function that calculates the maximum depth of&lt;br&gt;\na network, and is meant only to be applied to non-recurrent networks.&lt;br&gt;\nThis is useful if you are trying to query a net efficiently, so you&lt;br&gt;\nonly have to activate it enough times for the input signals to &lt;br&gt;\npropagate all the way to the output.&lt;br&gt;\n  &lt;br&gt;\nHowever, there is a bug in the rtNEAT implementation such that&lt;br&gt;\neven with recurrent connections disabled, somehow they can still seep&lt;br&gt;\ninto a network occasionally. &lt;br&gt;\n  &lt;br&gt;\nIf this happens, and the maximum depth function is called on a net&lt;br&gt;\nwith recurrent connections, an endless loop can result. This is&lt;br&gt;\nbecause the function was designed only to work with non-recurrent&lt;br&gt;\nnetworks.&lt;br&gt;\n  &lt;br&gt;\nTom, you are right in that this method cannot easily be extended to&lt;br&gt;\ndealing with recurrent networks.&lt;br&gt;\n  &lt;br&gt;\nOften the strategy that you mention is applied, arbitrarily activating&lt;br&gt;\nthe net a reasonable number of times. It is an&lt;br&gt;\neasy way to avoid this bug until it is fixed.&lt;br&gt;\n  &lt;br&gt;\nJoel&lt;br&gt;\n  &lt;br&gt;\n--- In &lt;a moz-do-not-send=&quot;true&quot; href=&quot;mailto:neat%40yahoogroups.com&quot;&gt;neat@yahoogroups.&lt;wbr&gt;com&lt;/a&gt;,\nJim O&#39;Flaherty &lt;jim_oflaherty_&lt;wbr&gt;jr@...&gt; wrote:&lt;br&gt;\n&gt;&lt;br&gt;\n&gt; Peter,&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; That doesn&#39;t make sense to me. Cesar&#39;s comments indicate he has a &lt;br&gt;\n&gt; similar implementation to mine. Basically, every node&#39;s value in a\n  &lt;br&gt;\n&gt; single instance of an ANN is calculated just once on an activation&lt;br&gt;\npass. &lt;br&gt;\n&gt; When the node is calculated, each of the nodes attached to it as&lt;br&gt;\n&quot;input&quot; &lt;br&gt;\n&gt; are used (whether they have been activated in this pass, or hold a\n  &lt;br&gt;\n&gt; residual value from the previous pass) to calculate it&#39;s current\nvalue. &lt;br&gt;\n&gt; And assuming the ordering of the activations is lined up by\ndependency &lt;br&gt;\n&gt; and they by node age, the network ought to activate\ndeterministically &lt;br&gt;\n&gt; meaning that starting with an empty network (all node activation\nvalues &lt;br&gt;\n&gt; are set to 0.0), providing the same input and making several\nactivation &lt;br&gt;\n&gt; passes ought to be able to return reliably repeatable results\ngiven the &lt;br&gt;\n&gt; node activation values are reset to 0.0 and precisely the same\ninput is &lt;br&gt;\n&gt; submitted for the same number of activation passes.&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; I get that the network graph can have cycles, as in recurrent &lt;br&gt;\n&gt; connections. However, those have no relevance to activation order\nor &lt;br&gt;\n&gt; cause any sort of &quot;loop&quot; in a straightforward ANN implementation.\nSo, I &lt;br&gt;\n&gt; am getting confused about where and how an &quot;endless loop&quot; could\nform. &lt;br&gt;\n&gt; Perhaps they are talking about the network output never\nstabilizing to &lt;br&gt;\n&gt; within some stable value ranges when activating it repeatedly with\nthe &lt;br&gt;\n&gt; same input. That&#39;s to be expected in a network with enough\nrecurrent &lt;br&gt;\n&gt; connections - non-uniformity in the output following activations\nwith &lt;br&gt;\n&gt; the same input. Each additional recurrent connection increases the\n  &lt;br&gt;\n&gt; &quot;echos from the past&quot; causing a stable output cycle to become less\nand &lt;br&gt;\n&gt; less probable.&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; Said another way, a single activation of an ANN, with or without &lt;br&gt;\n&gt; recurrent connections, will results in exactly the same number of\nnode &lt;br&gt;\n&gt; activation calculations each time it is told to process input.\nThere &lt;br&gt;\n&gt; should not be any variability to the number of node activations AT\nALL. &lt;br&gt;\n&gt; If so, then some sort of different activation strategy is being &lt;br&gt;\n&gt; employed. And if so, what is it? And why?&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; &lt;br&gt;\n&gt; Jim&lt;br&gt;\n&gt; &lt;br&gt;\n&gt; &lt;br&gt;\n&gt; petar_chervenski wrote:&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt; &gt; It is about the loop in which you calculate the longest path\nfrom an&lt;br&gt;\n&gt; &gt; input node to an output node. Not the activation loop in\nwhich you&lt;br&gt;\n&gt; &gt; activate the network.&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt; &gt; Peter&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt; &gt; --- In &lt;a moz-do-not-send=&quot;true&quot;\n href=&quot;mailto:neat%40yahoogroups.com&quot;&gt;neat@yahoogroups.&lt;wbr&gt;com&lt;/a&gt;\n&lt;&lt;a class=&quot;moz-txt-link-freetext&quot; href=&quot;mailto:neat%&quot;&gt;mailto:neat%&lt;/a&gt;&lt;wbr&gt;40yahoogroups.&lt;wbr&gt;com&gt;, Jim &lt;br&gt;\n&gt; &gt; O&#39;Flaherty &lt;jim_oflaherty_&lt;wbr&gt;jr@&gt;&lt;br&gt;\n&gt; &gt; wrote:&lt;br&gt;\n&gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; Ken,&lt;br&gt;\n&gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; I am confused how you could end up in an endless\nactivation loop. If&lt;br&gt;\n&gt; &gt; you&lt;br&gt;\n&gt; &gt; &gt; are moving from the input nodes forward through the\nhidden nodes to&lt;br&gt;\n&gt; &gt; the&lt;br&gt;\n&gt; &gt; &gt; output nodes as a state calculation progression, there\nwould be no&lt;br&gt;\n&gt; &gt; need&lt;br&gt;\n&gt; &gt; &gt; to worry about activation loops - you would only\ncalculate the value&lt;br&gt;\n&gt; &gt; of&lt;br&gt;\n&gt; &gt; &gt; each node once in a single pass. The point of a\nrecurrent connection&lt;br&gt;\n&gt; &gt; is&lt;br&gt;\n&gt; &gt; &gt; to carry state between full network activations. So, the\nvalue&lt;br&gt;\n&gt; &gt; provided&lt;br&gt;\n&gt; &gt; &gt; by a recurrent connection would not be used until the\nnext&lt;br&gt;\n&gt; &gt; activation&lt;br&gt;\n&gt; &gt; &gt; pass (assuming all the nodes from the previous pass have\nnot be&lt;br&gt;\n&gt; &gt; &quot;zeroed&lt;br&gt;\n&gt; &gt; &gt; out&quot;).&lt;br&gt;\n&gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; How is it there is an endless loop?&lt;br&gt;\n&gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; Jim&lt;br&gt;\n&gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; Kenneth Stanley wrote:&lt;br&gt;\n&gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; Yes I have heard about this problem coming up in\nthe XOR&lt;br&gt;\n&gt; &gt; experiment.&lt;br&gt;\n&gt; &gt; &gt; &gt; Most neuroevolution experiments are not\nclassification experiments&lt;br&gt;\n&gt; &gt; &gt; &gt; (i.e. they don&#39;t have a &quot;final&quot; output), or they\nallow recurrent&lt;br&gt;\n&gt; &gt; &gt; &gt; connections, and therefore do not require depth to\nbe computed.&lt;br&gt;\n&gt; &gt; &gt; &gt; Therefore, this problem will not come up in most\nexpeirments.&lt;br&gt;\n&gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; However, XOR is a benchmark classification problem\nthat is only&lt;br&gt;\n&gt; &gt; meant&lt;br&gt;\n&gt; &gt; &gt; &gt; to be attempted by feedforward networks so it needs\nto have depth&lt;br&gt;\n&gt; &gt; &gt; &gt; computed. It appears that my attempts to keep the\nnetwork&lt;br&gt;\n&gt; &gt; feedforward&lt;br&gt;\n&gt; &gt; &gt; &gt; in all cases is not perfect, so sometimes when a\nloop arises, it&lt;br&gt;\n&gt; &gt; sends&lt;br&gt;\n&gt; &gt; &gt; &gt; the depth computation into an infinite loop. I have\nnot had time&lt;br&gt;\n&gt; &gt; to&lt;br&gt;\n&gt; &gt; &gt; &gt; think about the most elegant solution to this\nproblem: Maybe it&lt;br&gt;\n&gt; &gt; should&lt;br&gt;\n&gt; &gt; &gt; &gt; be a stronger check on recurrence, perhaps entirely\ndifferent from&lt;br&gt;\n&gt; &gt; how&lt;br&gt;\n&gt; &gt; &gt; &gt; it works now. Or perhaps it should be a fixed\nabort-iteration for&lt;br&gt;\n&gt; &gt; the&lt;br&gt;\n&gt; &gt; &gt; &gt; depth routine.&lt;br&gt;\n&gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; If someone does feel they have an elegant bit of\ncode to address&lt;br&gt;\n&gt; &gt; the&lt;br&gt;\n&gt; &gt; &gt; &gt; issue, I will be happy to take a look.&lt;br&gt;\n&gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; In any case, it should not cause serious problems\nin general. I&lt;br&gt;\n&gt; &gt; &gt; &gt; apologize for any inconvenience.&lt;br&gt;\n&gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; ken&lt;br&gt;\n&gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; --- In &lt;a moz-do-not-send=&quot;true&quot;\n href=&quot;mailto:neat%40yahoogroups.com&quot;&gt;neat@yahoogroups.&lt;wbr&gt;com&lt;/a&gt;\n&lt;&lt;a class=&quot;moz-txt-link-freetext&quot; href=&quot;mailto:neat%&quot;&gt;mailto:neat%&lt;/a&gt;&lt;wbr&gt;40yahoogroups.&lt;wbr&gt;com&gt; &lt;br&gt;\n&gt; &gt; &lt;&lt;a class=&quot;moz-txt-link-freetext&quot; href=&quot;mailto:neat%&quot;&gt;mailto:neat%&lt;/a&gt;&lt;wbr&gt;40yahoogroups.&lt;wbr&gt;com&gt;,&lt;br&gt;\n&gt; &gt; &gt; &gt; &quot;petar_chervenski&quot; &lt;petar_chervenski@&lt;wbr&gt;&gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; wrote:&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; Hi Cesar,&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; I know of this problem. It is obvious that\ndepth cannot be&lt;br&gt;\n&gt; &gt; determined&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; in a recurrent network, but in general it\ndepends, what is your&lt;br&gt;\n&gt; &gt; way to&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; handle the situation. Try improving the\nadd_link() code so that&lt;br&gt;\n&gt; &gt; the&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; right nodes are picked up when trying to add a\nforward or a&lt;br&gt;\n&gt; &gt; recurrent&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; connection. This is a good solution but in\ngeneral the problem&lt;br&gt;\n&gt; &gt; with&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; looped networks cannot be avoided. Suppose you\nhave 3 hidden&lt;br&gt;\n&gt; &gt; nodes, A,&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; B, and C. If you link these like A-&gt;B,\nB-&gt;C, C-&gt;A, it is a loop&lt;br&gt;\n&gt; &gt; in the&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; network, even though all connections are meant\nto be forward.&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; The best solution in my opinion is to put a\nlimit on the&lt;br&gt;\n&gt; &gt; possible&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; depth, say 32, if the depth exceeds 32, quit\nthe recursion and&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; activate the network 32 times. It slows things\ndown but at least&lt;br&gt;\n&gt; &gt; it&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; will not hurt evolution as if you penalize\nlooped networks.&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; Peter&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; --- In &lt;a moz-do-not-send=&quot;true&quot;\n href=&quot;mailto:neat%40yahoogroups.com&quot;&gt;neat@yahoogroups.&lt;wbr&gt;com&lt;/a&gt;\n&lt;&lt;a class=&quot;moz-txt-link-freetext&quot; href=&quot;mailto:neat%&quot;&gt;mailto:neat%&lt;/a&gt;&lt;wbr&gt;40yahoogroups.&lt;wbr&gt;com&gt; &lt;br&gt;\n&gt; &gt; &lt;&lt;a class=&quot;moz-txt-link-freetext&quot; href=&quot;mailto:neat%&quot;&gt;mailto:neat%&lt;/a&gt;&lt;wbr&gt;40yahoogroups.&lt;wbr&gt;com&gt;,&lt;br&gt;\n&gt; &gt; &quot;Cesar&lt;br&gt;\n&gt; &gt; &gt; &gt; G. Miguel&quot; &lt;cesar.gomes@&lt;wbr&gt;&gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; wrote:&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; Hi all,&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; I&#39;m not sure if someone else has notice\nthis &quot;bug&quot; in rtNEAT,&lt;br&gt;\n&gt; &gt; but&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; the&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; max_depth() method in network.cpp has the\npotential to be&lt;br&gt;\n&gt; &gt; forever in&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; loop if a recurrent link is added in a\nfeedforward topology,&lt;br&gt;\n&gt; &gt; e.g.,&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; the&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; XOR experiment (and that can happen even\nwhen the&lt;br&gt;\n&gt; &gt; recur_only_prob&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; parameter is set to zero). A real example\nis attached.&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; It seems to happen in 1 out of 10 runs.\nThe max_depth() method&lt;br&gt;\n&gt; &gt; calls&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; depth() in nnode.cpp, which should return\nthe max depth of&lt;br&gt;\n&gt; &gt; that&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; node.&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; But it can get trapped in a loop if any\nrecurrent link is&lt;br&gt;\n&gt; &gt; present&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; (as&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; it is commented out in the source: DEPTH\nNOT DETERMINED FOR&lt;br&gt;\n&gt; &gt; NETWORK&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; WITH LOOP).&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; For those cases I have to force a return\nif an endless loop is&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; detected and then set the chromosome&#39;s\nfitness to zero in&lt;br&gt;\n&gt; &gt; order to&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; continue.&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; Has anyone dealed with that before?&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; []&#39;s&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt; Cesar&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt; &gt;&lt;br&gt;\n&gt; &gt; &gt;&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt; &gt;&lt;br&gt;\n&gt;&lt;br&gt;\n  &lt;br&gt;\n  &lt;/p&gt;\n  &lt;/div&gt;\n&lt;!--End group email --&gt; &lt;/blockquote&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\r\n--------------020908010804060705050406--\r\n\n"}}